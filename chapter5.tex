\documentclass[12pt]{book}

\newcommand{\thetitle}{Think Java: How to Think Like a Computer Scientist}
\title{\thetitle}

\newcommand{\theauthors}{Allen Downey and Chris Mayfield}
\author{\theauthors}

\newcommand{\theversion}{Version 6.0 Draft -- \today}
\date{\theversion}

\usepackage{geometry}
\geometry{
    width=5.5in,
    height=8.5in,
    hmarginratio=3:2,
    vmarginratio=1:1,
    includehead=true,
    headheight=15pt
}

% paragraph spacing
\setlength{\parindent}{0pt}                      % 17.62482pt
\setlength{\parskip}{12pt plus 4pt minus 4pt}    % 0.0pt plus 1.0pt
\linespread{1.05}
\def\arraystretch{1.5}

% list spacing
\setlength{\topsep}{5pt plus 2pt minus 3pt}      % 10.0pt plus 4.0pt minus 6.0pt
\setlength{\partopsep}{-6pt plus 2pt minus 2pt}  %  3.0pt plus 2.0pt minus 2.0pt
\setlength{\itemsep}{0pt}                        %  5.0pt plus 2.5pt minus 1.0pt

% these are copied from tex/latex/base/book.cls
% all I changed is afterskip
\makeatletter
\renewcommand{\section}{\@startsection {section}{1}{\z@}%
    {-3.5ex \@plus -1ex \@minus -.2ex}%
    {0.7ex \@plus.2ex}%
    {\normalfont\Large\bfseries}}
\renewcommand\subsection{\@startsection{subsection}{2}{\z@}%
    {-3.25ex\@plus -1ex \@minus -.2ex}%
    {0.3ex \@plus .2ex}%
    {\normalfont\large\bfseries}}
\renewcommand\subsubsection{\@startsection{subsubsection}{3}{\z@}%
    {-3.25ex\@plus -1ex \@minus -.2ex}%
    {0.3ex \@plus .2ex}%
    {\normalfont\normalsize\bfseries}}
\makeatother

% table of contents vertical spacing
\usepackage{tocloft}
\setlength\cftparskip{8pt plus 4pt minus 4pt}

% The following line adds a little extra space to the column
% in which the Section numbers appear in the table of contents
\makeatletter
\renewcommand{\l@section}{\@dottedtocline{1}{1.5em}{3.0em}}
\makeatother

% customize page headers
\usepackage{fancyhdr}
\pagestyle{fancyplain}
\renewcommand{\chaptermark}[1]{\markboth{Chapter \thechapter ~~ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection ~~ #1}}
\lhead[\fancyplain{}{\bfseries\thepage}]%
      {\fancyplain{}{\bfseries\rightmark}}
\rhead[\fancyplain{}{\bfseries\leftmark}]%
      {\fancyplain{}{\bfseries\thepage}}
\cfoot{}
%\rfoot{\textcolor{gray}{\tiny ThinkJava Draft \today}}

% balanced index with TOC entry
\usepackage{makeidx}
\makeindex
%\usepackage[totoc]{idxlayout}

% automatically index glossary terms
\newcommand{\term}[1]{%
\index{#1}
\item[#1:]}
% TODO: doesn't work with plastex
%\newcommand{\term}[1]{\item[#1:]}

% where to find graphics
\usepackage{graphicx}
%\graphicspath{{figs/}}

%% tweak spacing of figures and captions
%\usepackage{floatrow}
%\usepackage{caption}
%\captionsetup{
%    font=small,
%    labelformat=empty,
%    justification=centering,
%    skip=4pt
%}

% format end of chapter excercises
\usepackage{amsmath}
\usepackage{amsthm}
\newtheoremstyle{exercise}
  {12pt}        % space above
  {12pt}        % space below
  {}            % body font
  {}            % indent amount
  {\bfseries}   % head font
  {}            % punctuation
  {12pt}        % head space
  {}            % custom head
\theoremstyle{exercise}
\newtheorem{exercise}{Exercise}[chapter]

% colors for code listings and output
\usepackage{xcolor}
\definecolor{bgcolor}{HTML}{FAFAFA}
\definecolor{comment}{HTML}{007C00}
\definecolor{keyword}{HTML}{0000FF}
\definecolor{strings}{HTML}{B20000}

% syntax highlighting in code listings
\usepackage{textcomp}
\usepackage{listings}
\lstset{
    language=java,
    basicstyle=\ttfamily,
    backgroundcolor=\color{bgcolor},
    commentstyle=\color{comment},
    keywordstyle=\color{keyword},
    stringstyle=\color{strings},
    columns=fullflexible,
    keepspaces=true,
    showstringspaces=false,
    upquote=true,
    aboveskip=\parskip,
    belowskip=\parskip
}

% code listing environments
\lstnewenvironment{code}
{\minipage{\linewidth}}
{\endminipage}
\lstnewenvironment{stdout}
{\lstset{commentstyle=,keywordstyle=,stringstyle=}\minipage{\linewidth}}
{\endminipage}

% pdf hyperlinks, table of contents, and document properties
\usepackage[pdftex]{hyperref}
\hypersetup{%
  pdftitle={\thetitle},
  pdfauthor={\theauthors},
  pdfsubject={\theversion},
  pdfkeywords={},
  bookmarksopen=false,
  colorlinks=true,
  citecolor=black,
  filecolor=black,
  linkcolor=black,
  urlcolor=blue
}

% inline syntax formatting
\newcommand{\java}[1]{\lstinline{#1}} %\end{
%\newcommand{\java}[1]{\verb"#1"}
%\newcommand{\java}[1]{{\tt #1}}

\begin{document}
\setcounter{chapter}{4}

\chapter{Decisions and logic}

\index{boolean}
\index{type!boolean}

During the mid 19th century, the mathematician George Boole developed a formal system for representing logic which today is known as Boolean algebra.
In contrast to traditional algebra that deals with real numbers and arithmetic operations like addition and multiplication, Boolean algebra is based on the values {\it true} and {\it false} and logic operations like {\it and}, {\it or}, and {\it not}.
In Java, the values \java{true} and \java{false} belong to the data type \java{boolean}.

%{\tt true} and {\tt false} are special values in Java, and together they make up a type called {\bf boolean}.
%You might recall that when I defined a type, I said it was a set of values.
%In the case of {\tt int}s, {\tt double}s and {\tt String}s, those sets are pretty big.
%For {\tt boolean}s, there are only two values.
%The values {\tt true} and {\tt false} are keywords in Java, so they may appear in a different color, depending on your development environment.


\section{Relational operators}

\index{operator!relational}
\index{relational operator}
\index{operator!comparison}
\index{comparison operator}

Most operations we have seen produce results that are the same type as their operands.
For example, the \java{+} operator takes two \java{int}s and produces an \java{int}, or two \java{double}s and produces a \java{double}, etc.
In contrast, {\bf relational operators} compare numeric types like \java{int}s and \java{double}s and return either \java{true} or \java{false}.

\begin{code}
    x == y          // x is equal to y
    x != y          // x is not equal to y
    x > y           // x is greater than y
    x < y           // x is less than y
    x >= y          // x is greater than or equal to y
    x <= y          // x is less than or equal to y
\end{code}

Although these operations are probably familiar to you, the syntax Java uses is a little different from mathematical symbols like $=$, $\neq$ and $\le$.
A common error is to use a single {\tt =} instead of a double {\tt ==}.
Remember that {\tt =} is the assignment operator and {\tt ==} is a comparison operator.
Also, there is no such thing as {\tt =<} or {\tt =>} operators.

The two sides of a relational operator have to be compatible.
For example, the expression \java{5 < "6"} is invalid because \java{5} is an \java{int} and \java{"6"} is a \java{String}.
When comparing values of different numeric types, Java applies the same conversion rules we saw previously with the assignment operator.
For example, when evaluating the expression \java{5 < 6.0}, Java automatically converts the \java{5} to \java{5.0}.

The operators {\tt ==} and {\tt !=} work with Strings too, but they don't do what you expect.
And the other relational operators don't do anything at all with Strings.
To compare two strings, you should use methods like \java{String.equals} or \java{String.compareTo}:

\begin{code}
    String fruit1 = "Apple";
    String fruit2 = "Orange";
    System.out.println(fruit1.equals(fruit2));
    System.out.println(fruit1.compareTo(fruit2));
\end{code}

\subsection{Flag variables}

\index{expression!boolean}

Recall from Section~\ref{sec:arithops} that expressions are typically a combination of variables and operators.
More generally, an expression is a language construct that evaluates to a single value.
Expressions can be as simple as the literal \java{0} or more complex like \java{Math.cos(angle + Math.PI / 2)}.
Boolean expressions and variables work just like other types of expressions and variables:

\begin{code}
    boolean flag;
    flag = true;
    boolean testResult = false;
\end{code}

\index{initialization}
\index{statement!initialization}

The first line is a variable declaration, the second is an assignment, and the third is an initialization.
Since relational operators evaluate to a \java{boolean} value, you can store the result of a comparison in a variable:

\begin{code}
    boolean evenFlag = (n % 2 == 0);    // true if n is even
    boolean positiveFlag = (x > 0);     // true if x is positive
\end{code}

The parentheses are unnecessary, but they make the code easier to read.
A variable used in this way is called a {\bf flag}, because it signals the presence or absence of some condition.
You can use flag variables as part of a conditional statement later:

\begin{code}
    if (evenFlag) {
        System.out.println("n was even when I checked it");
    }
\end{code}

Notice that you don't need to say \java{if (evenFlag == true)}.
Since \java{evenFlag} is a \java{boolean}, it's already a condition.

\section{Conditional operators}

\index{conditional operator}
\index{operator!conditional}
\index{logical operator}
\index{operator!logical}

Java has three {\bf conditional operators}: AND, OR, and NOT, which are denoted by the symbols \java{&&}, \java{||}, and \java{!}.
The semantics of these operators are similar to their meaning in English.

For example \java{x > 0 && x < 10} is true when \java{x} is greater than zero AND less than 10.
The expression \java{evenFlag || n \% 3 == 0} is true if {\it either} condition is true, that is, if \java{evenFlag} is true OR the number \java{n} is divisible by 3.
Finally, the NOT operator inverts a boolean expression.
So \java{!evenFlag} is \java{true} if \java{evenFlag} is \java{false}---regardless whether the original number is odd.

\index{short circuit}

It's important to remember that conditional operators have a {\bf short circuit} property, meaning they only evaluate the second operand when necessary.
For example, \java{true || anything} is always true, so Java does not need to evaluate the expression \java{anything}.
Likewise, \java{false && anything} is always false.
The short circuit feature is particularly efficient when \java{anything} is a method call, because Java eliminates the need to call that method.

\index{De Morgan's laws}

When solving logic problems using conditional operators, you will often need to negate AND and OR operations.
{\bf De Morgan's laws} show how to simplify such expressions:

\begin{itemize}
\item \java{!(A && B)} ~is the same as~ \java{!A || !B}
\item \java{!(A || B)} ~is the same as~ \java{!A && !B}
\end{itemize}

In other words, negating a conditional expression is the same as negating each term and changing the operator.
Note that since the \java{!} operator has higher precedence than \java{&&} and \java{||}, you don't need to put parentheses around the individual terms \java{!A} and \java{!B}.

De Morgan's laws also apply to the relational operators.
In this case, negating each term means using the ``opposite'' relational operator.

\begin{itemize}
\item \java{!(x < 5 && y == 3)} ~is the same as~ \java{x >= 5 || y != 3}
\item \java{!(x >= 1 || y != 7)} ~is the same as~ \java{x < 1 && y == 7}
\end{itemize}

It may help to read these examples out loud in English.
For instance, ``If I don't want x to be less than 5 AND I don't want y to be 3, then I need x to be greater than or equal to 5 OR I need y to be anything but 3.''

\subsection{DrJava interactions}

A good way to gain experience with relational and conditional operators is to practice using them via the Interactions Pane of DrJava.
As shown in Figure~\ref{fig:drjava}, you can declare several variables and {\it interactively} test your logic skills.
Come up with several interesting examples, and try to determine their result before running the code.

\begin{figure}[!h]
\begin{center}
\includegraphics[width=\textwidth]{figs/drjava-logic.png}
\caption{Screenshot of the Interactions Pane in DrJava.}
\label{fig:drjava}
\end{center}
\end{figure}

There is one subtle aspect to using the Interactions feature.
Notice how the variable declarations end with semicolons, but the logic expressions in the following lines do not.
When you don't end an expression (or statement) with a semicolon, DrJava automatically prints its value.

What's nice about this feature is you don't have to create a new class, declare a main method, write arbitrary expressions inside System.out.println statements, save the source file, and get all of your code to compile in advance.
In addition, you can press the up arrow to edit the previous command and experiment with incremental differences.

\index{order of operations}
\index{precedence}

Note also in Figure~\ref{fig:drjava} that the logic expressions do not use any parentheses.
As a general rule, Java first evaluates arithmetic operators, then the relational operators, followed by any conditional operators, and finally the assignment operator.
For more details, do a web search for ``java operator precedence.''


\section{The if-else statement}

\index{decision statement}
\index{statement!if}

To write useful programs, we almost always need to check conditions and react accordingly.
{\bf Decision statements} give us this ability.
We have already seen the simplest form of the \java{if} statement:

\begin{code}
    if (x > 0) {
        System.out.println("x is positive");
    }
\end{code}

The expression in parentheses is called the condition.
If it is true, then the following statements in braces get executed.
If the condition is false, then execution skips over that block of code.
The condition in parentheses can be {\it any} boolean expression.

\index{statement!else}
\index{decision!alternative}

A second form of decision statement is alternative execution, in which there are two possibilities: \java{if} and \java{else}.
The condition determines which one gets executed:

\begin{code}
    if (x % 2 == 0) {
        System.out.println("x is even");
    } else {
        System.out.println("x is odd");
    }
\end{code}

If the remainder when {\tt x} is divided by 2 is zero, then we know that {\tt x} is even, and this code prints a message to that effect.
If the condition is false, the second print statement is executed.
Since the condition must be true or false, exactly one of the alternatives will be executed.

%\label{alternative}
%\index{parity}
%
%To follow up the previous chapter, if you need to check the {\bf parity} (evenness or oddness) of numbers often, you might want to ``wrap'' this code up in a method:
%
%\begin{code}
%    public static void printParity(int x) {
%        if (x % 2 == 0) {
%            System.out.println("x is even");
%        } else {
%            System.out.println("x is odd");
%        }
%    }
%\end{code}
%
%Now you have a method named \java{printParity} that will print an appropriate message for any integer you care to provide.
%In \java{main} you would invoke this method as follows:
%
%\begin{code}
%    printParity(17);
%\end{code}
%
%Always remember that when you invoke a method, you do not have to declare the types of the arguments you provide.
%Java can figure out what type they are.
%You should resist the temptation to write things like:
%
%\begin{code}
%    int number = 17;
%    printParity(int number);        // WRONG!!!
%\end{code}

\index{decision!chained}

Sometimes you want to check for a number of related conditions and choose one of several actions.
One way to do this is by {\bf chaining} a series of \java{if} and \java{else} statements:

\begin{code}
    if (x > 0) {
        System.out.println("x is positive");
    } else if (x < 0) {
        System.out.println("x is negative");
    } else {
        System.out.println("x is zero");
    }
\end{code}

These chains can be as long as you want, although they can be difficult to read if they get out of hand.
One way to make them easier to read is to use standard indentation, as demonstrated in these examples.
If you keep all the statements and braces lined up, you are less likely to make syntax errors.

\index{decision!nested}
\index{nested structure}

In addition to chaining, you can also make complex decisions by {\bf nesting} one decision inside another.
We could have written the previous example as:

\begin{code}
    if (x == 0) {
        System.out.println("x is zero");
    } else {
        if (x > 0) {
            System.out.println("x is positive");
        } else {
            System.out.println("x is negative");
        }
    }
\end{code}

There is now an outer conditional that contains two branches.
The first branch contains a \java{print} statement, but the second branch contains another decision statement.
It has two branches of its own that each contain a \java{print} statement, but they could have been further decision statements as well.

These kinds of nested structures are common, and they can get difficult to read very quickly.
Good indentation is essential to make the structure (or intended structure) apparent to the reader.
Although Java does not require braces for one-line if statements, you should always use them as shown.


\section{The return statement}

\index{return}
\index{statement!return}

The \java{return} statement allows you to terminate a method before you reach the end.
One reason to use it is if you detect an error condition:

\begin{code}
    public static void printLogarithm(double x) {
        if (x <= 0.0) {
            System.err.println("Oops, x must be positive.");
            return;
        }
        double result = Math.log(x);
        System.out.println("The log of x is " + result);
    }
\end{code}

This example defines a method named \java{printLogarithm} that takes a \java{double} value (named \java{x}) as a parameter.
It checks whether \java{x} is less than or equal to zero, in which case it prints an error message and then uses \java{return} to exit the method.
The flow of execution immediately returns to the caller, and the remaining lines of the method are not executed.

\index{System.err}

Notice the floating-point value \java{0.0} on the right side of the condition.
Since \java{x} is a floating-point variable, you should compare it to a floating-point literal.
This example also makes use of \java{System.err}, which is the {\it standard error} output stream.
Operating systems typically distinguish normal output and error output by using a different color.

As a matter of practice, methods should have {\it at most two} return statements: one for the error condition, and another for the final result.
Many methods don't have error conditions, and \java{void} methods don't need an explicit \java{return} at the end.
We will look at the more general use of \java{return} in the next chapter.


\section{Recursive methods}
\label{recursion}

\index{recursion}

We saw in the previous chapter how it is common for one method to invoke another.
But what happens if a method invokes itself?
This idea turns out to be one of the most magical and interesting things a program can do.
It may not be obvious why at this point, but we need to learn the basics first.

\index{recursion}

When a method invokes itself, the process is called {\bf recursion}.
For example, look at the following method:

\begin{code}
    public static void countdown(int n) {
        if (n == 0) {
            System.out.println("Blastoff!");
        } else {
            System.out.println(n);
            countdown(n - 1);
        }
    }
\end{code}

The name of the method is \java{countdown}, and it takes a single integer as a parameter.
If the parameter is zero, it prints the word ``Blastoff.''
Otherwise, it prints the number and then invokes the \java{countdown} method (i.e., itself) passing \java{n - 1} as the argument.

What happens if we invoke \java{countdown(3)} from \java{main}?

\vspace{-1ex}
\begin{quote}
The execution of \java{countdown} begins with \java{n == 3}, and since \java{n} is not zero, it prints the value 3, and then invokes itself...
\begin{quote}
The execution of \java{countdown} begins with \java{n == 2}, and since \java{n} is not zero, it prints the value 2, and then invokes itself...
\begin{quote}
The execution of \java{countdown} begins with \java{n == 1}, and since \java{n} is not zero, it prints the value 1, and then invokes itself...
\begin{quote}
The execution of \java{countdown} begins with \java{n == 0}, and since \java{n} is zero, it prints the word ``Blastoff!'' and then returns.
\end{quote}
The \java{countdown} that got \java{n == 1} returns.
\end{quote}
The \java{countdown} that got \java{n == 2} returns.
\end{quote}
The \java{countdown} that got \java{n == 3} returns.
\end{quote}
\vspace{-1ex}

And then you're back in \java{main}.
So the total output looks like:

\begin{stdout}
3
2
1
Blastoff!
\end{stdout}

As a second example, let's look again at the methods \java{newLine} and \java{threeLine}.

\begin{code}
    public static void newLine() {
        System.out.println();
    }

    public static void threeLine() {
        newLine();
        newLine();
        newLine();
    }
\end{code}

\index{newline}

Although these work, they would not be much help if we wanted to print 2 newlines, or 106.
A better alternative would be:

\begin{code}
    public static void nLines(int n) {
        if (n > 0) {
            System.out.println();
            nLines(n - 1);
        }
    }
\end{code}

This method is similar to \java{countdown}.
As long as \java{n} is greater than zero, it prints a newline and then invokes itself to print \java{n - 1} additional newlines.
The total number of newlines that get printed is \java{1 + (n - 1)}, which by no accident comes out to be exactly \java{n}.


\section{Recursive stack diagrams}

\index{stack diagram}
\index{diagram!stack}

In the previous chapter we used a stack diagram to represent the state of a program during a method invocation.
The same kind of diagram can make it easier to interpret a recursive method.

Remember that every time a method gets called, it creates a new frame that contains a new version of the method's parameters and variables.
The following figure is a stack diagram for countdown, called with \java{n == 3}:

\begin{center}
\includegraphics{figs/stack2.pdf}
\end{center}

Note that this ``stack'' of method calls is upside down.
It's easier to draw stack diagrams from top to bottom, because it's not always clear how much vertical space you will need.

The stack frame for \java{main} is empty because \java{main} does not have any variables.
Technically speaking, \java{main} does have the parameter \java{args} for its command-line arguments.
But since we're not using that parameter, we'll omit it from the diagram for simplicity.

There is one frame for \java{main} and four frames for \java{countdown}, each with a different value for the parameter \java{n}.
The top of the stack, \java{countdown} with \java{n == 0}, is called the {\bf base case}.
It does not make a recursive call, so there are no more frames for \java{countdown}.

This type of recursion is essentially a simple loop.
We'll see in a couple chapters how to accomplish that with a \java{while} statement.
But for now, it's important to understand how a recursive call causes the method to repeat itself.


\section{Binary Numbers}

The \java{countdown} example illustrated three basic steps: (1) check the base case, (2) print something out, and (3) make the recursive call.
You should always check the base case first, or else the recursion may keep going until the program runs out of memory (i.e., \java{java.lang.StackOverflowError}).
However, it's okay to make the recursive call {\it before} completing the rest of the method:

\begin{code}
    public static void countup(int n) {
        if (n == 0) {
            System.out.println("Blastoff!");
        } else {
            countdown(n - 1);
            System.out.println(n);
        }
    }
\end{code}

Doing so causes the original behavior to be reversed.
The stack diagram is the same as before, and the method is still called \java{n} times.
But now the \java{System.out.println} happens just before each recursive call returns.
As a result, it counts up instead of down---even though the code is subtracting!

\begin{stdout}
Blastoff!
1
2
3
\end{stdout}

There are many situations when you want to compute results in reverse order.
For example, to convert a decimal integer into its {\bf binary} representation, you repeatedly divide the number by two:

\begin{stdout}
23 / 2 is 11 remainder 1
11 / 2 is  5 remainder 1
 5 / 2 is  2 remainder 1
 2 / 2 is  1 remainder 0
 1 / 2 is  0 remainder 1
\end{stdout}

23 in binary is 10111, which is the remainders in the above example from bottom to top.
Here is a recursive method that prints the binary representation of any positive integer:

\begin{code}
    public static void showBinary(int value) {
        if (value > 0) {
            showBinary(value / 2);
            System.out.print(value % 2);  // line 4
        }
    }
\end{code}

The \java{showBinary} method begins with the base case: it stops recursion when the value to divide becomes 0.
If the argument is still positive, \java{showBinary} divides it by two and makes the recursive call again.
At some point, \java{showBinary} returns from the base case to line 4.
It then prints the remainder at that step of the algorithm and returns again to line 4.
Because each method call has its own copy of the parameter \java{value}, the arithmetic works out correctly.

\begin{code}
    print(23);    
    // output is 10111
\end{code}

Learning to think recursively is an important aspect of learning to think like a computer scientist.
The main idea is that the method parameter decreases or increases until a base case is reached.
With respect to recursive calls, the interesting computation happens on the way in, on the way out, or both.


\section{Vocabulary}

\begin{description}

\term{boolean}
A type of variable that contains either the value \java{true} or \java{false}.

\index{operator!relational}
\term{relational operator}
An operator that compares two values and produces a boolean that indicates the relationship between the operands.

\term{flag}
A variable (usually \java{boolean}) that records a condition or status.

\index{operator!conditional}
\term{conditional operator}
An operator that combines boolean values and produces boolean values.

\term{short circuit}
A property of conditional operators that cases them not to evaluate the second operand if the answer is already known.

\term{De Morgan's laws}
Mathematical rules that show how to negate a conditional expression.

\term{decision statement}
A block of statements that may or may not be executed depending on some condition.

\term{chaining}
A way of joining several conditional statements in sequence.

\term{nesting}
Putting a conditional statement inside one or both branches of another conditional statement.

\term{recursion}
The process of invoking the same method you are currently executing.

\term{base case}
A condition that causes a recursive method {\it not} to make another recursive call.

\term{binary}
A system that uses only zeros and ones to represent numbers.
Also known as base-2 in mathematics.

\end{description}


\section{Exercises}

\begin{exercise}
Fermat's Last Theorem says that there are no integers $a$, $b$, and $c$ such that
\[ a^n + b^n = c^n \]
except in the case when $n \leq 2$ (e.g., the Pythagorean Theorem).

Write a method named {\tt checkFermat} that takes four integers as parameters---{\tt a}, {\tt b}, {\tt c} and {\tt n}---and that checks to see if Fermat's theorem holds.
If $n$ is greater than 2 and it turns out to be true that $a^n + b^n = c^n$, the program should print ``Holy smokes, Fermat was wrong!''
Otherwise the program should print ``No, that doesn't work.''

HINT: You may want to use \java{Math.pow} in your method.
\end{exercise}

\begin{exercise}
Conditional operators can simplify nested decision structures.
For example, how can you rewrite this code using a single \java{if} statement?

\begin{code}
    if (x > 0) {
        if (x < 10) {
            System.out.println("x is a positive single digit.");
        }
    }
\end{code}
\end{exercise}

\begin{exercise}
What is the output of the following program?

\begin{code}
public class Narf {

    public static void zoop(String fred, int bob) {
        System.out.println(fred);
        if (bob == 5) {
            ping("not ");
        } else {
            System.out.println("!");
        }
    }

    public static void main(String[] args) {
        int bizz = 5;
        int buzz = 2;
        zoop("just for", bizz);
        clink(2 * buzz);
    }

    public static void clink(int fork) {
        System.out.print("It's ");
        zoop("breakfast ", fork) ;
    }

    public static void ping(String strangStrung) {
        System.out.println("any " + strangStrung + "more ");
    }

}
\end{code}
\end{exercise}

\begin{exercise}
Draw a stack diagram that shows the state of the program in Section~\ref{recursion} after \java{main} invokes \java{nLines} with the parameter \java{n == 4}, just before the last invocation of \java{nLines} returns.
\end{exercise}

\begin{exercise}
The first verse of the song ``99 Bottles of Pop'' is:

\begin{quote}
99 bottles of pop on the wall,
99 bottles of pop,
If one of those bottles should happen to fall,
98 bottles of pop on the wall.
\end{quote}

Subsequent verses are identical except that the number of bottles gets smaller by one in each verse, until the last verse:

\begin{quote}
1 bottle of pop on the wall,
1 bottle of pop,
If that last bottle should happen to fall,
No more bottles of pop on the wall.
\end{quote}

And then the song (finally) ends.

Write a program that prints the entire lyrics of ``99 Bottles of Pop.''
Your program should include a {\it recursive} method that does the hard part, but you might want to write additional methods to separate the major functions of the program.
As you develop your code, test it with a small number of verses like ``3 Bottles of Pop.''

%The purpose of this exercise is to take a problem and break it into smaller problems, and to solve the smaller problems by writing simple methods.
\end{exercise}

\begin{exercise}
This exercise reviews the flow of execution through a program with multiple methods.
Read the following code and answer the questions.

\begin{code}
public class Buzz {

    public static void baffle(String blimp) {
        System.out.println(blimp);
        zippo("ping", -5);
    }

    public static void zippo(String quince, int flag) {
        if (flag < 0) {
            System.out.println(quince + " zoop");
        } else {
            System.out.println("ik");
            baffle(quince);
            System.out.println("boo-wa-ha-ha");
        }
    }

    public static void main(String[] args) {
        zippo("rattle", 13);
    }

}
\end{code}

\begin{enumerate}

\item Write the number {\tt 1} next to the first {\em statement} of this program that will be executed.
Be careful to distinguish things that are statements from things that are not.

\item Write the number {\tt 2} next to the second statement, and so on until the end of the program.
If a statement is executed more than once, it might end up with more than one number next to it.

\item What is the value of the parameter {\tt blimp} when {\tt baffle} gets invoked?

\item What is the output of this program?

\end{enumerate}
\end{exercise}

\end{document}
