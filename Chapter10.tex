\documentclass[12pt]{book}

\newcommand{\thetitle}{Think Java: How to Think Like a Computer Scientist}
\title{\thetitle}

\newcommand{\theauthors}{Allen Downey and Chris Mayfield}
\author{\theauthors}

\newcommand{\theversion}{Version 6.0 Draft -- \today}
\date{\theversion}

\usepackage{geometry}
\geometry{
    width=5.5in,
    height=8.5in,
    hmarginratio=3:2,
    vmarginratio=1:1,
    includehead=true,
    headheight=15pt
}

% paragraph spacing
\setlength{\parindent}{0pt}                      % 17.62482pt
\setlength{\parskip}{12pt plus 4pt minus 4pt}    % 0.0pt plus 1.0pt
\linespread{1.05}
\def\arraystretch{1.5}

% list spacing
\setlength{\topsep}{5pt plus 2pt minus 3pt}      % 10.0pt plus 4.0pt minus 6.0pt
\setlength{\partopsep}{-6pt plus 2pt minus 2pt}  %  3.0pt plus 2.0pt minus 2.0pt
\setlength{\itemsep}{0pt}                        %  5.0pt plus 2.5pt minus 1.0pt

% these are copied from tex/latex/base/book.cls
% all I changed is afterskip
\makeatletter
\renewcommand{\section}{\@startsection {section}{1}{\z@}%
    {-3.5ex \@plus -1ex \@minus -.2ex}%
    {0.7ex \@plus.2ex}%
    {\normalfont\Large\bfseries}}
\renewcommand\subsection{\@startsection{subsection}{2}{\z@}%
    {-3.25ex\@plus -1ex \@minus -.2ex}%
    {0.3ex \@plus .2ex}%
    {\normalfont\large\bfseries}}
\renewcommand\subsubsection{\@startsection{subsubsection}{3}{\z@}%
    {-3.25ex\@plus -1ex \@minus -.2ex}%
    {0.3ex \@plus .2ex}%
    {\normalfont\normalsize\bfseries}}
\makeatother

% table of contents vertical spacing
\usepackage{tocloft}
\setlength\cftparskip{8pt plus 4pt minus 4pt}

% The following line adds a little extra space to the column
% in which the Section numbers appear in the table of contents
\makeatletter
\renewcommand{\l@section}{\@dottedtocline{1}{1.5em}{3.0em}}
\makeatother

% customize page headers
\usepackage{fancyhdr}
\pagestyle{fancyplain}
\renewcommand{\chaptermark}[1]{\markboth{Chapter \thechapter ~~ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection ~~ #1}}
\lhead[\fancyplain{}{\bfseries\thepage}]%
      {\fancyplain{}{\bfseries\rightmark}}
\rhead[\fancyplain{}{\bfseries\leftmark}]%
      {\fancyplain{}{\bfseries\thepage}}
\cfoot{}
%\rfoot{\textcolor{gray}{\tiny ThinkJava Draft \today}}

% balanced index with TOC entry
\usepackage{makeidx}
\makeindex
%\usepackage[totoc]{idxlayout}

% automatically index glossary terms
\newcommand{\term}[1]{%
\index{#1}
\item[#1:]}
% TODO: doesn't work with plastex
%\newcommand{\term}[1]{\item[#1:]}

% where to find graphics
\usepackage{graphicx}
%\graphicspath{{figs/}}

%% tweak spacing of figures and captions
%\usepackage{floatrow}
%\usepackage{caption}
%\captionsetup{
%    font=small,
%    labelformat=empty,
%    justification=centering,
%    skip=4pt
%}

% format end of chapter excercises
\usepackage{amsmath}
\usepackage{amsthm}
\newtheoremstyle{exercise}
  {12pt}        % space above
  {12pt}        % space below
  {}            % body font
  {}            % indent amount
  {\bfseries}   % head font
  {}            % punctuation
  {12pt}        % head space
  {}            % custom head
\theoremstyle{exercise}
\newtheorem{exercise}{Exercise}[chapter]

% colors for code listings and output
\usepackage{xcolor}
\definecolor{bgcolor}{HTML}{FAFAFA}
\definecolor{comment}{HTML}{007C00}
\definecolor{keyword}{HTML}{0000FF}
\definecolor{strings}{HTML}{B20000}

% syntax highlighting in code listings
\usepackage{textcomp}
\usepackage{listings}
\lstset{
    language=java,
    basicstyle=\ttfamily,
    backgroundcolor=\color{bgcolor},
    commentstyle=\color{comment},
    keywordstyle=\color{keyword},
    stringstyle=\color{strings},
    columns=fullflexible,
    keepspaces=true,
    showstringspaces=false,
    upquote=true,
    aboveskip=\parskip,
    belowskip=\parskip
}

% code listing environments
\lstnewenvironment{code}
{\minipage{\linewidth}}
{\endminipage}
\lstnewenvironment{stdout}
{\lstset{commentstyle=,keywordstyle=,stringstyle=}\minipage{\linewidth}}
{\endminipage}

% pdf hyperlinks, table of contents, and document properties
\usepackage[pdftex]{hyperref}
\hypersetup{%
  pdftitle={\thetitle},
  pdfauthor={\theauthors},
  pdfsubject={\theversion},
  pdfkeywords={},
  bookmarksopen=false,
  colorlinks=true,
  citecolor=black,
  filecolor=black,
  linkcolor=black,
  urlcolor=blue
}

% inline syntax formatting
\newcommand{\java}[1]{\lstinline{#1}} %\end{
%\newcommand{\java}[1]{\verb"#1"}
%\newcommand{\java}[1]{{\tt #1}}

\begin{document}
\setcounter{chapter}{9}


\chapter{Design your own classes}

\index{class definition}
\index{object type}
\index{type!object}
\index{user-defined type}

Way back in Section~\ref{hello} when we defined the class \java{Hello}, we also created a data type named \java{Hello}.
We didn't create any variables with type \java{Hello}, and we didn't use \java{new} to create any \java{Hello} objects---but we could have!
This example doesn't make much sense, since there is no reason to create a \java{Hello} object, and it wouldn't do much if we did.

In this chapter, we will look at class definitions for creating {\em useful} object types.
Here are the most important ideas:

\begin{itemize}

\item Defining a new class also creates a new object type with the same name.

\item Every object belongs to some object type; that is, it is an {\bf instance} of some class.

\item A class definition is like a template for objects: it determines what instance variables the objects have and what methods can operate on them.

\item The methods that operate on a type are defined in the class definition for that type.

\item When you invoke \java{new} to create an object, Java invokes a special method called a {\bf constructor} to initialize the instance variables.
You may provide one or more constructors as part of the class definition.

\item If you don't provide a constructor for a class, then Java will generate one for you.
The default constructor takes no arguments and initializes all instance variables to zero (or the equivalent value for its data type).

\end{itemize}

Here are some syntax issues about class definitions:

\begin{itemize}

\item Class names (and hence object types) should begin with a capital letter, which helps distinguish them from primitive types and variable names.

\item You usually put one class definition in each file, and the name of the file must be the same as the name of the class, with the suffix {\tt .java}.
For example, the \java {class Time} is defined in the file named {\tt Time.java}.

\item In any program, one class is designated as the {\bf startup class} that contains a method named \java{main} where the execution of the program begins.
Other classes {\em may} have a method named \java{main}, but it will not be executed (unless another method calls it directly for some reason).

\end{itemize}

%With those issues out of the way, let's look at an example of a user-defined class.


\section{Time}

\index{class!Time}
\index{Time}

A common motivation for creating an object type is to encapsulate related data in an object that can be treated as a single unit.
We have already seen two such types, \java{Point} and \java{Rectangle}.

Another example, which we will implement ourselves, is \java{Time}, which represents the time of day.
The data encapsulated in a \java{Time} object are an hour, a minute, and a number of seconds.
Because every \java{Time} object contains these data, we need instance variables to hold them.

The first step is to decide what type each variable should be.
It seems clear that \java{hour} and \java{minute} should be integers.
Just to keep things interesting, let's make \java{second} a \java{double}.

\index{instance variable}
\index{variable!instance}

Instance variables are declared at the beginning of the class definition, outside of any method definition:

\begin{code}
public class Time {
    private int hour;
    private int minute;
    private double second;
}
\end{code}

By itself, this code fragment is a legal class definition.
The state diagram for a \java{Time} object looks like this:

\begin{center}
\includegraphics{figs/time.pdf}
\end{center}

%\subsection{Public vs private}

The keyword \java{public} means that a class, method, or variable can be accessed from other classes.
The alternative is \java{private}, which means the item can only be accessed inside the class where it is defined.
To prevent yourself and others from making mistakes, it's good practice to make instance variables \java{private}.

If you attempt to read or write a \java{private} variable from another class, you will get a compiler error.
Private methods and instance variables are language features that help programmers ensure {\bf data encapsulation}, which means that objects in one class are isolated from other classes.
Limiting interactions between classes is one technique for managing complexity of software development.

%We can create {\bf accessor methods} like \java{getHour}, \java{getMinute}, and \java{getSecond}.
%, but it provides no methods that modify the instance variables.
%In effect, \java{Location} objects are immutable, which means that they can be shared without worrying about unexpected behavior due to aliasing.

%Making methods private helps keep the API simple.
%Classes often include helper methods that are used to implement other methods, but making those methods part of the public API might be unnecessary and error-prone.

After declaring the instance variables, the next step is to define a constructor for the new class.


\section{Constructors}

\index{constructor}
\index{method!constructor}
\index{static}

Constructors initialize the instance variables.
The syntax for constructors is similar to that of other methods, with three exceptions:

\begin{itemize}
\item The name of the constructor is the same as the name of the class.
\item Constructors have no return type and no return value.
\item The keyword \java{static} is omitted.
\end{itemize}

Here is an example for the \java{Time} class:

\begin{code}
    public Time() {
        this.hour = 0;
        this.minute = 0;
        this.second = 0.0;
    }
\end{code}

Where you would expect to see a return type, between \java{public} and \java{Time}, there is nothing.
That's how we (and the compiler) can tell that this is a constructor as opposed to a \java{void} method.

This constructor does not take any arguments.
Each line of the constructor initializes an instance variable to zero (which in this case means midnight).

\index{this}

The name \java{this} is a special keyword that refers to the object that we are creating.
You can use \java{this} the same way you use the name of any other object.
For example, you can read and write the instance variables of \java{this}, and you can pass \java{this} as an argument to other methods.
But you do not declare \java{this}, and you can't make an assignment to it.
%The variable \java{this} is created by the system; all you have to do is initialize its instance variables.

A common error when writing constructors is to put a \java{return} statement at the end.
Like \java{void} methods, constructors do not return values.
Another mistake that beginning programmers make is to invoke the \java{new} operation inside the constructor.
For example, writing the code \java{new Time(0, 0, 0.0)} in the constructor results in infinite recursion.

%\subsection{More constructors}

\index{overloading}

Constructors can be overloaded, just like other methods, which means that you can provide multiple constructors with different parameters.
Java knows which constructor to invoke by matching the arguments after \java{new} with the parameters of the constructors.

It is common to have one constructor that takes no arguments (the default constructor), and one constructor that takes a parameter list identical to the list of instance variables (the explicit value constructor).

\begin{code}
    public Time(int hour, int minute, double second) {
        this.hour = hour;
        this.minute = minute;
        this.second = second;
    }
\end{code}

Notice how the names and types of the parameters are the same as the names and types of the instance variables.
All the constructor does is copy the information from the parameters into the instance variables.

If you look at the documentation for \java{Point} and \java{Rectangle}, you will see that both classes provide similar constructors.
Overloading constructors provides the flexibility to create an object first and then fill in the blanks, or to collect all the information before creating the object.

This might not seem very interesting, and in fact it is not.
Writing constructors is a boring, mechanical process, and some IDEs will automatically generate them for you.
Once you have written two, you will find that you can write them quickly just by looking at the list of instance variables.


\section{Creating a new object}

\index{new}
\index{statement!new}

Although constructors look like methods, you never invoke them directly.
Instead, when you apply the \java{new} operator, the system allocates space for the object and then invokes your constructor.

The following program demonstrates two common ways to create and initialize \java{Time} objects:

\begin{code}
public class Time {
    private int hour;
    private int minute;
    private double second;

    public Time() {
        this.hour = 0;
        this.minute = 0;
        this.second = 0.0;
    }

    public Time(int hour, int minute, double second) {
        this.hour = hour;
        this.minute = minute;
        this.second = second;
    }

    public static void main(String[] args) {
        // one way to create and initialize a Time object
        Time t1 = new Time();
        t1.hour = 11;
        t1.minute = 8;
        t1.second = 3.14159;
        System.out.println(t1);

        // another way to do the same thing
        Time t2 = new Time(11, 8, 3.14159);
        System.out.println(t2);
    }
}
\end{code}

In \java{main}, the first time we apply \java{new} we provide no arguments, so Java invokes the default constructor.
The next few lines assign values to the instance variables.

The second time we invoke \java{new}, we provide arguments that match the parameters of the second constructor.
This way of initializing the instance variables is more concise and slightly more efficient.
But it can be harder to read, since it is not as clear which values are assigned to which instance variables.


\section{Printing objects}
\label{printobject}

\index{print}
\index{statement!print}
\index{object!printing}

The output of this program is:

\begin{stdout}
Time@80cc7c0
Time@80cc807
\end{stdout}

When Java prints the value of a user-defined object type, it prints the name of the type and a special hexadecimal (base 16) code that is unique for each object.  This code is not meaningful in itself; in fact, it can vary from machine to machine and even from run to run.
But it can be useful for debugging, in case you want to keep track of individual objects.

To print objects in a way that is more meaningful to users (as opposed to programmers), you could write a method called something like \java{printTime}:

\begin{code}
    public static void printTime(Time t) {
        System.out.println(t.hour + ":" + t.minute + ":" + t.second);
    }
\end{code}

Compare this method to the version of \java{printTime} in Section~\ref{time}.

The output of this method, if we pass either \java{t1} or \java{t2} as an argument, is {\tt 11:8:3.14159}.
Although this is recognizable as a time, it is not quite in the standard format.
For example, if the number of minutes or seconds is less than 10, we expect a leading {\tt 0} as a place-keeper.
Also, we might want to drop the decimal part of the seconds.
In other words, we want something like {\tt 11:08:03}.
Fortunately, we can use \java{printf} to format the output:

\begin{code}
    public static void printTime(Time t) {
        System.out.printf("%02d:%02d:%02.0f\n",
            t.hour, t.minute, t.second);
    }
\end{code}

As a reminder, you need to use \java{\%d} with integers and \java{\%f} with floating-point numbers.
The \java{\%f} specifier automatically rounds the value.


\section{The toString method}

\index{toString}
\index{method!toString}

Every object type has a method called \java{toString} that returns a string representation of the object.
When you print an object using \java{print} or \java{println}, Java invokes the object's \java{toString} method.

The default version of \java{toString} returns a string that contains the type of the object and a unique identifier (see Section~\ref{printobject}).
When you define a new object type, you can {\bf override} the default behavior by providing a new method with the behavior you want.

For example, here is a \java{toString} method for \java{Time}:

\begin{code}
public String toString() {
    return String.format("%02d:%02d:%02.0f\n",
            t.hour, t.minute, t.second);
}
\end{code}

This code is essentially the same as printTime in the previous section, except that we are returning a string instead of printing one to the screen.
The \java{String.format} method works the same way as \java{printf}; in fact, the \java{printf} method invokes \java{String.format}.

You can invoke \java{toString} in the usual way:

\begin{code}
    Time time = new Time(11, 8, 3.14159);
    String s = time.toString();
\end{code}

Or you can invoke it indirectly through \java{println}:

\begin{code}
    System.out.println(time);
\end{code}


\section{The equals method}

\index{equals}
\index{method!equals}

When comparing objects, there are two notions of equality: objects that are {\em identical}, and objects that are {\em equivalent}.
Identical means that two variables refer to the same object.
Equivalent means that two objects have the same values.
Consider for example the following \java{Time} variables:

\begin{code}
    Time time1 = new Time(9, 30, 0.0);
    Time time2 = time1;
    Time time3 = new Time(9, 30, 0.0);
\end{code}

Since \java{Time} is a reference type, \java{time1}, \java{time2}, and \java{time3} are references to objects.
Here is a memory diagram:

\begin{center}
\includegraphics{figs/time2.pdf}
\end{center}

Recall that the assignment operator simply copies a reference; \java{time1} and \java{time2} refer to the same object.
In contrast, \java{time3} points to a different object.
Whenever you apply the \java{new} operator, you create a new object in memory.

In this example, \java{time1} and \java{time2} are identical: they refer to the same object.
The \java{==} operator compares references, so \java{time1 == time2} is \java{true}.
All three variables are equivalent: the objects they reference have the same values.
However \java{time1 == time3} is \java{false}, because their references are not the same.

There is no operator that tests equivalence, since the notion of equality is different for each type of object.
In the case of \java{Time}, we could write a \java{static} method that compares hours, minutes, and seconds:

\begin{code}
    public static boolean sameTime(Time t1, Time t2) {
        return t1.hour == t2.hour
            && t1.minute == t2.minute
            && t1.second == t2.second;
    }
\end{code}

This method works just fine, but it's not the way most Java classes are designed.
Instead, objects should provide a non-\java{static} method named \java{equals} that defines equivalence.
So all we have to do is rewrite \java{sameTime} as an instance method:

\begin{code}
    public boolean equals(Time t2) {
        return this.hour == t2.hour
            && this.minute == t2.minute
            && this.second == t2.second;
    }
\end{code}

By way of comparison, here is how each of these methods are invoked:

\begin{code}
    System.out.println(Time.sameTime(time1, time3));
    System.out.println(time1.equals(time3));
\end{code}

The latter method is certainly easier to read and understand.
Inside the \java{equals} method, the reference to \java{time1} is the current object \java{this}, and \java{time3} is the parameter \java{t2}.


\section{Static methods}

\index{pure function}
\index{function}
\index{method!pure function}

A method is considered a pure function if the result depends only on the arguments, and it has no side effects like modifying an argument or printing something.
The only result of invoking a pure function is the return value.

One example is \java{isAfter}, which compares two \java{Time}s and returns a \java{boolean} that indicates whether the first operand comes after the second:

\begin{code}
    public static boolean isAfter(Time time1, Time time2) {
        if (time1.hour > time2.hour) return true;
        if (time1.hour < time2.hour) return false;

        if (time1.minute > time2.minute) return true;
        if (time1.minute < time2.minute) return false;

        if (time1.second > time2.second) return true;
        return false;
    }
\end{code}

What is the result of this method if the two times are equal?
Does that seem like the appropriate result for this method?
If you were writing the documentation for this method, would you mention that case specifically?

A second example is \java{addTime}, which calculates the sum of two times.
For example, if it is {\tt 9:14:30}, and your bread maker takes 3 hours and 35 minutes, you could use \java{addTime} to figure out when the bread will be done.

Here is a rough draft of this method that is not quite right:

\begin{code}
    public static Time addTime(Time t1, Time t2) {
        Time sum = new Time();
        sum.hour = t1.hour + t2.hour;
        sum.minute = t1.minute + t2.minute;
        sum.second = t1.second + t2.second;
        return sum;
    }
\end{code}

Although this method returns a \java{Time} object, it is not a constructor.
You should go back and compare the syntax of a method like this with the syntax of a constructor, because it is easy to get confused.

Here is an example of how to use this method.
If \java{currentTime} contains the current time and \java{breadTime} contains the amount of time it takes for your bread maker to make bread, then you could use \java{addTime} to figure out when the bread will be done.

\begin{code}
    Time currentTime = new Time(9, 14, 30.0);
    Time breadTime = new Time(3, 35, 0.0);
    Time doneTime = addTime(currentTime, breadTime);
    printTime(doneTime);
\end{code}

The output of this program is {\tt 12:49:30.0}, which is correct.
On the other hand, there are cases where the result is not correct.
Can you think of one?

The problem is that this method does not deal with cases where the number of seconds or minutes adds up to more than 60.
In that case, we have to ``carry'' the extra seconds into the minutes column, or extra minutes into the hours column.

Here's a corrected version of the method.

\begin{code}
    public static Time addTime(Time t1, Time t2) {
        Time sum = new Time();
        sum.hour = t1.hour + t2.hour;
        sum.minute = t1.minute + t2.minute;
        sum.second = t1.second + t2.second;

        if (sum.second >= 60.0) {
            sum.second -= 60.0;
            sum.minute += 1;
        }
        if (sum.minute >= 60) {
            sum.minute -= 60;
            sum.hour += 1;
        }
        return sum;
    }
\end{code}

Although it's correct, it's starting to get big.
Later I suggest a much shorter alternative.

\index{increment}
\index{decrement}
\index{operator!increment}
\index{operator!decrement}

This code demonstrates two operators we have not seen before, \java{+=} and \java{-=}.
These operators provide a concise way to increment and decrement variables.
They are similar to \java{++} and \java{--}, except (1) they work on \java{double}s as well as \java{int}s, and (2) the amount of the increment does not have to be 1.
The statement \java{sum.second -= 60.0;} is equivalent to \java{sum.second = sum.second - 60;}


\section{Accessors and mutators}

\index{modifier}
\index{method!modifier}

As an example of a modifier, consider \java{increment}, which adds a given number of seconds to a \java{Time} object.
Again, a rough draft of this method looks like:

\begin{code}
    public static void increment(Time time, double secs) {
        time.second += secs;
        if (time.second >= 60.0) {
            time.second -= 60.0;
            time.minute += 1;
        }
        if (time.minute >= 60) {
            time.minute -= 60;
            time.hour += 1;
        }
    }
\end{code}

The first line performs the basic operation; the remainder deals with the same cases we saw before.

Is this method correct?
What happens if the argument \java{secs} is much greater than 60?
In that case, it is not enough to subtract 60 once; we have to keep doing it until \java{second} is below 60.
We can do that by replacing the \java{if} statements with \java{while} statements:

\begin{code}
    public static void increment(Time time, double secs) {
        time.second += secs;
        while (time.second >= 60.0) {
            time.second -= 60.0;
            time.minute += 1;
        }
        while (time.minute >= 60) {
            time.minute -= 60;
            time.hour += 1;
        }
    }
\end{code}

This solution is correct, but not very efficient.
Can you think of a solution that does not require iteration?


\section{Glossary}

\begin{description}

\term{class}
Previously, we defined a class as a collection of related methods.
In this chapter we learned that a class definition is also a template for a new type of object.

\term{instance}
A member of a class.
Every object is an instance of some class.

\term{constructor}
A special method that initializes the instance variables of a newly-constructed object.

\term{startup class}
The class that contains the \java{main} method where execution of the program begins.

\term{pure function}
A method whose result depends only on its parameters, and that has no side-effects other than returning a value.

\term{modifier}
A method that changes one or more of the objects it receives as parameters and is usually \java{void}.

\end{description}


\section{Exercises}


\begin{exercise}
In the board game Scrabble\footnote{Scrabble is a registered trademark owned in the U.S.A and Canada by Hasbro Inc., and in the rest of the world by J.W. Spear \& Sons Limited of Maidenhead, Berkshire, England, a subsidiary of Mattel Inc.}, each tile contains a letter, which is used to spell words, and a score, which is used to determine the value of words.

\begin{enumerate}

\item Write a definition for a class named \java{Tile} that represents Scrabble tiles.
The instance variables should be a character named \java{letter} and an integer named \java{value}.

\item Write a constructor that takes parameters named \java{letter} and \java{value} and initializes the instance variables.

\item Write a method named \java{printTile} that takes a \java{Tile} object as a parameter and prints the instance variables in
a reader-friendly format.

\item Write a method named \java{testTile} that creates a Tile object with the letter \java{Z} and the value 10, and then uses \java{printTile} to print the state of the object.

\end{enumerate}

The point of this exercise is to practice the mechanical part of creating a new class definition and code that tests it.
\end{exercise}


\begin{exercise}
Write a class definition for \java{Date}, an object type that contains three integers, \java{year}, \java{month} and \java{day}.
This class should provide two constructors.
The first should take no parameters.
The second should take parameters named \java{year}, \java{month} and \java{day}, and use them to initialize the instance variables.

Write a \java{main} method that creates a new \java{Date} object named \java{birthday}.
The new object should contain your birth date.
You can use either constructor.
\end{exercise}


\begin{exercise}
\label{ex.rational}

A rational number is a number that can be represented as the ratio of two integers.
For example, $2/3$ is a rational number, and you can think of 7 as a rational number with an implicit 1 in the denominator.
For this assignment, you are going to write a class definition for rational numbers.

\begin{enumerate}

\item Create a new program called \java{Rational.java} that defines a class named \java{Rational}.
A \java{Rational} object should have two integer instance variables to store the numerator and denominator.

\item Write a constructor that takes no arguments and that sets the numerator to 0 and denominator to 1.

\item Write a method called \java{printRational} that takes a Rational object as an argument and prints it in some reasonable format.

\item Write a \java{main} method that creates a new object with type Rational, sets its instance variables to some values, and prints the object.

\item At this stage, you have a minimal testable program.
Test it and, if necessary, debug it.

\item Write a second constructor for your class that takes two arguments and that uses them to initialize the instance variables.

\item Write a method called \java{negate} that reverses the sign of a rational number.
This method should be a modifier, so it should be \java{void}.
Add lines to \java{main} to test the new method.

\item Write a method called \java{invert} that inverts the number by swapping the numerator and denominator.
Add lines to \java{main} to test the new method.

\item Write a method called \java{toDouble} that converts the rational number to a double (floating-point number) and returns the result.
This method is a pure function; it does not modify the object.
As always, test the new method.

\item Write a modifier named \java{reduce} that reduces a rational number to its lowest terms by finding the greatest common divisor (GCD) of the numerator and denominator and dividing through.
This method should be a pure function; it should not modify the instance variables of the object on which it is invoked.
To find the GCD, see Exercise~\ref{gcd}).

\item Write a method called \java{add} that takes two Rational numbers as arguments and returns a new Rational object.
The return object should contain the sum of the arguments.

There are several ways to add fractions.
You can use any one you want, but you should make sure that the result of the operation is reduced so that the numerator and denominator have no common divisor (other than 1).
\end{enumerate}

The purpose of this exercise is to write a class definition that includes a variety of methods, including constructors, modifiers and pure functions.
\end{exercise}


\end{document}
