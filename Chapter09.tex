\documentclass[12pt]{book}

\newcommand{\thetitle}{Think Java: How to Think Like a Computer Scientist}
\title{\thetitle}

\newcommand{\theauthors}{Allen Downey and Chris Mayfield}
\author{\theauthors}

\newcommand{\theversion}{Version 6.0 Draft -- \today}
\date{\theversion}

\usepackage{geometry}
\geometry{
    width=5.5in,
    height=8.5in,
    hmarginratio=3:2,
    vmarginratio=1:1,
    includehead=true,
    headheight=15pt
}

% paragraph spacing
\setlength{\parindent}{0pt}                      % 17.62482pt
\setlength{\parskip}{12pt plus 4pt minus 4pt}    % 0.0pt plus 1.0pt
\linespread{1.05}
\def\arraystretch{1.5}

% list spacing
\setlength{\topsep}{5pt plus 2pt minus 3pt}      % 10.0pt plus 4.0pt minus 6.0pt
\setlength{\partopsep}{-6pt plus 2pt minus 2pt}  %  3.0pt plus 2.0pt minus 2.0pt
\setlength{\itemsep}{0pt}                        %  5.0pt plus 2.5pt minus 1.0pt

% these are copied from tex/latex/base/book.cls
% all I changed is afterskip
\makeatletter
\renewcommand{\section}{\@startsection {section}{1}{\z@}%
    {-3.5ex \@plus -1ex \@minus -.2ex}%
    {0.7ex \@plus.2ex}%
    {\normalfont\Large\bfseries}}
\renewcommand\subsection{\@startsection{subsection}{2}{\z@}%
    {-3.25ex\@plus -1ex \@minus -.2ex}%
    {0.3ex \@plus .2ex}%
    {\normalfont\large\bfseries}}
\renewcommand\subsubsection{\@startsection{subsubsection}{3}{\z@}%
    {-3.25ex\@plus -1ex \@minus -.2ex}%
    {0.3ex \@plus .2ex}%
    {\normalfont\normalsize\bfseries}}
\makeatother

% table of contents vertical spacing
\usepackage{tocloft}
\setlength\cftparskip{8pt plus 4pt minus 4pt}

% The following line adds a little extra space to the column
% in which the Section numbers appear in the table of contents
\makeatletter
\renewcommand{\l@section}{\@dottedtocline{1}{1.5em}{3.0em}}
\makeatother

% customize page headers
\usepackage{fancyhdr}
\pagestyle{fancyplain}
\renewcommand{\chaptermark}[1]{\markboth{Chapter \thechapter ~~ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection ~~ #1}}
\lhead[\fancyplain{}{\bfseries\thepage}]%
      {\fancyplain{}{\bfseries\rightmark}}
\rhead[\fancyplain{}{\bfseries\leftmark}]%
      {\fancyplain{}{\bfseries\thepage}}
\cfoot{}
%\rfoot{\textcolor{gray}{\tiny ThinkJava Draft \today}}

% balanced index with TOC entry
\usepackage{makeidx}
\makeindex
%\usepackage[totoc]{idxlayout}

% automatically index glossary terms
\newcommand{\term}[1]{%
\index{#1}
\item[#1:]}
% TODO: doesn't work with plastex
%\newcommand{\term}[1]{\item[#1:]}

% where to find graphics
\usepackage{graphicx}
%\graphicspath{{figs/}}

%% tweak spacing of figures and captions
%\usepackage{floatrow}
%\usepackage{caption}
%\captionsetup{
%    font=small,
%    labelformat=empty,
%    justification=centering,
%    skip=4pt
%}

% format end of chapter excercises
\usepackage{amsmath}
\usepackage{amsthm}
\newtheoremstyle{exercise}
  {12pt}        % space above
  {12pt}        % space below
  {}            % body font
  {}            % indent amount
  {\bfseries}   % head font
  {}            % punctuation
  {12pt}        % head space
  {}            % custom head
\theoremstyle{exercise}
\newtheorem{exercise}{Exercise}[chapter]

% colors for code listings and output
\usepackage{xcolor}
\definecolor{bgcolor}{HTML}{FAFAFA}
\definecolor{comment}{HTML}{007C00}
\definecolor{keyword}{HTML}{0000FF}
\definecolor{strings}{HTML}{B20000}

% syntax highlighting in code listings
\usepackage{textcomp}
\usepackage{listings}
\lstset{
    language=java,
    basicstyle=\ttfamily,
    backgroundcolor=\color{bgcolor},
    commentstyle=\color{comment},
    keywordstyle=\color{keyword},
    stringstyle=\color{strings},
    columns=fullflexible,
    keepspaces=true,
    showstringspaces=false,
    upquote=true,
    aboveskip=\parskip,
    belowskip=\parskip
}

% code listing environments
\lstnewenvironment{code}
{\minipage{\linewidth}}
{\endminipage}
\lstnewenvironment{stdout}
{\lstset{commentstyle=,keywordstyle=,stringstyle=}\minipage{\linewidth}}
{\endminipage}

% pdf hyperlinks, table of contents, and document properties
\usepackage[pdftex]{hyperref}
\hypersetup{%
  pdftitle={\thetitle},
  pdfauthor={\theauthors},
  pdfsubject={\theversion},
  pdfkeywords={},
  bookmarksopen=false,
  colorlinks=true,
  citecolor=black,
  filecolor=black,
  linkcolor=black,
  urlcolor=blue
}

% inline syntax formatting
\newcommand{\java}[1]{\lstinline{#1}} %\end{
%\newcommand{\java}[1]{\verb"#1"}
%\newcommand{\java}[1]{{\tt #1}}

\begin{document}
\setcounter{chapter}{8}


\chapter{Classes and objects}
\label{objects}

\index{String}
\index{type!String}

As we learned in the previous chapter, \java{String}s are objects.
But they are atypical in Java because:
\begin{itemize}

\item They are immutable.
You can't change an existing \java{String} object, but you can create new ones.

\item You don't have to use \java{new} to create a \java{String} object.
For convenience, Java allows you to assign \java{String} literals.

\end{itemize}

In this chapter, we use two objects from the Java library: \java{Point} and \java{Rectangle}.
To be clear, these points and rectangles are not graphical objects that appear on the screen.
Like strings, they simply contain data and provide methods for manipulating that data.


\section{Class diagrams}

TODO


\section{Point objects}

\index{Point}
\index{class!Point}

A point is two numbers (coordinates) that we treat collectively as a single object.
In mathematical notation, points are often written in parentheses, with a comma separating the coordinates.
For example, $(0, 0)$ indicates the origin, and $(x, y)$ indicates the point $x$ units to the right and $y$ units up from the origin.

\index{new}
\index{statement!new}

In Java, a point is represented by a \java{Point} object.
To create a new point, you have to use \java{new}:

\begin{code}
    Point blank;
    blank = new Point(3, 4);
\end{code}

\index{declaration}
\index{statement!declaration}

The first line is a conventional variable declaration: \java{blank} has type \java{Point}.
The second line invokes \java{new}, specifies the type of the new object, and provides arguments.
The arguments are the coordinates of the new point, $(3, 4)$.

\index{reference}

The result of \java{new} is a {\bf reference} to the new point.
So \java{blank} contains a reference to the newly-created object.
Here is a standard way to diagram this assignment:

\includegraphics{figs/reference.pdf}

As usual, the name of the variable \java{blank} appears outside the box and its value appears inside the box.
In this case, that value is a reference, which is shown graphically with an arrow.
The arrow points to the object we're referring to.

\index{instance variable}
\index{variable!instance}

The big box shows the newly-created object with the two values in it.
The names \java{x} and \java{y} are the names of the {\bf instance variables}.

\index{state}
\index{state diagram}

Taken together, all the variables, values, and objects in a program are called the {\bf state}.
Diagrams like this that show the state of the program are called {\bf state diagrams}.
As the program runs, the state changes, so you should think of a state diagram as a snapshot of a particular point in the execution.


\section{Instance variables}

The pieces of data that make up an object are called instance variables because each object, which is an {\bf instance} of its type, has its own copy of the instance variables.

It's like the glove compartment of a car.  Each car is an instance of the type ``car,'' and each car has its own glove compartment.
If you ask me to get something from the glove compartment of your car, you have to tell me which car is yours.

\index{dot notation}

Similarly, if you want to read a value from an instance variable, you have to specify the object you want to get it from.
In Java this is done using dot notation.

\begin{code}
    int x = blank.x;
\end{code}

The expression \java{blank.x} means ``go to the object \java{blank} refers to, and get the value of \java{x}.''
In this case we assign that value to a local variable named \java{x}.
There is no conflict between the local variable named \java{x} and the instance variable named \java{x}.
The purpose of dot notation is to identify {\em which} variable you are referring to unambiguously.

You can use dot notation as part of any Java expression, so the following are legal.

\begin{code}
    System.out.println(blank.x + ", " + blank.y);
    int sum = blank.x * blank.x + blank.y * blank.y;
\end{code}

The first line prints \java{3, 4}; the second line calculates the value 25.


\section{Objects as parameters}

\index{parameter}
\index{object!as parameter}

You can pass objects as parameters in the usual way.
For example:

\begin{code}
    public static void printPoint(Point p) {
        System.out.println("(" + p.x + ", " + p.y + ")");
    }
\end{code}

This method takes a point as an argument and prints it in the standard format.
If you invoke \java{printPoint(blank)}, it prints \java{(3, 4)}.
Actually, Java already has a method for printing \java{Points}.
If you invoke \java{System.out.println(blank)}, you get:

\begin{stdout}
java.awt.Point[x=3,y=4]
\end{stdout}

This is a standard format Java uses for printing objects.
It prints the name of the type, followed by the names and values of the instance variables.

As a second example, we can rewrite the \java{distance} method from Section~\ref{distance} so that it takes two \java{Point}s as parameters instead of four \java{double}s.

\begin{code}
    public static double distance(Point p1, Point p2) {
        double dx = (double)(p2.x - p1.x);
        double dy = (double)(p2.y - p1.y);
        return Math.sqrt(dx*dx + dy*dy);
    }
\end{code}

The typecasts are not really necessary; I added them as a reminder that the instance variables in a \java{Point} are integers.


\section{Rectangles}

\index{Rectangle}
\index{class!Rectangle}

\java{Rectangle}s are similar to points, except that they have four instance variables: \java{x}, \java{y}, \java{width} and \java{height}.
Other than that, everything is pretty much the same.
This example creates a \java{Rectangle} object and makes \java{box} refer to it.

\begin{code}
    Rectangle box = new Rectangle(0, 0, 100, 200);
\end{code}

This figure shows the effect of this assignment.

\includegraphics{figs/rectangle.pdf}

If you print \java{box}, you get:

\begin{stdout}
java.awt.Rectangle[x=0,y=0,width=100,height=200]
\end{stdout}

Again, this is the result of a Java method that knows how to print \java{Rectangle} objects.


\section{Objects as return types}

\index{return}
\index{statement!return}

You can write methods that return objects.
For example, \java{findCenter} takes a \java{Rectangle} as an argument and returns a \java{Point} that contains the coordinates of the center of the \java{Rectangle}:

\begin{code}
    public static Point findCenter(Rectangle box) {
        int x = box.x + box.width/2;
        int y = box.y + box.height/2;
        return new Point(x, y);
    }
\end{code}

Notice that you can use \java{new} to create a new object, and then immediately use the result as the return value.


\section{Mutable objects}

\index{mutable}
\index{object!mutable}

You can change the contents of an object by making an assignment to one of its instance variables.
For example, to ``move'' a rectangle without changing its size, you can modify the \java{x} and \java{y} values:

\begin{code}
    box.x = box.x + 50;
    box.y = box.y + 100;
\end{code}

The result is shown in the figure:

\includegraphics{figs/rectangle2.pdf}

\index{encapsulation}
\index{generalization}

We can encapsulate this code in a method and generalize it to move the rectangle by any amount:

\begin{code}
    public static void moveRect(Rectangle box, int dx, int dy) {
        box.x = box.x + dx;
        box.y = box.y + dy;
    }
\end{code}

The variables \java{dx} and \java{dy} indicate how far to move the rectangle in each direction.
Invoking this method has the effect of modifying the \java{Rectangle} that is passed as an argument.

\begin{code}
    Rectangle box = new Rectangle(0, 0, 100, 200);
    moveRect(box, 50, 100);
    System.out.println(box);
\end{code}

This code prints \java{java.awt.Rectangle[x=50,y=100,width=100,height=200]}.

Modifying objects by passing them as arguments to methods can be useful, but it can also make debugging more difficult because it is not always clear which method invocations do or do not modify their arguments.
Later, I discuss some pros and cons of this programming style.

Java provides methods that operate on Points and Rectangles.
You can read the documentation at
\url{http://docs.oracle.com/javase/7/docs/api/java/awt/Point.html}
and
\url{http://docs.oracle.com/javase/7/docs/api/java/awt/Rectangle.html}.

For example, \java{translate} has the same effect as \java{moveRect}, but instead of passing the Rectangle as an argument, you use dot notation:

\begin{code}
    box.translate(50, 100);
\end{code}


\section{Aliasing}
\label{aliasing}

\index{reference}

Remember that when you assign an object to a variable, you are assigning a {\em reference} to an object.
It is possible to have multiple variables that refer to the same object.

\begin{code}
    Rectangle box1 = new Rectangle(0, 0, 100, 200);
    Rectangle box2 = box1;
\end{code}

This code generates a state diagram that looks like:

\includegraphics{figs/aliasing.pdf}

\index{aliasing}

The \java{box1} and \java{box2} variables refer to the same object.
In other words, this object has two names, \java{box1} and \java{box2}.
When a person uses two names, it's called {\bf aliasing}.
Same thing with objects.

When two variables are aliased, any changes that affect one variable also affect the other.
For example:

\begin{code}
    System.out.println(box2.width);
    box1.grow(50, 50);
    System.out.println(box2.width);
\end{code}

The first line prints \java{100}, which is the width of the \java{Rectangle} referred to by \java{box2}.
The second line invokes the \java{grow} method on \java{box1}, which expands the \java{Rectangle} by 50 pixels in every direction (see the documentation for more details).
The effect is shown in the figure:

\includegraphics{figs/aliasing2.pdf}

Whatever changes are made to \java{box1} also apply to \java{box2}.
Thus, the value printed by the third line is \java{200}, the width of the expanded rectangle.
(As an aside, it is perfectly legal for the coordinates of a \java{Rectangle} to be negative.)

As you can tell even from this simple example, code that involves aliasing can get confusing fast, and can be difficult to debug.
In general, aliasing should be avoided or used with care.


\section{Immutable objects}

TODO


\section{The null keyword}

\index{null}

When you create an object variable, remember that you are creating a {\em reference} to an object.
Until you make the variable point to an object, the value of the variable is \java{null}.
\java{null} is a special value (and a Java keyword) that means ``no object.''

The declaration \java{Point blank;} is equivalent to this initialization:

\begin{code}
    Point blank = null;
\end{code}

and is shown in the following state diagram:

\includegraphics{figs/reference2.pdf}

The value \java{null} is represented by a small square with no arrow.

\index{exception!NullPointer}
\index{run-time error}

If you try to use a null object, either by accessing an instance variable or invoking a method, Java throws a \java{NullPointerException}, prints an error message, and terminates the program.

\begin{code}
    Point blank = null;
    int x = blank.x;              // NullPointerException
    blank.translate(50, 50);      // NullPointerException
\end{code}

On the other hand, it is legal to pass a null object as an argument or receive one as a return value.
In fact, it is common to do so, for example to represent an empty set or indicate an error condition.


\section{Garbage collection}

In Section~\ref{aliasing} we talked about what happens when more than one variable refers to the same object.
What happens when {\em no} variable refers to an object?
For example:

\begin{code}
    Point blank = new Point(3, 4);
    blank = null;
\end{code}

The first line creates a new \java{Point} object and makes \java{blank} refer to it.
The second line changes \java{blank} so that instead of referring to the object, it refers to nothing (the null object).

\includegraphics{figs/reference3.pdf}

\index{garbage collection}

If no one refers to an object, then no one can read or write any of its values, or invoke a method on it.
In effect, it ceases to exist.
We could keep the object in memory, but it would only waste space, so periodically as your program runs, the system looks for stranded objects and reclaims them, in a process called {\bf garbage collection}.
Later, the memory space occupied by the object will be available to be used as part of a new object.

You don't have to do anything to make garbage collection happen, and in general you will not be aware of it.
But you should know that it periodically runs in the background.


\section{Vocabulary}

\begin{description}

%\term{AWT}
%The Abstract Window Toolkit, one of the biggest and commonly-used Java packages.

\term{reference}
A value that indicates an object.
In a state diagram, a reference appears as an arrow.

\term{instance}
An example from a category.
My cat is an instance of the category ``feline things.''
Every object is an instance of some class.

\term{instance variable}
One of the named data items that make up an object.
Each object (instance) has its own copy of the instance variables for its class.

\term{state}
A complete description of all the variables and objects and their values, at a given point during the execution of a program.

\term{state diagram}
A snapshot of the state of a program, shown graphically.

\term{aliasing}
The condition when two or more variables refer to the same object.

\term{garbage collection}
The process of finding objects that have no references and reclaiming their storage space.

\end{description}


\section{Exercises}


\begin{exercise}
For the following program:

\begin{enumerate}

\item Draw a stack diagram showing the local variables and parameters of \java{main} and \java{riddle}, and show any objects those variables refer to.

\item What is the output of this program?

\end{enumerate}

\begin{code}
    public static void main(String[] args) {
        int x = 5;
        Point blank = new Point(1, 2);

        System.out.println(riddle(x, blank));
        System.out.println(x);
        System.out.println(blank.x);
        System.out.println(blank.y);
    }

    public static int riddle(int x, Point p) {
        x = x + 7;
        return x + p.x + p.y;
    }
\end{code}

The point of this exercise is to make sure you understand the mechanism for passing objects as parameters.
\end{exercise}


\begin{exercise}
For the following program:

\begin{enumerate}

\item Draw a stack diagram showing the state of the program just before \java{distance} returns.
Include all variables and parameters and the objects those variables refer to.

\item What is the output of this program?

\end{enumerate}

\begin{code}
    public static double distance(Point p1, Point p2) {
        int dx = p1.x - p2.x;
        int dy = p1.y - p2.y;
        return Math.sqrt(dx * dx + dy * dy);
    }

    public static Point findCenter(Rectangle box) {
        int x = box.x + box.width / 2;
        int y = box.y + box.height / 2;
        return new Point(x, y);
    }

    public static void main(String[] args) {
        Point blank = new Point(5, 8);

        Rectangle rect = new Rectangle(0, 2, 4, 4);
        Point center = findCenter(rect);

        double dist = distance(center, blank);
        System.out.println(dist);
    }
\end{code}

\end{exercise}


\begin{exercise}
The method \java{grow} is part of the \java{Rectangle} class.

\begin{enumerate}

\item What is the output of the following program?

\item Draw a state diagram that shows the state of the program just before the end of \java{main}.
Include all local variables and the objects they refer to.

\item At the end of \java{main}, are \java{p1} and \java{p2} aliased?
Why or why not?

\end{enumerate}

\begin{code}
    public static void printPoint(Point p) {
        System.out.println("(" + p.x + ", " + p.y + ")");
    }

    public static Point findCenter(Rectangle box) {
        int x = box.x + box.width / 2;
        int y = box.y + box.height / 2;
        return new Point(x, y);
    }

    public static void main(String[] args) {
        Rectangle box1 = new Rectangle(2, 4, 7, 9);
        Point p1 = findCenter(box1);
        printPoint(p1);

        box1.grow(1, 1);
        Point p2 = findCenter(box1);
        printPoint(p2);
    }
\end{code}

\end{exercise}


\begin{exercise}
\label{ex.biginteger}

You might be sick of the factorial method by now, but we're going to do one more version.

\begin{enumerate}

\item Create a new program called \java{Big.java} and write an iterative version of \java{factorial}.

\item Print a table of the integers from 0 to 30 along with their factorials.
At some point around 15, you will probably see that the answers are not right any more.
Why not?

\item \java{BigInteger} is a Java class that can represent arbitrarily big integers.
There is no upper bound except the limitations of memory size and processing speed.
Read the documentation at \url{http://docs.oracle.com/javase/7/docs/api/java/math/BigInteger.html}.

\item To use BigIntegers, you have to add \java{import java.math.BigInteger} to the beginning of your program.

\item There are several ways to create a BigInteger, but the one I recommend uses \java{valueOf}.
The following code converts an integer to a \java{BigInteger}:

\begin{code}
    int x = 17;
    BigInteger big = BigInteger.valueOf(x);
\end{code}

Type in this code and try it out.
Try printing a BigInteger.

\item Because BigIntegers are not primitive types, the usual math operators don't work.
Instead we have to use methods like \java{add}.
To add two BigIntegers, invoke \java{add} on one and pass the other as an argument.
For example:

\begin{code}
    BigInteger small = BigInteger.valueOf(17);
    BigInteger big = BigInteger.valueOf(1700000000);
    BigInteger total = small.add(big);
\end{code}

Try out some of the other methods, like \java{multiply} and \java{pow}.

\item Convert \java{factorial} so that it performs its calculation using BigIntegers and returns a BigInteger as a result.
You can leave the parameter alone---it will still be an integer.

\item Try printing the table again with your modified factorial method.
Is it correct up to 30?
How high can you make it go?
I calculated the factorial of all the numbers from 0 to 999, but my machine is pretty slow, so it took a while.
The last number, 999!, has 2565 digits.

\end{enumerate}
\end{exercise}


\begin{exercise}
Many encryption techniques depend on the ability to raise large integers to an integer power.
Here is a method that implements a (reasonably) fast technique for integer exponentiation:

\begin{code}
    public static int pow(int x, int n) {
        if (n == 0) return 1;

        // find x to the n/2 recursively
        int t = pow(x, n / 2);

        // if n is even, the result is t squared
        // if n is odd, the result is t squared times x
        if (n % 2 == 0) {
            return t*t;
        } else {
            return t*t*x;
        }
    }
\end{code}

The problem with this method is that it only works if the result is smaller than 2 billion.
Rewrite it so that the result is a \java{BigInteger}.
The parameters should still be integers, though.

You can use the BigInteger methods \java{add} and \java{multiply}, but don't use \java{pow}, which would spoil the fun.
\end{exercise}


\end{document}
