

{% extends 'books/thinkjava/base.html' %}
{% block chaptercontent %}
<div class="row">
<div class="columns small-12">


      <div class="row">
        <div class="columns small-12"><h1 name="sec104" class="chapter">Chapter 9  Strings and things</h1>
<p>
<a name="strings"></a></p><p><a name="hevea_default451"></a>
<a name="hevea_default452"></a>
<a name="hevea_default453"></a></p><p>In Java and other object-oriented languages, an <span style="font-weight:bold">object</span> is a collection of data that provides a set of methods.
For example, <code>Scanner</code>, which we saw in Section <a href="/thinkjava/chapter3.html#scanner">3.2</a>, is an object that provides methods for parsing input.
<code>System.out</code> and <code>System.in</code> are also objects.</p><p>Strings are objects, too.
They contain characters and provide methods for manipulating character data.
We explore some of those methods in this chapter.</p><p><a name="hevea_default454"></a></p><p>Not everything in Java is an object: <code><span style="color:blue">int</span></code>, <code><span style="color:blue">double</span></code>, and <code><span style="color:blue">boolean</span></code> are so-called <span style="font-weight:bold">primitive</span> types.
We will explain some of the differences between object types and primitive types as we go along.</p>
<h2 name="sec105" class="section">9.1  Characters</h2>
<p><a name="hevea_default455"></a>
<a name="hevea_default456"></a>
<a name="hevea_default457"></a></p><p>Strings provide a method named <code>charAt</code>, which extracts a character.
It returns a <code><span style="color:blue">char</span></code>, a primitive type that stores an individual character (as opposed to strings of them).</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">String fruit = <span style="color:#B20000">"banana"</span>;
<span style="color:blue">char</span> letter = fruit.charAt(0);</td></tr>
</table><p>The argument <code>0</code> means that we want the letter at position 0.
Like array indexes, string indexes start at 0, so the character assigned to <code>letter</code> is <code>b</code>.</p><p>Characters work like the other primitive types we have seen.
You can compare them using relational operators:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">if</span> (letter == <span style="color:#B20000">'a'</span>) {
    System.out.println(<span style="color:#B20000">'?'</span>);
}</td></tr>
</table><p><a name="hevea_default458"></a>
<a name="hevea_default459"></a></p><p>Character literals, like <span style="color:#B20000"><code>'a'</code></span>, appear in single quotes.
Unlike string literals, which appear in double quotes, character literals can only contain a single character.
Escape sequences, like <span style="color:#B20000"><code>'\t'</code></span>, are legal because they represent a single character.</p><p>The increment and decrement operators work with characters.
So this loop displays the letters of the alphabet:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">System.out.print(<span style="color:#B20000">"Roman alphabet: "</span>);
<span style="color:blue">for</span> (<span style="color:blue">char</span> c = <span style="color:#B20000">'A'</span>; c &lt;= <span style="color:#B20000">'Z'</span>; c++) {
    System.out.print(c);
}
System.out.println();</td></tr>
</table><p><a name="hevea_default460"></a></p><p>Java uses <span style="font-weight:bold">Unicode</span> to represent characters, so strings can store text in other alphabets like Cyrillic and Greek, and non-alphabetic languages like Chinese.
You can read more about it at <a href="http://unicode.org/"><span style="font-family:monospace">http://unicode.org/</span></a>.</p><p>In Unicode, each character is represented by a “code unit”, which you can think of as an integer.
The code units for uppercase Greek letters run from 913 to 937, so we can display the Greek alphabet like this:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">System.out.print(<span style="color:#B20000">"Greek alphabet: "</span>);
<span style="color:blue">for</span> (<span style="color:blue">int</span> i = 913; i &lt;= 937; i++) {
    System.out.print((<span style="color:blue">char</span>) i);
}
System.out.println();</td></tr>
</table><p>This example uses a type cast to convert each integer (in the range) to the corresponding character.</p>
<h2 name="sec106" class="section">9.2  Strings are immutable</h2>
<p>
<a name="immutable"></a></p><p><a name="hevea_default461"></a>
<a name="hevea_default462"></a>
<a name="hevea_default463"></a></p><p>Strings provide methods, <code>toUpperCase</code> and <code>toLowerCase</code>, that convert from uppercase to lowercase and back.
These methods are often a source of confusion, because it sounds like they modify strings.
But neither these methods nor any others can change a string, because strings are <span style="font-weight:bold">immutable</span>.</p><p>When you invoke <code>toUpperCase</code> on a string, you get a new string object as a return value.
For example:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">String name = <span style="color:#B20000">"Alan Turing"</span>;
String upperName = name.toUpperCase();</td></tr>
</table><p><a name="hevea_default464"></a></p><p>After these statements run, <code>upperName</code> refers to the string <span style="color:#B20000"><code>"ALAN TURING"</code></span>.
But <code>name</code> still refers to <span style="color:#B20000"><code>"Alan Turing"</code></span>.</p><p><a name="hevea_default465"></a></p><p>Another useful method is <code>replace</code>, which finds and replaces instances of one string within another.
This example replaces <span style="color:#B20000"><code>"Computer Science"</code></span> with <span style="color:#B20000"><code>"CS"</code></span>:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">String text = <span style="color:#B20000">"Computer Science is fun!"</span>;
text = text.replace(<span style="color:#B20000">"Computer Science"</span>, <span style="color:#B20000">"CS"</span>);</td></tr>
</table><p>This example demonstrates a common way to work with string methods.
It invokes <code>text.replace</code>, which returns a reference to a new string, <span style="color:#B20000"><code>"CS is fun!"</code></span>.
Then it assigns the new string to <code>text</code>, replacing the old string.</p><p>This assignment is important; if you don’t save the return value, invoking <code>text.replace</code> has no effect.</p>
<h2 name="sec107" class="section">9.3  String traversal</h2>
<p>
<a name="stringtraverse"></a></p><p><a name="hevea_default466"></a></p><p>The following loop traverses the characters in <code>fruit</code> and displays them, one on each line:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">for</span> (<span style="color:blue">int</span> i = 0; i &lt; fruit.length(); i++) {
    <span style="color:blue">char</span> letter = fruit.charAt(i);
    System.out.println(letter);
}</td></tr>
</table><p><a name="hevea_default467"></a>
<a name="hevea_default468"></a></p><p>Strings provide a method called <code>length</code> that returns the number of characters in the string.
Because it is a method, you have to invoke it with the empty argument list, <code>()</code>.
</p><p><a name="hevea_default469"></a>
<a name="hevea_default470"></a></p><p>The condition is <code>i &lt; fruit.length()</code>, which means that when <code>i</code> is equal to the length of the string, the condition is <code><span style="color:blue">false</span></code> and the loop terminates.</p><p><a name="hevea_default471"></a></p><p>Unfortunately, the enhanced <code><span style="color:blue">for</span></code> loop does not work with strings.
But you can convert any string to a character array and iterate that:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">for</span> (<span style="color:blue">char</span> letter : fruit.toCharArray()) {
    System.out.println(letter);
}</td></tr>
</table><p>To find the last letter of a string, you might be tempted to try something like:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">int</span> length = fruit.length();
<span style="color:blue">char</span> last = fruit.charAt(length);      <span style="color:#007C00">// wrong!</span></td></tr>
</table><p><a name="hevea_default472"></a>
<a name="hevea_default473"></a></p><p>This code compiles and runs, but invoking the <code>charAt</code> method throws a <code>StringIndexOutOfBoundsException</code>.
The problem is that there is no sixth letter in <span style="color:#B20000"><code>"banana"</code></span>.
Since we started counting at 0, the 6 letters are indexed from 0 to 5.
To get the last character, you have to subtract 1 from <code>length</code>.</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">int</span> length = fruit.length();
<span style="color:blue">char</span> last = fruit.charAt(length - 1);  <span style="color:#007C00">// correct</span></td></tr>
</table><p>Many string traversals involve reading one string and creating another.
For example, to reverse a string, we simply add one character at a time:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">public static</span> String reverse(String s) {
    String r = <span style="color:#B20000">""</span>;
    <span style="color:blue">for</span> (<span style="color:blue">int</span> i = s.length() - 1; i &gt;= 0; i--) {
        r = r + s.charAt(i);
    }
    <span style="color:blue">return</span> r;
}</td></tr>
</table><p><a name="hevea_default474"></a></p><p>The initial value of <code>r</code> is <span style="color:#B20000"><code>""</code></span>, which is the <span style="font-weight:bold">empty string</span>.
The loop traverses the letters of <code>s</code> in reverse order.
Each time through the loop, it creates a new string and assigns it to <code>r</code>.
When the loop exits, <code>r</code> contains the letters from <code>s</code> in reverse order.
So the result of <code>reverse(<span style="color:#B20000">"banana"</span>)</code> is <span style="color:#B20000"><code>"ananab"</code></span>.</p>
<h2 name="sec108" class="section">9.4  Substrings</h2>
<p>The <code>substring</code> method returns a new string that copies letters from an existing string, starting at the given index.</p><ul class="itemize"><li class="li-itemize">
<code>fruit.substring(0)</code> returns <span style="color:#B20000"><code>"banana"</code></span>
</li><li class="li-itemize"><code>fruit.substring(2)</code> returns <span style="color:#B20000"><code>"nana"</code></span>
</li><li class="li-itemize"><code>fruit.substring(6)</code> returns <span style="color:#B20000"><code>""</code></span>
</li></ul><p>The first example returns a copy of the entire string.
The second example returns all but the first two characters.
As the last example shows, <code>substring</code> returns the empty string if the argument is the length of the string.</p><p>To visualize how the <code>substring</code> method works, it helps to draw a picture like Figure <a href="#fig.banana">9.1</a>.</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></a></div>
<div class="center">
<img src="thinkjava6016.png"/>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;">Figure 9.1: State diagram for a <code>String</code> of six characters.</td></tr>
</table></div>
<a name="fig.banana"></a>
</div>
<div class="center"><hr style="width:80%;height:2"/></div></blockquote><p>Like most string methods, <code>substring</code> is overloaded.
That is, there are other versions of <code>substring</code> that have different parameters.
If it’s invoked with two arguments, they are treated as a start and end index:</p><ul class="itemize"><li class="li-itemize">
<code>fruit.substring(0, 3)</code> returns <span style="color:#B20000"><code>"ban"</code></span>
</li><li class="li-itemize"><code>fruit.substring(2, 5)</code> returns <span style="color:#B20000"><code>"nan"</code></span>
</li><li class="li-itemize"><code>fruit.substring(6, 6)</code> returns <span style="color:#B20000"><code>""</code></span>
</li></ul><p>Notice that the character indicated by the end index is not included.
Defining <code>substring</code> this way simplifies some common operations.
For example, to select a substring with length <code>len</code>, starting at index <code>i</code>, you could write <code>fruit.substring(i, i + len)</code>.</p>
<h2 name="sec109" class="section">9.5  The indexOf method</h2>
<p><a name="hevea_default475"></a></p><p>The <code>indexOf</code> method searches for a character in a string.</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">String fruit = <span style="color:#B20000">"banana"</span>;
<span style="color:blue">int</span> index = fruit.indexOf(<span style="color:#B20000">'a'</span>);</td></tr>
</table><p>This example finds the index of <span style="color:#B20000"><code>'a'</code></span> in the string.
But the letter appears three times, so it’s not obvious what <code>indexOf</code> should do.
According to the documentation, it returns the index of the <em>first</em> appearance.</p><p>To find subsequent appearances, you can use another version of <code>indexOf</code>, which takes a second argument that indicates where in the string to start looking.</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">int</span> index = fruit.indexOf(<span style="color:#B20000">'a'</span>, 2);</td></tr>
</table><p>This code starts at index 2 (the first <span style="color:#B20000"><code>'n'</code></span>) and finds the next <span style="color:#B20000"><code>'a'</code></span>, which is at index 3.
If the letter happens to appear at the starting index, the starting index is the answer.
So <code>fruit.indexOf(<span style="color:#B20000">'a'</span>, 5)</code> returns <code>5</code>.</p><p>If the character does not appear in the string, <code>indexOf</code> returns <code>-1</code>.
Since indexes cannot be negative, this value indicates the character was not found.</p><p>You can also use <code>indexOf</code> to search for a substring, not just a single character.
For example, the expression <code>fruit.indexOf(<span style="color:#B20000">"nan"</span>)</code> returns <code>2</code>.</p>
<h2 name="sec110" class="section">9.6  String comparison</h2>
<p>
<a name="strcmp"></a></p><p><a name="hevea_default476"></a>
<a name="hevea_default477"></a></p><p>To compare two strings, it may be tempting to use the <code>==</code> and <code>!=</code> operators.</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">String name1 = <span style="color:#B20000">"Alan Turing"</span>;
String name2 = <span style="color:#B20000">"Ada Lovelace"</span>;
<span style="color:blue">if</span> (name1 == name2) {                 <span style="color:#007C00">// wrong!</span>
    System.out.println(<span style="color:#B20000">"The names are the same."</span>);
}</td></tr>
</table><p>This code compiles and runs, and most of the time it gets the answer right.
But it is not correct, and sometimes it gets the answer wrong.
The problem is that the <code>==</code> operator checks whether the two variables refer to the same object (by comparing the references).
If you give it two different strings that contain the same letters, it yields <code><span style="color:blue">false</span></code>.</p><p>The right way to compare strings is with the <code>equals</code> method, like this:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">if</span> (name1.equals(name2)) {
    System.out.println(<span style="color:#B20000">"The names are the same."</span>);
}</td></tr>
</table><p>This example invokes <code>equals</code> on <code>name1</code> and passes <code>name2</code> as an argument.
The <code>equals</code> method returns <code><span style="color:blue">true</span></code> if the strings contain the same characters; otherwise it returns <code><span style="color:blue">false</span></code>.</p><p>If the strings differ, we can use <code>compareTo</code> to see which comes first in alphabetical order:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">int</span> diff = name1.compareTo(name2);
<span style="color:blue">if</span> (diff == 0) {
    System.out.println(<span style="color:#B20000">"The names are the same."</span>);
} <span style="color:blue">else if</span> (diff &lt; 0) {
    System.out.println(<span style="color:#B20000">"name1 comes before name2."</span>);
} <span style="color:blue">else if</span> (diff &gt; 0) {
    System.out.println(<span style="color:#B20000">"name2 comes before name1."</span>);
}</td></tr>
</table><p>The return value from <code>compareTo</code> is the difference between the first characters in the strings that differ.
If the strings are equal, their difference is zero.
If the first string (the one on which the method is invoked) comes first in the alphabet, the difference is negative.
Otherwise, the difference is positive.</p><p>In the preceding code, <code>compareTo</code> returns positive 8, because the second letter of <span style="color:#B20000"><code>"Ada"</code></span> comes before the second letter of <span style="color:#B20000"><code>"Alan"</code></span> by 8 letters.</p><p><a name="hevea_default478"></a></p><p>Both <code>equals</code> and <code>compareTo</code> are case-sensitive.
The uppercase letters come before the lowercase letters, so <span style="color:#B20000"><code>"Ada"</code></span> comes before <span style="color:#B20000"><code>"ada"</code></span>.</p>
<h2 name="sec111" class="section">9.7  String formatting</h2>
<p><a name="hevea_default479"></a>
<a name="hevea_default480"></a></p><p>In Section <a href="/thinkjava/chapter3.html#printf">3.6</a>, we learned how to use <code>printf</code> to display formatted output.
Sometimes programs need to create strings that are formatted a certain way, but not display them immediately, or ever.
For example, the following method returns a time string in 12-hour format:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">public static</span> String timeString(<span style="color:blue">int</span> hour, <span style="color:blue">int</span> minute) {
    String ampm;
    <span style="color:blue">if</span> (hour &lt; 12) {
        ampm = <span style="color:#B20000">"AM"</span>;
        <span style="color:blue">if</span> (hour == 0) {
            hour = 12;  <span style="color:#007C00">// midnight</span>
        }
    } <span style="color:blue">else</span> {
        ampm = <span style="color:#B20000">"PM"</span>;
        hour = hour - 12;
    }
    <span style="color:blue">return</span> String.format(<span style="color:#B20000">"%02d:%02d %s"</span>, hour, minute, ampm);
}</td></tr>
</table><p><a name="hevea_default481"></a></p><p><code>String.format</code> takes the same arguments as <code>System.out.printf</code>: a format specifier followed by a sequence of values.
The main difference is that <code>System.out.printf</code> displays the result on the screen; <code>String.format</code> creates a new string, but does not display anything.</p><p>In this example, the format specifier <code>\%02d</code> means “two digit integer padded with zeros”, so <code>timeString(19, 5)</code> returns the string <span style="color:#B20000"><code>"07:05 PM"</code></span>.</p>
<h2 name="sec112" class="section">9.8  Wrapper classes</h2>
<p>
<a name="wrappers"></a></p><p>Primitive values (like <code><span style="color:blue">int</span></code>s, <code><span style="color:blue">double</span></code>s, and <code><span style="color:blue">char</span></code>s) do not provide methods.
For example, you can’t call <code>equals</code> on an <code><span style="color:blue">int</span></code>:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">int</span> i = 5;
System.out.println(i.equals(5));  <span style="color:#007C00">// compiler error</span></td></tr>
</table><p><a name="hevea_default482"></a>
<a name="hevea_default483"></a>
<a name="hevea_default484"></a>
<a name="hevea_default485"></a></p><p>But for each primitive type, there is a corresponding class in the Java library, called a <span style="font-weight:bold">wrapper class</span>.
The wrapper class for <code><span style="color:blue">char</span></code> is called <code>Character</code>; for <code><span style="color:blue">int</span></code> it’s called <code>Integer</code>.
Other wrapper classes include <code>Boolean</code>, <code>Long</code>, and <code>Double</code>.
They are in the <code>java.lang</code> package, so you can use them without importing them.</p><p>Each wrapper class defines constants <code>MIN_VALUE</code> and <code>MAX_VALUE</code>.
For example, <code>Integer.MIN_VALUE</code> is <code>-2147483648</code>, and <code>Integer.MAX_VALUE</code> is <code>2147483647</code>.
Because these constants are available in wrapper classes, you don’t have to remember them, and you don’t have to include them in your programs.</p><p>Wrapper classes provide methods for converting strings to other types.
For example, <code>Integer.parseInt</code> converts a string to (you guessed it) an integer:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">String str = <span style="color:#B20000">"12345"</span>;
<span style="color:blue">int</span> num = Integer.parseInt(str);</td></tr>
</table><p><a name="hevea_default486"></a></p><p>In this context, <span style="font-weight:bold">parse</span> means something like “read and translate”.</p><p>The other wrapper classes provide similar methods, like <code>Double.parseDouble</code> and <code>Boolean.parseBoolean</code>.
They also provide <code>toString</code>, which returns a string representation of a value:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">int</span> num = 12345;
String str = Integer.toString(num);</td></tr>
</table><p>The result is the string <span style="color:#B20000"><code>"12345"</code></span>.</p>
<h2 name="sec113" class="section">9.9  Command-line arguments</h2>
<p>Now that you know about arrays and strings, we can <em>finally</em> explain the <code>args</code> parameter for <code>main</code> that we have been ignoring since Chapter <a href="/thinkjava/chapter1.html#theway">1</a>.
If you are unfamiliar with the command-line interface, please read or review Appendix <a href="/thinkjava/appendix-a.html#commandline">A.3</a>.</p><p>Continuing an earlier example, let’s write a program to find the largest value in a sequence of numbers.
Rather than read the numbers from <code>System.in</code>, we’ll pass them as command-line arguments.
Here is a starting point:</p><p><script type="text/javascript">(function(d,l,s,i,c){function n(e){e=e.nextSibling;return (!e||e.nodeType!=3)?e:n(e);};function r(f){/in/.test(d.readyState) ? setTimeout(function(){r(f);},9):f()};l=d.getElementsByTagName('script');s=l[l.length-1];r(function(){i=n(s),c=n(i);i.setAttribute('data-src','https://trinket.io/tools/1.0/jekyll/embed/java#code='+encodeURIComponent(c.nodeValue.replace(/^\s+|\s+$/g,'')));});})(document)</script><iframe width="100%" height="400" frameborder="0" marginwidth="0" marginheight="0" class="lazyload" allowfullscreen=""/><!--
----{Max.java}----
public class Max {
    public static void main(String[] args) {
        System.out.println(Arrays.toString(args));
    }
}
--></p><p>You can run this program from the command line by typing:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">java Max</td></tr>
</table><p><a name="hevea_default487"></a></p><p>The output indicates that <code>args</code> is an <span style="font-weight:bold">empty array</span>; that is, it has no elements:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">[]</td></tr>
</table><p>But if you provide additional values on the command line, they are passed as arguments to <code>main</code>.
For example, if you run it like this:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">java Max 10 -3 55 0 14</td></tr>
</table><p>The output is:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">[10, -3, 55, 0, 14]</td></tr>
</table><p>But remember that the elements of <code>args</code> are strings.
To find the maximum number, we have to convert the arguments to integers.</p><p>The following fragment uses an enhanced <code><span style="color:blue">for</span></code> loop to parse the arguments (using the <code>Integer</code> wrapper class) and find the largest value:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">int</span> max = Integer.MIN_VALUE;
<span style="color:blue">for</span> (String arg : args) {
    <span style="color:blue">int</span> value = Integer.parseInt(arg);
    <span style="color:blue">if</span> (value &gt; max) {
        max = value;
    }
}
System.out.println(<span style="color:#B20000">"The max is "</span> + max);</td></tr>
</table><p>The initial value of <code>max</code> is the smallest (most negative) number an <code><span style="color:blue">int</span></code> can represent, so any other value is greater.
If <code>args</code> is empty, the result is <code>MIN_VALUE</code>.</p>
<h2 name="sec114" class="section">9.10  Vocabulary</h2>
<dl class="description"><dt class="dt-description"><span style="font-weight:bold">object:</span></dt><dd class="dd-description"><a name="hevea_default488"></a>
A collection of related data that comes with a set of methods that operate on it.</dd><dt class="dt-description"><span style="font-weight:bold">primitive:</span></dt><dd class="dd-description"><a name="hevea_default489"></a>
A data type that stores a single value and provides no methods.</dd><dt class="dt-description"><span style="font-weight:bold">Unicode:</span></dt><dd class="dd-description"><a name="hevea_default490"></a>
A standard for representing characters in most of the world’s languages.</dd><dt class="dt-description"><span style="font-weight:bold">immutable:</span></dt><dd class="dd-description"><a name="hevea_default491"></a>
An object that, once created, cannot be modified.
Strings are immutable by design.</dd><dt class="dt-description"><span style="font-weight:bold">empty string:</span></dt><dd class="dd-description"><a name="hevea_default492"></a>
The string <span style="color:#B20000"><code>""</code></span>, which contains no characters and has a length of zero.</dd><dt class="dt-description"><span style="font-weight:bold">wrapper class:</span></dt><dd class="dd-description"><a name="hevea_default493"></a>
Classes in <code>java.lang</code> that provide constants and methods for working with primitive types.</dd><dt class="dt-description"><span style="font-weight:bold">parse:</span></dt><dd class="dd-description"><a name="hevea_default494"></a>
To read a string and interpret or translate it.</dd><dt class="dt-description"><span style="font-weight:bold">empty array:</span></dt><dd class="dd-description"><a name="hevea_default495"></a>
An array with no elements and a length of zero.</dd></dl>
<h2 name="sec115" class="section">9.11  Exercises</h2>
<p>The code for this chapter is in the <span style="font-family:monospace">ch09</span> directory of <span style="font-family:monospace">ThinkJavaCode</span>.
See page <a href="/thinkjava/preface.html#code">??</a> for instructions on how to download the repository.
Before you start the exercises, we recommend that you compile and run the examples.</p><div class="theorem"><span style="font-weight:bold">Exercise 1</span>  <p><em>The point of this exercise is to explore Java types and fill in some of the details that aren’t covered in the chapter.</em></p><p><a name="hevea_default496"></a></p><ol class="enumerate" type="1"><li class="li-enumerate"><em>Create a new program named <span style="font-family:monospace">Test.java</span> and write a <code>main</code> method that contains expressions that combine various types using the <code>+</code> operator.
For example, what happens when you “add” a <code>String</code> and a <span style="color:blue"><code>char</code></span>?
Does it perform character addition or string concatenation?
What is the type of the result?
(How can you determine the type of the result?)</em></li><li class="li-enumerate"><em>Make a bigger copy of the following table and fill it in.
At the intersection of each pair of types, you should indicate whether it is legal to use the <code>+</code> operator with these types, what operation is performed (addition or concatenation), and what the type of the result is.</em><div class="center">
<table border="1" style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:left;border:solid 1px;white-space:nowrap"> </td><td style="text-align:left;border:solid 1px;white-space:nowrap"><em>boolean</em></td><td style="text-align:left;border:solid 1px;white-space:nowrap"><em> char </em></td><td style="text-align:left;border:solid 1px;white-space:nowrap"><em>  int  </em></td><td style="text-align:left;border:solid 1px;white-space:nowrap"><em>double</em></td><td style="text-align:left;border:solid 1px;white-space:nowrap"><em>String </em></td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap"><em>boolean</em></td><td style="text-align:left;border:solid 1px;white-space:nowrap"> </td><td style="text-align:left;border:solid 1px;white-space:nowrap"> </td><td style="text-align:left;border:solid 1px;white-space:nowrap"> </td><td style="text-align:left;border:solid 1px;white-space:nowrap"> </td><td style="text-align:left;border:solid 1px;white-space:nowrap"> </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap"><em>char</em></td><td style="text-align:left;border:solid 1px;white-space:nowrap"> </td><td style="text-align:left;border:solid 1px;white-space:nowrap"> </td><td style="text-align:left;border:solid 1px;white-space:nowrap"> </td><td style="text-align:left;border:solid 1px;white-space:nowrap"> </td><td style="text-align:left;border:solid 1px;white-space:nowrap"> </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap"><em>int</em></td><td style="text-align:left;border:solid 1px;white-space:nowrap"> </td><td style="text-align:left;border:solid 1px;white-space:nowrap"> </td><td style="text-align:left;border:solid 1px;white-space:nowrap"> </td><td style="text-align:left;border:solid 1px;white-space:nowrap"> </td><td style="text-align:left;border:solid 1px;white-space:nowrap"> </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap"><em>double</em></td><td style="text-align:left;border:solid 1px;white-space:nowrap"> </td><td style="text-align:left;border:solid 1px;white-space:nowrap"> </td><td style="text-align:left;border:solid 1px;white-space:nowrap"> </td><td style="text-align:left;border:solid 1px;white-space:nowrap"> </td><td style="text-align:left;border:solid 1px;white-space:nowrap"> </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap"><em>String</em></td><td style="text-align:left;border:solid 1px;white-space:nowrap"> </td><td style="text-align:left;border:solid 1px;white-space:nowrap"> </td><td style="text-align:left;border:solid 1px;white-space:nowrap"> </td><td style="text-align:left;border:solid 1px;white-space:nowrap"> </td><td style="text-align:left;border:solid 1px;white-space:nowrap"> </td></tr>
</table>
</div></li><li class="li-enumerate"><em>Think about some of the choices the designers of Java made when they filled in this table.
How many of the entries seem unavoidable, as if there was no other choice?
How many seem like arbitrary choices from several equally reasonable possibilities?
Which entries seem most problematic?</em></li><li class="li-enumerate"><em>Here’s a puzzler: normally, the statement <code>x++</code> is exactly equivalent to <code>x = x + 1</code>.
But if <code>x</code> is a <span style="color:blue"><code>char</code></span>, it’s not exactly the same!
In that case, <code>x++</code> is legal, but <code>x = x + 1</code> causes an error.
Try it out and see what the error message is, then see if you can figure out what is going on.</em></li><li class="li-enumerate"><em>What happens when you add <span style="color:#B20000"><code>""</code></span> (the empty string) to the other types, for example, <code><span style="color:#B20000">""</span> + 5</code>?</em></li><li class="li-enumerate"><em>For each data type, what types of values can you assign to it?
For example, you can assign an <span style="color:blue"><code>int</code></span> to a <span style="color:blue"><code>double</code></span> but not vice versa.</em></li></ol></div><div class="theorem"><span style="font-weight:bold">Exercise 2</span>  <em>
Write a method called <code>letterHist</code> that takes a string as a parameter and returns a histogram of the letters in the string.
The zeroth element of the histogram should contain the number of a’s in the string (upper- and lowercase); the 25th element should contain the number of z’s.
Your solution should only traverse the string once.
</em></div><div class="theorem"><span style="font-weight:bold">Exercise 3</span>  <p><a name="hevea_default497"></a>
<a name="hevea_default498"></a></p><p><em>The purpose of this exercise is to review encapsulation and generalization (see Section </em><a href="/thinkjava/chapter7.html#encapsulation"><em>7.3</em></a><em>).
The following code fragment traverses a string and checks whether it has the same number of open and close parentheses:</em></p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><em>String s = <span style="color:#B20000">"((3 + 7) * 2)"</span>;
<span style="color:blue">int</span> count = 0;

<span style="color:blue">for</span> (<span style="color:blue">int</span> i = 0; i &lt; s.length(); i++) {
    <span style="color:blue">char</span> c = s.charAt(i);
    <span style="color:blue">if</span> (c == <span style="color:#B20000">'('</span>) {
        count++;
    } <span style="color:blue">else if</span> (c == <span style="color:#B20000">')'</span>) {
        count--;
    }
}

System.out.println(count);</em></td></tr>
</table><ol class="enumerate" type="1"><li class="li-enumerate"><em>Encapsulate this fragment in a method that takes a string argument and returns the final value of <code>count</code>.</em></li><li class="li-enumerate"><em>Now that you have generalized the code so that it works on any string, what could you do to generalize it more?</em></li><li class="li-enumerate"><em>Test your method with multiple strings, including some that are balanced and some that are not.</em></li></ol></div><div class="theorem"><span style="font-weight:bold">Exercise 4</span>  <p><em>Create a program called <span style="font-family:monospace">Recurse.java</span> and type in the following methods:</em></p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><em><span style="color:#007C00">/**
 * Returns the first character of the given String.
 */</span>
<span style="color:blue">public static char</span> first(String s) {
    <span style="color:blue">return</span> s.charAt(0);
}</em></td></tr>
</table><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><em><span style="color:#007C00">/**
 * Returns all but the first letter of the given String.
 */</span>
<span style="color:blue">public static</span> String rest(String s) {
    <span style="color:blue">return</span> s.substring(1);
}</em></td></tr>
</table><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><em><span style="color:#007C00">/**
 * Returns all but the first and last letter of the String.
 */</span>
<span style="color:blue">public static</span> String middle(String s) {
    <span style="color:blue">return</span> s.substring(1, s.length() - 1);
}</em></td></tr>
</table><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><em><span style="color:#007C00">/**
 * Returns the length of the given String.
 */</span>
<span style="color:blue">public static int</span> length(String s) {
    <span style="color:blue">return</span> s.length();
}</em></td></tr>
</table><ol class="enumerate" type="1"><li class="li-enumerate"><em>Write some code in <code>main</code> that tests each of these methods.
Make sure they work, and you understand what they do.</em></li><li class="li-enumerate"><em>Using these methods, and without using any other <code>String</code> methods, write a method called <code>printString</code> that takes a string as a parameter and that displays the letters of the string, one on each line.
It should be a void method.</em></li><li class="li-enumerate"><em>Again using only these methods, write a method called <code>printBackward</code> that does the same thing as <code>printString</code> but that displays the string backward (again, one character per line).</em></li><li class="li-enumerate"><em>Now write a method called <code>reverseString</code> that takes a string as a parameter and that returns a new string as a return value.
The new string should contain the same letters as the parameter, but in reverse order.</em><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><em>String backwards = reverseString(<span style="color:#B20000">"coffee"</span>);
System.out.println(backwards);</em></td></tr>
</table><p><em>The output of this example code should be:</em></p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><em>eeffoc</em></td></tr>
</table><p><a name="hevea_default499"></a></p></li><li class="li-enumerate"><em>A palindrome is a word that reads the same both forward and backward, like “otto” and “palindromeemordnilap”.
Here’s one way to test whether a string is a palindrome:</em><blockquote class="quotation"><em>
A single letter is a palindrome, a two-letter word is a palindrome if the letters are the same, and any other word is a palindrome if the first letter is the same as the last and the middle is a palindrome.
</em></blockquote><p><em>Write a recursive method named <code>isPalindrome</code> that takes a <code>String</code> and returns a <span style="color:blue"><code>boolean</code></span> indicating whether the word is a palindrome.</em></p></li></ol></div><div class="theorem"><span style="font-weight:bold">Exercise 5</span>  
<a name="abecedarian"></a>
<a name="hevea_default500"></a><p><em>A word is said to be “abecedarian” if the letters in the word appear in alphabetical order.
For example, the following are all six-letter English abecedarian words:</em></p><blockquote class="quote"><em>
abdest, acknow, acorsy, adempt, adipsy, agnosy, befist, behint, beknow, bijoux, biopsy, cestuy, chintz, deflux, dehors, dehort, deinos, diluvy, dimpsy </em></blockquote><p><em>Write a method called <code>isAbecedarian</code> that takes a <code>String</code> and returns a <span style="color:blue"><code>boolean</code></span> indicating whether the word is abecedarian.
Your method can be iterative or recursive.</em></p></div><div class="theorem"><span style="font-weight:bold">Exercise 6</span>  
<a name="hevea_default501"></a><p><em>A word is said to be a “doubloon” if every letter that appears in the word appears exactly twice.
Here are some example doubloons found in the dictionary:</em></p><blockquote class="quote"><em>
Abba, Anna, appall, appearer, appeases, arraigning, beriberi, bilabial, boob, Caucasus, coco, Dada, deed, Emmett, Hannah, horseshoer, intestines, Isis, mama, Mimi, murmur, noon, Otto, papa, peep, reappear, redder, sees, Shanghaiings, Toto
</em></blockquote><p><em>Write a method called <code>isDoubloon</code> that takes a string and checks whether it is a doubloon.
To ignore case, invoke the <code>toLowerCase</code> method before checking.
</em></p></div><div class="theorem"><span style="font-weight:bold">Exercise 7</span>  
<a name="hevea_default502"></a><p><em>Two words are anagrams if they contain the same letters and the same number of each letter.
For example, “stop” is an anagram of “pots” and “allen downey” is an anagram of “well annoyed”.</em></p><p><em>Write a method that takes two strings and checks whether they are anagrams of each other.
</em></p></div><div class="theorem"><span style="font-weight:bold">Exercise 8</span>  
<a name="hevea_default503"></a><p><em>In Scrabble</em><sup><a name="text1" href="#note1"><em>1</em></a></sup><em> each player has a set of tiles with letters on them.
The object of the game is to use those letters to spell words.
The scoring system is complex, but longer words are usually worth more than shorter words.</em></p><p><em>Imagine you are given your set of tiles as a string, like <span style="color:#B20000"><code>"quijibo"</code></span>, and you are given another string to test, like <span style="color:#B20000"><code>"jib"</code></span>.</em></p><p><em>Write a method called <code>canSpell</code> that takes two strings and checks whether the set of tiles can spell the word.
You might have more than one tile with the same letter, but you can only use each tile once.</em></p></div>
<hr class="footnoterule"/><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a name="note1" href="#text1">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Scrabble is a registered trademark owned in the USA and Canada by Hasbro Inc., and in the rest of the world by J. W. Spear &amp; Sons Limited of Maidenhead, Berkshire, England, a subsidiary of Mattel Inc.</div>
</dd></dl>
</div>
</div>

</div>

</div>
{% endblock %}

{% block toc %}
<li class="has-dropdown"><a href="/thinkjava/chapter9.html">Strings and things</a>
<ul class="dropdown">
<li><a href="/thinkjava/chapter9.html#sec105">Characters</a>
</li><li><a href="/thinkjava/chapter9.html#sec106">Strings are immutable</a>
</li><li><a href="/thinkjava/chapter9.html#sec107">String traversal</a>
</li><li><a href="/thinkjava/chapter9.html#sec108">Substrings</a>
</li><li><a href="/thinkjava/chapter9.html#sec109">The indexOf method</a>
</li><li><a href="/thinkjava/chapter9.html#sec110">String comparison</a>
</li><li><a href="/thinkjava/chapter9.html#sec111">String formatting</a>
</li><li><a href="/thinkjava/chapter9.html#sec112">Wrapper classes</a>
</li><li><a href="/thinkjava/chapter9.html#sec113">Command-line arguments</a>
</li><li><a href="/thinkjava/chapter9.html#sec114">Vocabulary</a>
</li><li><a href="/thinkjava/chapter9.html#sec115">Exercises</a>
</li></ul>
</li>
{% endblock %}

{% block title%}Strings and things | Think Java | Trinket{% endblock %}
