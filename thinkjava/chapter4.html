

{% extends 'books/thinkjava/base.html' %}
{% block chaptercontent %}
<div class="row">
<div class="columns small-12">


      <div class="row">
        <div class="columns small-12"><h1 name="sec44" class="chapter">Chapter 4  Void methods</h1>
<p>
<a name="voidmeth"></a></p><p>So far we’ve only written short programs that have a single class and a single method (<code>main</code>).
In this chapter, we’ll show you how to organize longer programs into multiple methods and classes.
We’ll also present the <code>Math</code> class, which provides methods for common mathematical operations.</p>
<h2 name="sec45" class="section">4.1  Math methods</h2>
<p><a name="hevea_default195"></a>
<a name="hevea_default196"></a></p><p>In mathematics, you have probably seen functions like sin and log, and you have learned to evaluate expressions like sin(π/2) and log(1/<span style="font-style:italic">x</span>).
First, you evaluate the expression in parentheses, which is called the <span style="font-weight:bold">argument</span> of the function.
Then you can evaluate the function itself, maybe by punching it into a calculator.</p><p>This process can be applied repeatedly to evaluate more complex expressions like log(1/sin(π/2)).
First we evaluate the argument of the innermost function, then evaluate the function itself, and so on.</p><p><a name="hevea_default197"></a>
<a name="hevea_default198"></a>
<a name="hevea_default199"></a></p><p>The Java library includes a <code>Math</code> class that provides common mathematical operations.
<code>Math</code> is in the <code>java.lang</code> package, so you don’t have to import it.
You can use, or <span style="font-weight:bold">invoke</span>, <code>Math</code> methods like this:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">double</span> root = Math.sqrt(17.0);
<span style="color:blue">double</span> angle = 1.5;
<span style="color:blue">double</span> height = Math.sin(angle);</td></tr>
</table><p>The first line sets <code>root</code> to the square root of 17.
The third line finds the sine of 1.5 (the value of <code>angle</code>).</p><p><a name="hevea_default200"></a>
<a name="hevea_default201"></a>
<a name="hevea_default202"></a></p><p>Arguments of the trigonometric functions – <code>sin</code>, <code>cos</code>, and <code>tan</code> – should be in <em>radians</em>.
To convert from degrees to radians, you can divide by 180 and multiply by π.
Conveniently, the <code>Math</code> class provides a constant double named <code>PI</code> that contains an approximation of π:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">double</span> degrees = 90;
<span style="color:blue">double</span> angle = degrees / 180.0 * Math.PI;</td></tr>
</table><p>Notice that <code>PI</code> is in capital letters.
Java does not recognize <code>Pi</code>, <code>pi</code>, or <code>pie</code>.
Also, <code>PI</code> is the name of a variable, not a method, so it doesn’t have parentheses.
The same is true for the constant <code>Math.E</code>, which approximates Euler’s number.</p><p>Converting to and from radians is a common operation, so the <code>Math</code> class provides methods that do it for you.</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">double</span> radians = Math.toRadians(180.0);
<span style="color:blue">double</span> degrees = Math.toDegrees(Math.PI);</td></tr>
</table><p><a name="hevea_default203"></a>
<a name="hevea_default204"></a></p><p>Another useful method is <code>round</code>, which rounds a floating-point value to the nearest integer and returns a <code><span style="color:blue">long</span></code>.
A <code><span style="color:blue">long</span></code> is like an <code><span style="color:blue">int</span></code>, but bigger.
More specifically, an <code><span style="color:blue">int</span></code> uses 32 bits; the largest value it can hold is 2<sup>31</sup>−1, which is about 2 billion.
A <code><span style="color:blue">long</span></code> uses 64 bits, so the largest value is 2<sup>63</sup>−1, which is about 9 quintillion.</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">long</span> x = Math.round(Math.PI * 20.0);</td></tr>
</table><p>The result is 63 (rounded up from 62.8319).</p><p>Take a minute to read the documentation for these and other methods in the <code>Math</code> class.
The easiest way to find documentation for Java classes is to do a web search for “Java” and the name of the class.</p>
<h2 name="sec46" class="section">4.2  Composition revisited</h2>
<p><a name="hevea_default205"></a>
<a name="hevea_default206"></a></p><p>Just as with mathematical functions, Java methods can be <em>composed</em>.
That means you can use one expression as part of another.
For example, you can use any expression as an argument to a method:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">double</span> x = Math.cos(angle + Math.PI / 2.0);</td></tr>
</table><p>This statement divides <code>Math.PI</code> by two, adds the result to <code>angle</code>, and computes the cosine of the sum.
You can also take the result of one method and pass it as an argument to another:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">double</span> x = Math.exp(Math.log(10.0));</td></tr>
</table><p>In Java, the <code>log</code> method always uses base <span style="font-style:italic">e</span>.
So this statement finds the log base <span style="font-style:italic">e</span> of 10, and then raises <span style="font-style:italic">e</span> to that power.
The result gets assigned to <code>x</code>.</p><p>Some math methods take more than one argument.
For example, <code>Math.pow</code> takes two arguments and raises the first to the power of the second.
This line of code assigns the value <code>1024.0</code> to the variable <code>x</code>:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">double</span> x = Math.pow(2.0, 10.0);</td></tr>
</table><p>When using <code>Math</code> methods, it is a common error to forget the <code>Math</code>.
For example, if you try to invoke <code>pow(2.0, 10.0)</code>, you get an error message like:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">File: Test.java  [line: 5]
Error: cannot find symbol
  symbol:   method pow(double,double)
  location: class Test</td></tr>
</table><p>The message “cannot find symbol” is confusing, but the last line provides a useful hint.
The compiler is looking for <code>pow</code> in the same class where it is used, which is <code>Test</code>.
If you don’t specify a class name, the compiler looks in the current class.</p>
<h2 name="sec47" class="section">4.3  Adding new methods</h2>
<p>
<a name="adding_methods"></a></p><p><a name="hevea_default207"></a></p><p>You have probably guessed by now that you can define more than one method in a class.
Here’s an example:</p><p><script type="text/javascript">(function(d,l,s,i,c){function n(e){e=e.nextSibling;return (!e||e.nodeType!=3)?e:n(e);};function r(f){/in/.test(d.readyState) ? setTimeout(function(){r(f);},9):f()};l=d.getElementsByTagName('script');s=l[l.length-1];r(function(){i=n(s),c=n(i);i.setAttribute('data-src','https://trinket.io/tools/1.0/jekyll/embed/java#code='+encodeURIComponent(c.nodeValue.replace(/^\s+|\s+$/g,'')));});})(document)</script><iframe width="100%" height="400" frameborder="0" marginwidth="0" marginheight="0" class="lazyload" allowfullscreen=""/><!--
----{NewLine.java}----
public class NewLine {

    public static void newLine() {
        System.out.println();
    }

    public static void main(String[] args) {
        System.out.println("First line.");
        newLine();
        System.out.println("Second line.");
    }
}
--></p><p><a name="hevea_default208"></a>
<a name="hevea_default209"></a></p><p>The name of the class is <code>NewLine</code>.
By convention, class names begin with a capital letter.
<code>NewLine</code> contains two methods, <code>newLine</code> and <code>main</code>.
Remember that Java is case-sensitive, so <code>NewLine</code> and <code>newLine</code> are not the same.</p><p><a name="hevea_default210"></a></p><p>Method names should begin with a lowercase letter and use “camel case”, which is a cute name for <code>jammingWordsTogetherLikeThis</code>.
You can use any name you want for methods, except <code>main</code> or any of the Java keywords.</p><p><a name="hevea_default211"></a>
<a name="hevea_default212"></a>
<a name="hevea_default213"></a></p><p><code>newLine</code> and <code>main</code> are <code><span style="color:blue">public</span></code>, which means they can be invoked from other classes.
They are both <code><span style="color:blue">static</span></code>, but we can’t explain what that means yet.
And they are both <code><span style="color:blue">void</span></code>, which means that they don’t yield a result (unlike the <code>Math</code> methods, for example).</p><p><a name="hevea_default214"></a></p><p>The parentheses after the method name contain a list of variables, called <span style="font-weight:bold">parameters</span>, where the method stores its arguments.
<code>main</code> has a single parameter, called <code>args</code>, which has type <code>String[]</code>.
That means that whoever invokes <code>main</code> must provide an array of strings (we’ll get to arrays in a later chapter).</p><p>Since <code>newLine</code> has no parameters, it requires no arguments, as shown when it is invoked in <code>main</code>.
And because <code>newLine</code> is in the same class as <code>main</code>, we don’t have to specify the class name.</p><p>The output of this program is:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">First line.

Second line.</td></tr>
</table><p>Notice the extra space between the lines.
If we wanted more space between them, we could invoke the same method repeatedly:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">public static void</span> main(String[] args) {
    System.out.println(<span style="color:#B20000">"First line."</span>);
    newLine();
    newLine();
    newLine();
    System.out.println(<span style="color:#B20000">"Second line."</span>);
}</td></tr>
</table><p>Or we could write a new method that displays three blank lines:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">public static void</span> threeLine() {
    newLine();
    newLine();
    newLine();
}

<span style="color:blue">public static void</span> main(String[] args) {
    System.out.println(<span style="color:#B20000">"First line."</span>);
    threeLine();
    System.out.println(<span style="color:#B20000">"Second line."</span>);
}</td></tr>
</table><p>You can invoke the same method more than once, and you can have one method invoke another.
In this example, <code>main</code> invokes <code>threeLine</code>, and <code>threeLine</code> invokes <code>newLine</code>.</p><p>Beginners often wonder why it is worth the trouble to create new methods.
There are many reasons, but this example demonstrates a few of them:</p><ul class="itemize"><li class="li-itemize">Creating a new method gives you an opportunity to give a name to a group of statements, which makes code easier to read and understand.
</li><li class="li-itemize">Introducing new methods can make a program smaller by eliminating repetitive code.
For example, to display nine consecutive new lines, you could invoke <code>threeLine</code> three times.</li><li class="li-itemize">A common problem solving technique is to break tasks down into sub-problems.
Methods allow you to focus on each sub-problem in isolation, and then compose them into a complete solution.</li></ul>
<h2 name="sec48" class="section">4.4  Flow of execution</h2>
<p><a name="hevea_default215"></a>
<a name="hevea_default216"></a></p><p>Pulling together the code from the previous section, the complete program looks like this:</p><p><script type="text/javascript">(function(d,l,s,i,c){function n(e){e=e.nextSibling;return (!e||e.nodeType!=3)?e:n(e);};function r(f){/in/.test(d.readyState) ? setTimeout(function(){r(f);},9):f()};l=d.getElementsByTagName('script');s=l[l.length-1];r(function(){i=n(s),c=n(i);i.setAttribute('data-src','https://trinket.io/tools/1.0/jekyll/embed/java#code='+encodeURIComponent(c.nodeValue.replace(/^\s+|\s+$/g,'')));});})(document)</script><iframe width="100%" height="400" frameborder="0" marginwidth="0" marginheight="0" class="lazyload" allowfullscreen=""/><!--
----{NewLine.java}----
public class NewLine {

    public static void newLine() {
        System.out.println();
    }

    public static void threeLine() {
        newLine();
        newLine();
        newLine();
    }

    public static void main(String[] args) {
        System.out.println("First line.");
        threeLine();
        System.out.println("Second line.");
    }
}
--></p><p><a name="hevea_default217"></a></p><p>When you look at a class definition that contains several methods, it is tempting to read it from top to bottom.
But that is likely to be confusing, because that is not the <span style="font-weight:bold">flow of execution</span> of the program.</p><p>Execution always begins at the first statement of <code>main</code>, regardless of where it is in the source file.
Statements are executed one at a time, in order, until you reach a method invocation, which you can think of as a detour.
Instead of going to the next statement, you jump to the first line of the invoked method, execute all the statements there, and then come back and pick up exactly where you left off.</p><p>That sounds simple enough, but remember that one method can invoke another one.
In the middle of <code>main</code>, we go off to execute the statements in <code>threeLine</code>.
While we are executing <code>threeLine</code>, we go off to execute <code>newLine</code>.
Then <code>newLine</code> invokes <code>println</code>, which causes yet another detour.</p><p>Fortunately, Java is good at keeping track of which methods are running.
So when <code>println</code> completes, it picks up where it left off in <code>newLine</code>; when <code>newLine</code> completes, it goes back to <code>threeLine</code>, and when <code>threeLine</code> completes, it gets back to <code>main</code>.</p><p>In summary, when you read a program, don’t read from top to bottom.
Instead, follow the flow of execution.</p>
<h2 name="sec49" class="section">4.5  Parameters and arguments</h2>
<p><a name="hevea_default218"></a>
<a name="hevea_default219"></a></p><p>Some of the methods we have used require arguments, which are the values you provide when you invoke the method.
For example, to find the sine of a number, you have to provide the number, so <code>sin</code> takes a <code><span style="color:blue">double</span></code> as an argument.
To display a message, you have to provide the message, so <code>println</code> takes a <code>String</code>.</p><p>When you use a method, you provide the arguments.
When you write a method, you name the parameters.
The parameter list indicates what arguments are required.
The following class shows an example:</p><p><script type="text/javascript">(function(d,l,s,i,c){function n(e){e=e.nextSibling;return (!e||e.nodeType!=3)?e:n(e);};function r(f){/in/.test(d.readyState) ? setTimeout(function(){r(f);},9):f()};l=d.getElementsByTagName('script');s=l[l.length-1];r(function(){i=n(s),c=n(i);i.setAttribute('data-src','https://trinket.io/tools/1.0/jekyll/embed/java#code='+encodeURIComponent(c.nodeValue.replace(/^\s+|\s+$/g,'')));});})(document)</script><iframe width="100%" height="400" frameborder="0" marginwidth="0" marginheight="0" class="lazyload" allowfullscreen=""/><!--
----{PrintTwice.java}----
public class PrintTwice {

    public static void printTwice(String s) {
        System.out.println(s);
        System.out.println(s);
    }

    public static void main(String[] args) {
        printTwice("Don't make me say this twice!");
    }
}
--></p><p><code>printTwice</code> has a parameter named <code>s</code> with type <code>String</code>.
When we invoke <code>printTwice</code>, we have to provide an argument with type <code>String</code>.</p><p>Before the method executes, the argument gets assigned to the parameter.
In this example, the argument <span style="color:#B20000"><code>"Don't make me say this twice!"</code></span> gets assigned to the parameter <code>s</code>.</p><p><a name="hevea_default220"></a></p><p>This process is called <span style="font-weight:bold">parameter passing</span> because the value gets passed from outside the method to the inside.
An argument can be any kind of expression, so if you have a <code>String</code> variable, you can use it as an argument:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">String argument = <span style="color:#B20000">"Never say never."</span>;
printTwice(argument);</td></tr>
</table><p>The value you provide as an argument must have the same type as the parameter.
For example, if you try:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">printTwice(17);  <span style="color:#007C00">// syntax error</span></td></tr>
</table><p>You will get an error message like this:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">File: Test.java  [line: 10]
Error: method printTwice in class Test cannot be applied
       to given types;
  required: java.lang.String
  found: int
  reason: actual argument int cannot be converted to
          java.lang.String by method invocation conversion</td></tr>
</table><p>Sometimes Java can convert an argument from one type to another automatically.
For example, <code>Math.sqrt</code> requires a <code><span style="color:blue">double</span></code>, but if you invoke <code>Math.sqrt(25)</code>, the integer value <code>25</code> is automatically converted to the floating-point value <code>25.0</code>.
But in the case of <code>printTwice</code>, Java can’t (or won’t) convert the integer <code>17</code> to a <code>String</code>.</p><p>Parameters and other variables only exist inside their own methods.
Inside <code>main</code>, there is no such thing as <code>s</code>.
If you try to use it there, you’ll get a compiler error.
Similarly, inside <code>printTwice</code> there is no such thing as <code>argument</code>.
That variable belongs to <code>main</code>.</p><p><a name="hevea_default221"></a>
<a name="hevea_default222"></a></p><p>Because variables only exist inside the methods where they are defined, they are often called <span style="font-weight:bold">local variables</span>.</p>
<h2 name="sec50" class="section">4.6  Multiple parameters</h2>
<p>
<a name="time"></a></p><p><a name="hevea_default223"></a>
<a name="hevea_default224"></a></p><p>Here is an example of a method that takes two parameters:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">public static void</span> printTime(<span style="color:blue">int</span> hour, <span style="color:blue">int</span> minute) {
    System.out.print(hour);
    System.out.print(<span style="color:#B20000">":"</span>);
    System.out.println(minute);
}</td></tr>
</table><p>In the parameter list, it may be tempting to write:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">public static void</span> printTime(<span style="color:blue">int</span> hour, minute) {
    ...</td></tr>
</table><p>But that format (without the second <code><span style="color:blue">int</span></code>) is only legal for variable declarations.
In parameter lists, you need to specify the type of each variable separately.</p><p>To invoke this method, we have to provide two integers as arguments:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">int</span> hour = 11;
<span style="color:blue">int</span> minute = 59;
printTime(hour, minute);</td></tr>
</table><p>A common error is to declare the types of the arguments, like this:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">int</span> hour = 11;
<span style="color:blue">int</span> minute = 59;
printTime(<span style="color:blue">int</span> hour, <span style="color:blue">int</span> minute);  <span style="color:#007C00">// syntax error</span></td></tr>
</table><p>That’s a syntax error; the compiler sees <code><span style="color:blue">int</span> hour</code> and <code><span style="color:blue">int</span> minute</code> as variable declarations, not expressions.
You wouldn’t declare the types of the arguments if they were simply integers:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">printTime(<span style="color:blue">int</span> 11, <span style="color:blue">int</span> 59);  <span style="color:#007C00">// syntax error</span></td></tr>
</table>
<h2 name="sec51" class="section">4.7  Stack diagrams</h2>
<p>
<a name="stack"></a></p><p>Pulling together the code fragments from the previous section, here is a complete class definition:</p><p><script type="text/javascript">(function(d,l,s,i,c){function n(e){e=e.nextSibling;return (!e||e.nodeType!=3)?e:n(e);};function r(f){/in/.test(d.readyState) ? setTimeout(function(){r(f);},9):f()};l=d.getElementsByTagName('script');s=l[l.length-1];r(function(){i=n(s),c=n(i);i.setAttribute('data-src','https://trinket.io/tools/1.0/jekyll/embed/java#code='+encodeURIComponent(c.nodeValue.replace(/^\s+|\s+$/g,'')));});})(document)</script><iframe width="100%" height="400" frameborder="0" marginwidth="0" marginheight="0" class="lazyload" allowfullscreen=""/><!--
----{PrintTime.java}----
public class PrintTime {

    public static void printTime(int hour, int minute) {
        System.out.print(hour);
        System.out.print(":");
        System.out.println(minute);
    }

    public static void main(String[] args) {
        int hour = 11;
        int minute = 59;
        printTime(hour, minute);
    }
}
--></p><p><code>printTime</code> has two parameters, named <code>hour</code> and <code>minute</code>.
And <code>main</code> has two variables, also named <code>hour</code> and <code>minute</code>.
Although they have the same names, these variables are not the same.
<code>hour</code> in <code>printTime</code> and <code>hour</code> in <code>main</code> refer to different storage locations, and they can have different values.</p><p>For example, you could invoke <code>printTime</code> like this:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">int</span> hour = 11;
<span style="color:blue">int</span> minute = 59;
printTime(hour + 1, 0);</td></tr>
</table><p>Before the method is invoked, Java evaluates the arguments; in this example, the results are <code>12</code> and <code>0</code>.
Then it assigns those values to the parameters.
Inside <code>printTime</code>, the value of <code>hour</code> is <code>12</code>, not <code>11</code>, and the value of <code>minute</code> is <code>0</code>, not <code>59</code>.
Furthermore, if <code>printTime</code> modifies one of its parameters, that change has no effect on the variables in <code>main</code>.</p><p><a name="hevea_default225"></a>
<a name="hevea_default226"></a>
<a name="hevea_default227"></a></p><p>One way to keep track of everything is to draw a <span style="font-weight:bold">stack diagram</span>, which is a state diagram (see Section <a href="/thinkjava/chapter2.html#state">2.3</a>) that shows method invocations.
For each method there is a box called a <span style="font-weight:bold">frame</span> that contains the method’s parameters and variables.
The name of the method appears outside the frame; the variables and parameters appear inside.</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"/></div>
<div class="center">
<img src="thinkjava6008.png"/>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;">Figure 4.1: Stack diagram for <code>PrintTime</code>.</td></tr>
</table></div>
<a name="fig.stack"></a>
</div>
<div class="center"><hr style="width:80%;height:2"/></div></blockquote><p>As with state diagrams, stack diagrams show variables and methods at a particular point in time.
Figure <a href="#fig.stack">4.1</a> is a stack diagram at the beginning of the <code>printTime</code> method.</p>
<h2 name="sec52" class="section">4.8  Reading documentation</h2>
<p>
<a name="sec:apidocs"></a></p><p><a name="hevea_default228"></a></p><p>One of the nice things about Java is that it comes with an extensive library of classes and methods.
But before you use them, you might have to read the documentation.
And sometimes that’s not easy.</p><p>As an example, let’s look at the documentation for <code>Scanner</code>, which we used in Section <a href="/thinkjava/chapter3.html#scanner">3.2</a>.
You can find it by doing a web search for “Java Scanner”.
Figure <a href="#fig.scanner">4.2</a> shows a screenshot of the page.</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></a></div>
<div class="center">
<img src="thinkjava6009.png"/>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;">Figure 4.2: Screenshot of the documentation for <code>Scanner</code>.</td></tr>
</table></div>
<a name="fig.scanner"></a>
</div>
<div class="center"><hr style="width:80%;height:2"/></div></blockquote><p>Documentation for other classes uses a similar format.
The first line is the package that contains the class, such as <code>java.util</code>.
The second line is the name of the class.
The “Implemented Interfaces” section lists some of the things a <code>Scanner</code> can do; we won’t say more about that for now.</p><p>The next section of the documentation is a narrative that explains the purpose of the class and includes examples of how to use it.
This text can be difficult to read because it uses terms we have not learned yet.
But the examples are often very useful.
A good way to get started with a new class is to paste the examples into a test file and see if you can compile and run them.</p><p>One of the examples shows how you can use a <code>Scanner</code> to read input from a <code>String</code> instead of <code>System.in</code>:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">String input = <span style="color:#B20000">"1 fish 2 fish red fish blue fish"</span>;
Scanner s = <span style="color:blue">new</span> Scanner(input);</td></tr>
</table><p>After the narrative, code examples, and some other details, you will find the following tables:</p><dl class="description"><dt class="dt-description"><span style="font-weight:bold">Constructor summary:</span></dt><dd class="dd-description">
Ways of creating, or “constructing”, a <code>Scanner</code>.</dd><dt class="dt-description"><span style="font-weight:bold">Method summary:</span></dt><dd class="dd-description">
The list of methods that <code>Scanner</code> provides.</dd><dt class="dt-description"><span style="font-weight:bold">Constructor detail:</span></dt><dd class="dd-description">
More information about how to create a <code>Scanner</code>.</dd><dt class="dt-description"><span style="font-weight:bold">Method detail:</span></dt><dd class="dd-description">
More information about each method.</dd></dl><p>As an example, here is the summary information for <code>nextInt</code>:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">public int nextInt()
Scans the next token of the input as an int.</td></tr>
</table><p><a name="hevea_default229"></a></p><p>The first line is the method’s <span style="font-weight:bold">signature</span>, which specifies the name of the method, its parameters (none), and what type it returns (<code><span style="color:blue">int</span></code>).
The next line is a short description of what it does.</p><p>The “Method detail” explains more:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">public int nextInt()
Scans the next token of the input as an int.

An invocation of this method of the form nextInt() behaves in
exactly the same way as the invocation nextInt(radix), where
radix is the default radix of this scanner.

Returns:
the int scanned from the input

Throws:
InputMismatchException - if the next token does not match
    the Integer regular expression, or is out of range
NoSuchElementException - if input is exhausted
IllegalStateException - if this scanner is closed</td></tr>
</table><p>The “Returns” section describes the result when the method succeeds.
In contrast, the “Throws” section describes possible errors and their resulting exceptions.
Exceptions are said to be “thrown”, like a referee throwing a flag, or like a toddler throwing a fit.</p><p>It might take you some time to get comfortable reading documentation and learning which parts to ignore.
But it’s worth the effort.
Knowing what’s available in the library helps you avoid reinventing the wheel.
And a little bit of documentation can save you a lot of debugging.</p>
<h2 name="sec53" class="section">4.9  Writing documentation</h2>
<p>
<a name="sec:javadoc"></a></p><p>As you benefit from reading good documentation, you should “pay it forward” by writing good documentation.
A nice feature of the Java language is the ability to embed documentation in your source code.
That way, you can write it as you go, and as things change, it is easier to keep the documentation consistent with the code.</p><p><a name="hevea_default230"></a>
<a name="hevea_default231"></a></p><p>If you include documentation in your source code, you can extract it automatically, and generate well-formatted HTML, using a tool called <span style="font-weight:bold">Javadoc</span>.
This tool is included in standard Java development environments, and it is widely used.
In fact, the online documentation of the Java libraries is generated by Javadoc.</p><p><a name="hevea_default232"></a>
<a name="hevea_default233"></a></p><p>Javadoc scans your source files looking for specially-formatted <span style="font-weight:bold">documentation comments</span>, also known as “Javadoc comments”.
They begin with <span style="color:#007C00"><code>/**</code></span> (two stars) and end with <code>*/</code> (one star).
Anything in between is considered part of the documentation.</p><p>Here’s a class definition with two Javadoc comments, one for the class and one for the <code>main</code> method:</p><p><script type="text/javascript">(function(d,l,s,i,c){function n(e){e=e.nextSibling;return (!e||e.nodeType!=3)?e:n(e);};function r(f){/in/.test(d.readyState) ? setTimeout(function(){r(f);},9):f()};l=d.getElementsByTagName('script');s=l[l.length-1];r(function(){i=n(s),c=n(i);i.setAttribute('data-src','https://trinket.io/tools/1.0/jekyll/embed/java#code='+encodeURIComponent(c.nodeValue.replace(/^\s+|\s+$/g,'')));});})(document)</script><iframe width="100%" height="400" frameborder="0" marginwidth="0" marginheight="0" class="lazyload" allowfullscreen=""/><!--
----{Goodbye.java}----
/**
 * Example program that demonstrates print vs println.
 */
public class Goodbye {

    /**
     * Prints a greeting.
     */
    public static void main(String[] args) {
        System.out.print("Goodbye, ");  // note the space
        System.out.println("cruel world");
    }
}
--></p><p>The class comment explains the purpose of the class.
The method comment explains what the method does.</p><p>Notice that this example also includes an inline comment, beginning with <span style="color:#007C00"><code>//</code></span>.
In general, inline comments are short phrases that help explain complex parts of a program.
They are intended for other programmers reading and maintaining the source code.</p><p>In contrast, Javadoc comments are longer, usually complete sentences.
They explain what each method does, but they omit details about how the method works.
And they are intended for people who will use the methods without looking at the source code.</p><p>Appropriate comments and documentation are essential for making source code readable.
And remember that the person most likely to read your code in the future, and appreciate good documentation, is you.</p>
<h2 name="sec54" class="section">4.10  Vocabulary</h2>
<dl class="description"><dt class="dt-description"><span style="font-weight:bold">argument:</span></dt><dd class="dd-description"><a name="hevea_default234"></a>
A value that you provide when you invoke a method.
This value must have the same type as the corresponding parameter.</dd><dt class="dt-description"><span style="font-weight:bold">invoke:</span></dt><dd class="dd-description"><a name="hevea_default235"></a>
To cause a method to execute.
Also known as “calling” a method.</dd><dt class="dt-description"><span style="font-weight:bold">parameter:</span></dt><dd class="dd-description"><a name="hevea_default236"></a>
A piece of information that a method requires before it can run.
Parameters are variables: they contain values and have types.</dd><dt class="dt-description"><span style="font-weight:bold">flow of execution:</span></dt><dd class="dd-description"><a name="hevea_default237"></a>
The order in which Java executes methods and statements.
It may not necessarily be from top to bottom, left to right.</dd><dt class="dt-description"><span style="font-weight:bold">parameter passing:</span></dt><dd class="dd-description"><a name="hevea_default238"></a>
The process of assigning an argument value to a parameter variable.</dd><dt class="dt-description"><span style="font-weight:bold">local variable:</span></dt><dd class="dd-description"><a name="hevea_default239"></a>
A variable declared inside a method.
Local variables cannot be accessed from outside their method.</dd><dt class="dt-description"><span style="font-weight:bold">stack diagram:</span></dt><dd class="dd-description"><a name="hevea_default240"></a>
A graphical representation of the variables belonging to each method.
The method calls are “stacked” from top to bottom, in the flow of execution.</dd><dt class="dt-description"><span style="font-weight:bold">frame:</span></dt><dd class="dd-description"><a name="hevea_default241"></a>
In a stack diagram, a representation of the variables and parameters for a method, along with their current values.</dd><dt class="dt-description"><span style="font-weight:bold">signature:</span></dt><dd class="dd-description"><a name="hevea_default242"></a>
The first line of a method that defines its name, return type, and parameters.</dd><dt class="dt-description"><span style="font-weight:bold">Javadoc:</span></dt><dd class="dd-description"><a name="hevea_default243"></a>
A tool that reads Java source code and generates documentation in HTML format.</dd><dt class="dt-description"><span style="font-weight:bold">documentation:</span></dt><dd class="dd-description"><a name="hevea_default244"></a>
Comments that describe the technical operation of a class or method.</dd></dl>
<h2 name="sec55" class="section">4.11  Exercises</h2>
<p>The code for this chapter is in the <span style="font-family:monospace">ch04</span> directory of <span style="font-family:monospace">ThinkJavaCode</span>.
See page <a href="/thinkjava/preface.html#code">??</a> for instructions on how to download the repository.
Before you start the exercises, we recommend that you compile and run the examples.</p><p>If you have not already read Appendix <a href="/thinkjava/appendix-a.html#cltesting">A.4</a>, now might be a good time.
It describes an efficient way to test programs that take input from the user and display specific output.</p><div class="theorem"><span style="font-weight:bold">Exercise 1</span>  <p><em>The point of this exercise is to practice reading code and to make sure that you understand the flow of execution through a program with multiple methods.</em></p><ol class="enumerate" type="1"><li class="li-enumerate"><em>What is the output of the following program?
Be precise about where there are spaces and where there are newlines.</em><p>Hint:<em> Start by describing in words what <code>ping</code> and <code>baffle</code> do when they are invoked.</em></p></li><li class="li-enumerate"><em>Draw a stack diagram that shows the state of the program the first time <code>ping</code> is invoked.</em></li><li class="li-enumerate"><em>What happens if you invoke <code>baffle();</code> at the end of the <code>ping</code> method? (We will see why in the next chapter.)</em></li></ol><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><em><span style="color:blue">public static void</span> zoop() {
    baffle();
    System.out.print(<span style="color:#B20000">"You wugga "</span>);
    baffle();
}

<span style="color:blue">public static void</span> main(String[] args) {
    System.out.print(<span style="color:#B20000">"No, I "</span>);
    zoop();
    System.out.print(<span style="color:#B20000">"I "</span>);
    baffle();
}

<span style="color:blue">public static void</span> baffle() {
    System.out.print(<span style="color:#B20000">"wug"</span>);
    ping();
}

<span style="color:blue">public static void</span> ping() {
    System.out.println(<span style="color:#B20000">"."</span>);
}</em></td></tr>
</table></div><div class="theorem"><span style="font-weight:bold">Exercise 2</span>  <p><em>The point of this exercise is to make sure you understand how to write and invoke methods that take parameters.</em></p><ol class="enumerate" type="1"><li class="li-enumerate">
<em>Write the first line of a method named <code>zool</code> that takes three parameters: an <span style="color:blue"><code>int</code></span> and two <code>String</code>s.</em></li><li class="li-enumerate"><em>Write a line of code that calls <code>zool</code>, passing as arguments the value <code>11</code>, the name of your first pet, and the name of the street you grew up on.
</em></li></ol></div><div class="theorem"><span style="font-weight:bold">Exercise 3</span>  <p><em>The purpose of this exercise is to take code from a previous exercise and encapsulate it in a method that takes parameters.
You should start with a working solution to Exercise </em><a href="/thinkjava/chapter2.html#ex%3Adate"><em>2</em></a><em>.</em></p><ol class="enumerate" type="1"><li class="li-enumerate"><em>Write a method called <code>printAmerican</code> that takes the day, date, month and year as parameters and that displays them in American format.</em></li><li class="li-enumerate"><em>Test your method by invoking it from <code>main</code> and passing appropriate arguments.
The output should look something like this (except that the date might be different):</em><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><em>Saturday, July 22, 2015</em></td></tr>
</table></li><li class="li-enumerate"><em>Once you have debugged <code>printAmerican</code>, write another method called <code>printEuropean</code> that displays the date in European format.</em></li></ol></div>
</div>
</div>

</div>

</div>
{% endblock %}

{% block toc %}
<li class="has-dropdown"><a href="/thinkjava/chapter4.html">Void methods</a>
<ul class="dropdown">
<li><a href="/thinkjava/chapter4.html#sec45">Math methods</a>
</li><li><a href="/thinkjava/chapter4.html#sec46">Composition revisited</a>
</li><li><a href="/thinkjava/chapter4.html#sec47">Adding new methods</a>
</li><li><a href="/thinkjava/chapter4.html#sec48">Flow of execution</a>
</li><li><a href="/thinkjava/chapter4.html#sec49">Parameters and arguments</a>
</li><li><a href="/thinkjava/chapter4.html#sec50">Multiple parameters</a>
</li><li><a href="/thinkjava/chapter4.html#sec51">Stack diagrams</a>
</li><li><a href="/thinkjava/chapter4.html#sec52">Reading documentation</a>
</li><li><a href="/thinkjava/chapter4.html#sec53">Writing documentation</a>
</li><li><a href="/thinkjava/chapter4.html#sec54">Vocabulary</a>
</li><li><a href="/thinkjava/chapter4.html#sec55">Exercises</a>
</li></ul>
</li>
{% endblock %}

{% block title%}Void methods | Think Java | Trinket{% endblock %}
