

{% extends 'books/thinkjava/base.html' %}
{% block chaptercontent %}
<div class="row">
<div class="columns small-12">


      <div class="row">
        <div class="columns small-12"><h1 name="sec81" class="chapter">Chapter 7  Loops</h1>
<p>Computers are often used to automate repetitive tasks.
Repeating tasks without making errors is something that computers do well and people do poorly.</p><p><a name="hevea_default354"></a></p><p>Running the same code multiple times is called <span style="font-weight:bold">iteration</span>.
We have seen methods, like <code>countdown</code> and <code>factorial</code>, that use recursion to iterate.
Although recursion is elegant and powerful, it takes some getting used to.
Java provides language features that make iteration much easier:
the <code><span style="color:blue">while</span></code> and <code><span style="color:blue">for</span></code> statements.</p>
<h2 name="sec82" class="section">7.1  The while statement</h2>
<p>
<a name="while"></a></p><p><a name="hevea_default355"></a>
<a name="hevea_default356"></a>
<a name="hevea_default357"></a></p><p>Using a <code><span style="color:blue">while</span></code> statement, we can rewrite <code>countdown</code> like this:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">public static void</span> countdown(<span style="color:blue">int</span> n) {
    <span style="color:blue">while</span> (n &gt; 0) {
        System.out.println(n);
        n = n - 1;
    }
    System.out.println(<span style="color:#B20000">"Blastoff!"</span>);
}</td></tr>
</table><p>You can almost read the <code><span style="color:blue">while</span></code> statement like English:
“While <code>n</code> is greater than zero, print the value of <code>n</code> and then reduce the value of <code>n</code> by 1.
When you get to zero, print Blastoff!”</p><p><a name="hevea_default358"></a></p><p>The expression in parentheses is called the condition.
The statements in braces are called the <span style="font-weight:bold">body</span>.
The flow of execution for a <code><span style="color:blue">while</span></code> statement is:</p><ol class="enumerate" type="1"><li class="li-enumerate">Evaluate the condition, yielding <code><span style="color:blue">true</span></code> or <code><span style="color:blue">false</span></code>.</li><li class="li-enumerate">If the condition is <code><span style="color:blue">false</span></code>, skip the body and go to the next statement.</li><li class="li-enumerate">If the condition is <code><span style="color:blue">true</span></code>, execute the body and go back to step 1.</li></ol><p><a name="hevea_default359"></a></p><p>This type of flow is called a <span style="font-weight:bold">loop</span>, because the last step loops back around to the first.</p><p><a name="hevea_default360"></a>
<a name="hevea_default361"></a></p><p>The body of the loop should change the value of one or more variables so that, eventually, the condition becomes <code><span style="color:blue">false</span></code> and the loop terminates.
Otherwise the loop will repeat forever, which is called an <span style="font-weight:bold">infinite loop</span>.
An endless source of amusement for computer scientists is the observation that the directions on shampoo, “Lather, rinse, repeat,” are an infinite loop.</p><p>In the case of <code>countdown</code>, we can prove that the loop terminates when <code>n</code> is positive.
But in general, it is not so easy to tell whether a loop terminates.
For example, this loop continues until <code>n</code> is 1 (which makes the condition <code><span style="color:blue">false</span></code>):</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">public static void</span> sequence(<span style="color:blue">int</span> n) {
    <span style="color:blue">while</span> (n != 1) {
        System.out.println(n);
        <span style="color:blue">if</span> (n % 2 == 0) {         <span style="color:#007C00">// n is even</span>
            n = n / 2;
        } <span style="color:blue">else</span> {                  <span style="color:#007C00">// n is odd</span>
            n = n * 3 + 1;
        }
    }
}</td></tr>
</table><p>Each time through the loop, the program displays the value of <code>n</code> and then checks whether it is even or odd.
If it is even, the value of <code>n</code> is divided by two.
If it is odd, the value is replaced by 3<span style="font-style:italic">n</span>+1.
For example, if the starting value (the argument passed to <code>sequence</code>) is 3, the resulting sequence is 3, 10, 5, 16, 8, 4, 2, 1.</p><p>Since <code>n</code> sometimes increases and sometimes decreases, there is no obvious proof that <code>n</code> will ever reach 1 and that the program will ever terminate.
For some values of <code>n</code>, we can prove that it terminates.
For example, if the starting value is a power of two, then the value of <code>n</code> will be even every time through the loop until we get to 1.
The previous example ends with such a sequence, starting when <code>n</code> is 16.</p><p>The hard question is whether this program terminates for <em>all</em> values of n.
So far, no one has been able to prove it <em>or</em> disprove it!
For more information, see <a href="https://en.wikipedia.org/wiki/Collatz_conjecture"><span style="font-family:monospace">https://en.wikipedia.org/wiki/Collatz_conjecture</span></a>.
</p>
<h2 name="sec83" class="section">7.2  Generating tables</h2>
<p><a name="hevea_default362"></a>
<a name="hevea_default363"></a></p><p>Loops are good for generating and displaying tabular data.
Before computers were readily available, people had to calculate logarithms, sines and cosines, and other common mathematical functions by hand.
To make that easier, there were books of tables where you could look up values of various functions.
Creating these tables by hand was slow and boring, and the results were often full of errors.</p><p>When computers appeared on the scene, one of the initial reactions was: “This is great!
We can use a computer to generate the tables, so there will be no errors.”
That turned out to be true (mostly), but shortsighted.
Not much later, computers were so pervasive that printed tables became obsolete.</p><p><a name="hevea_default364"></a></p><p>Even so, for some operations, computers use tables of values to get an approximate answer, and then perform computations to improve the approximation.
In some cases, there have been errors in the underlying tables, most famously in the table the original Intel Pentium used to perform floating-point division (see <a href="https://en.wikipedia.org/wiki/Pentium_FDIV_bug"><span style="font-family:monospace">https://en.wikipedia.org/wiki/Pentium_FDIV_bug</span></a>).</p><p>Although a “log table” is not as useful as it once was, it still makes a good example of iteration.
The following loop displays a table with a sequence of values in the left column and their logarithms in the right column:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">int</span> i = 1;
<span style="color:blue">while</span> (i &lt; 10) {
    <span style="color:blue">double</span> x = i;
    System.out.println(x + <span style="color:#B20000">"   "</span> + Math.log(x));
    i = i + 1;
}</td></tr>
</table><p>The output of this program is:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">1.0   0.0
2.0   0.6931471805599453
3.0   1.0986122886681098
4.0   1.3862943611198906
5.0   1.6094379124341003
6.0   1.791759469228055
7.0   1.9459101490553132
8.0   2.0794415416798357
9.0   2.1972245773362196</td></tr>
</table><p><code>Math.log</code> computes natural logarithms, that is, logarithms base <span style="font-style:italic">e</span>.
For computer science applications, we often want logarithms with respect to base 2.
To compute them, we can apply this equation:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">log<sub>2</sub> <span style="font-style:italic">x</span> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">log</span><sub><span style="font-style:italic">e</span></sub> <span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"/></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">log</span><sub><span style="font-style:italic">e</span></sub> 2</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
We can modify the loop as follows:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">int</span> i = 1;
<span style="color:blue">while</span> (i &lt; 10) {
    <span style="color:blue">double</span> x = i;
    System.out.println(x + <span style="color:#B20000">"   "</span> + Math.log(x) / Math.log(2));
    i = i + 1;
}</td></tr>
</table><p>And here are the results:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">1.0   0.0
2.0   1.0
3.0   1.5849625007211563
4.0   2.0
5.0   2.321928094887362
6.0   2.584962500721156
7.0   2.807354922057604
8.0   3.0
9.0   3.1699250014423126</td></tr>
</table><p>Each time through the loop, we add one to <code>x</code>, so the result is an arithmetic sequence.
If we multiply <code>x</code> by something instead, we get a geometric sequence:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">final double</span> LOG2 = Math.log(2);
<span style="color:blue">int</span> i = 1;
<span style="color:blue">while</span> (i &lt; 100) {
    <span style="color:blue">double</span> x = i;
    System.out.println(x + <span style="color:#B20000">"   "</span> + Math.log(x) / LOG2);
    i = i * 2;
}</td></tr>
</table><p><a name="hevea_default365"></a></p><p>The first line stores <code>Math.log(2)</code> in a <code><span style="color:blue">final</span></code> variable to avoid computing that value over and over again.
The last line multiplies <code>x</code> by 2.
The result is:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">1.0   0.0
2.0   1.0
4.0   2.0
8.0   3.0
16.0   4.0
32.0   5.0
64.0   6.0</td></tr>
</table><p>This table shows the powers of two and their logarithms, base 2.
Log tables may not be useful anymore, but for computer scientists, knowing the powers of two helps a lot!
</p>
<h2 name="sec84" class="section">7.3  Encapsulation and generalization</h2>
<p>
<a name="encapsulation"></a></p><p><a name="hevea_default366"></a>
<a name="hevea_default367"></a></p><p>In Section <a href="/thinkjava/chapter6.html#distance">6.2</a>, we presented a way of writing programs called incremental development.
In this section we present another <span style="font-weight:bold">program development</span> process called “encapsulation and generalization”.
The steps are:</p><ol class="enumerate" type="1"><li class="li-enumerate">Write a few lines of code in <code>main</code> or another method, and test them.</li><li class="li-enumerate">When they are working, wrap them in a new method, and test again.</li><li class="li-enumerate">If it’s appropriate, replace literal values with variables and parameters.</li></ol><p><a name="hevea_default368"></a>
<a name="hevea_default369"></a></p><p>The second step is called <span style="font-weight:bold">encapsulation</span>; the third step is <span style="font-weight:bold">generalization</span>.</p><p>To demonstrate this process, we’ll develop methods that display multiplication tables.
Here is a loop that displays the multiples of two, all on one line:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">int</span> i = 1;
<span style="color:blue">while</span> (i &lt;= 6) {
    System.out.printf(<span style="color:#B20000">"%4d"</span>, 2 * i);
    i = i + 1;
}
System.out.println();</td></tr>
</table><p><a name="hevea_default370"></a>
<a name="hevea_default371"></a></p><p>The first line initializes a variable named <code>i</code>, which is going to act as a <span style="font-weight:bold">loop variable</span>: as the loop executes, the value of <code>i</code> increases from 1 to 6; when <code>i</code> is 7, the loop terminates.</p><p>Each time through the loop, we display the value <code>2 * i</code> padded with spaces so it’s four characters wide.
Since we use <code>System.out.printf</code>, the output appears on a single line.</p><p>After the loop, we call <code>println</code> to print a newline and complete the line.
Remember that in some environments, none of the output is displayed until the line is complete.</p><p>The output of the code so far is:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">   2   4   6   8  10  12</td></tr>
</table><p>The next step is to “encapsulate” this code in a new method.
Here’s what it looks like:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">public static void</span> printRow() {
    <span style="color:blue">int</span> i = 1;
    <span style="color:blue">while</span> (i &lt;= 6) {
        System.out.printf(<span style="color:#B20000">"%4d"</span>, 2 * i);
        i = i + 1;
    }
    System.out.println();
}</td></tr>
</table><p><a name="hevea_default372"></a></p><p>Next we replace the constant value, <code>2</code>, with a parameter, <code>n</code>.
This step is called “generalization” because it makes the method more general (less specific).</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">public static void</span> printRow(<span style="color:blue">int</span> n) {
    <span style="color:blue">int</span> i = 1;
    <span style="color:blue">while</span> (i &lt;= 6) {
        System.out.printf(<span style="color:#B20000">"%4d"</span>, n * i);
        i = i + 1;
    }
    System.out.println();
}</td></tr>
</table><p>Invoking this method with the argument 2 yields the same output as before.
With the argument 3, the output is:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">   3   6   9  12  15  18</td></tr>
</table><p>And with argument 4, the output is:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">   4   8  12  16  20  24</td></tr>
</table><p>By now you can probably guess how we are going to display a multiplication table: we’ll invoke <code>printRow</code> repeatedly with different arguments.
In fact, we’ll use another loop to iterate through the rows.</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">int</span> i = 1;
<span style="color:blue">while</span> (i &lt;= 6) {
    printRow(i);
    i = i + 1;
}</td></tr>
</table><p>And the output looks like this:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">   1   2   3   4   5   6
   2   4   6   8  10  12
   3   6   9  12  15  18
   4   8  12  16  20  24
   5  10  15  20  25  30
   6  12  18  24  30  36</td></tr>
</table><p>The format specifier <code>\%4d</code> in <code>printRow</code> causes the output to align vertically, regardless of whether the numbers are one or two digits.</p><p>Finally, we encapsulate the second loop in a method:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">public static void</span> printTable() {
    <span style="color:blue">int</span> i = 1;
    <span style="color:blue">while</span> (i &lt;= 6) {
        printRow(i);
        i = i + 1;
    }
}</td></tr>
</table><p>One of the challenges of programming, especially for beginners, is figuring out how to divide up a program into methods.
The process of encapsulation and generalization allows you to design as you go along.</p>
<h2 name="sec85" class="section">7.4  More generalization</h2>
<p><a name="hevea_default373"></a></p><p>The previous version of <code>printTable</code> always displays six rows.
We can generalize it by replacing the literal <code>6</code> with a parameter:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">public static void</span> printTable(<span style="color:blue">int</span> rows) {
    <span style="color:blue">int</span> i = 1;
    <span style="color:blue">while</span> (i &lt;= rows) {
        printRow(i);
        i = i + 1;
    }
}</td></tr>
</table><p>Here is the output with the argument 7:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">   1   2   3   4   5   6
   2   4   6   8  10  12
   3   6   9  12  15  18
   4   8  12  16  20  24
   5  10  15  20  25  30
   6  12  18  24  30  36
   7  14  21  28  35  42</td></tr>
</table><p>That’s better, but it still has a problem: it always displays the same number of columns.
We can generalize more by adding a parameter to <code>printRow</code>:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">public static void</span> printRow(<span style="color:blue">int</span> n, <span style="color:blue">int</span> cols) {
    <span style="color:blue">int</span> i = 1;
    <span style="color:blue">while</span> (i &lt;= cols) {
        System.out.printf(<span style="color:#B20000">"%4d"</span>, n * i);
        i = i + 1;
    }
    System.out.println();
}</td></tr>
</table><p>Now <code>printRow</code> takes two parameters: <code>n</code> is the value whose multiples should be displayed, and <code>cols</code> is the number of columns.
Since we added a parameter to <code>printRow</code>, we also have to change the line in <code>printTable</code> where it is invoked:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">public static void</span> printTable(<span style="color:blue">int</span> rows) {
    <span style="color:blue">int</span> i = 1;
    <span style="color:blue">while</span> (i &lt;= rows) {
        printRow(i, rows);
        i = i + 1;
    }
}</td></tr>
</table><p>When this line executes, it evaluates <code>rows</code> and passes the value, which is 7 in this example, as an argument.
In <code>printRow</code>, this value is assigned to <code>cols</code>.
As a result, the number of columns equals the number of rows, so we get a square 7x7 table:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">   1   2   3   4   5   6   7
   2   4   6   8  10  12  14
   3   6   9  12  15  18  21
   4   8  12  16  20  24  28
   5  10  15  20  25  30  35
   6  12  18  24  30  36  42
   7  14  21  28  35  42  49</td></tr>
</table><p>When you generalize a method appropriately, you often find that it has capabilities you did not plan.
For example, you might notice that the multiplication table is symmetric; since <span style="font-style:italic">ab</span> = <span style="font-style:italic">ba</span>, all the entries in the table appear twice.
You could save ink by printing half of the table, and you would only have to change one line of <code>printTable</code>:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">printRow(i, i);</td></tr>
</table><p>In words, the length of each row is the same as its row number.
The result is a triangular multiplication table.</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">   1
   2   4
   3   6   9
   4   8  12  16
   5  10  15  20  25
   6  12  18  24  30  36
   7  14  21  28  35  42  49</td></tr>
</table><p>Generalization makes code more versatile, more likely to be reused, and sometimes easier to write.</p>
<h2 name="sec86" class="section">7.5  The for statement</h2>
<p>
<a name="for"></a></p><p><a name="hevea_default374"></a>
<a name="hevea_default375"></a>
<a name="hevea_default376"></a></p><p>The loops we have written so far have several elements in common.
They start by initializing a variable, they have a condition that depends on that variable, and inside the loop they do something to update that variable.
This type of loop is so common that there is another statement, the <code><span style="color:blue">for</span></code> loop, that expresses it more concisely.</p><p>For example, we could rewrite <code>printTable</code> like this:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">public static void</span> printTable(<span style="color:blue">int</span> rows) {
    <span style="color:blue">for</span> (<span style="color:blue">int</span> i = 1; i &lt;= rows; i = i + 1) {
        printRow(i, rows);
    }
}</td></tr>
</table><p><code><span style="color:blue">for</span></code> loops have three components in parentheses, separated by semicolons: the initializer, the condition, and the update.</p><ol class="enumerate" type="1"><li class="li-enumerate">The <em>initializer</em> runs once at the very beginning of the loop.</li><li class="li-enumerate">The <em>condition</em> is checked each time through the loop.
If it is <code><span style="color:blue">false</span></code>, the loop ends.
Otherwise, the body of the loop is executed (again).</li><li class="li-enumerate">At the end of each iteration, the <em>update</em> runs, and we go back to step 2.</li></ol><p>The <code><span style="color:blue">for</span></code> loop is often easier to read because it puts all the loop-related statements at the top of the loop.</p><p>There is one difference between <code><span style="color:blue">for</span></code> loops and <code><span style="color:blue">while</span></code> loops: if you declare a variable in the initializer, it only exists inside the <code><span style="color:blue">for</span></code> loop.
For example, here is a version of <code>printRow</code> that uses a <code><span style="color:blue">for</span></code> loop:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">public static void</span> printRow(<span style="color:blue">int</span> n, <span style="color:blue">int</span> cols) {
    <span style="color:blue">for</span> (<span style="color:blue">int</span> i = 1; i &lt;= cols; i = i + 1) {
        System.out.printf(<span style="color:#B20000">"%4d"</span>, n * i);
    }
    System.out.println(i);  <span style="color:#007C00">// compiler error</span>
}</td></tr>
</table><p>The last line tries to display <code>i</code> (for no reason other than demonstration) but it won’t work.
If you need to use a loop variable outside the loop, you have to declare it outside the loop, like this:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">public static void</span> printRow(<span style="color:blue">int</span> n, <span style="color:blue">int</span> cols) {
    <span style="color:blue">int</span> i;
    <span style="color:blue">for</span> (i = 1; i &lt;= cols; i = i + 1) {
        System.out.printf(<span style="color:#B20000">"%4d"</span>, n * i);
    }
    System.out.println(i);
}</td></tr>
</table><p><a name="hevea_default377"></a>
<a name="hevea_default378"></a></p><p>Assignments like <code>i = i + 1</code> don’t often appear in <code><span style="color:blue">for</span></code> loops, because Java provides a more concise way to add and subtract by one.
Specifically, <code>++</code> is the <span style="font-weight:bold">increment</span> operator; it has the same effect as <code>i = i + 1</code>.
And <code>--</code> is the <span style="font-weight:bold">decrement</span> operator; it has the same effect as <code>i = i - 1</code>.</p><p>If you want to increment or decrement a variable by an amount other than <code>1</code>, you can use <code>+=</code> and <code>-=</code>.
For example, <code>i += 2</code> increments <code>i</code> by <code>2</code>.</p>
<h2 name="sec87" class="section">7.6  The do-while loop</h2>
<p><a name="hevea_default379"></a></p><p>The <code><span style="color:blue">while</span></code> and <code><span style="color:blue">for</span></code> statements are <span style="font-weight:bold">pretest loops</span>; that is, they test the condition first and at the beginning of each pass through the loop.</p><p><a name="hevea_default380"></a>
<a name="hevea_default381"></a></p><p>Java also provides a <span style="font-weight:bold">posttest loop</span>: the <code><span style="color:blue">do</span></code>-<code><span style="color:blue">while</span></code> statement.
This type of loop is useful when you need to run the body of the loop at least once.</p><p>For example, in Section <a href="/thinkjava/chapter5.html#validate">5.7</a> we used the <code><span style="color:blue">return</span></code> statement to avoid reading invalid input from the user.
We can use a <code><span style="color:blue">do</span></code>-<code><span style="color:blue">while</span></code> loop to keep reading input until it’s valid:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">Scanner in = <span style="color:blue">new</span> Scanner(System.in);
<span style="color:blue">boolean</span> okay;
<span style="color:blue">do</span> {
    System.out.print(<span style="color:#B20000">"Enter a number: "</span>);
    <span style="color:blue">if</span> (in.hasNextDouble()) {
        okay = <span style="color:blue">true</span>;
    } <span style="color:blue">else</span> {
        okay = <span style="color:blue">false</span>;
        String word = in.next();
        System.err.println(word + <span style="color:#B20000">" is not a number"</span>);
    }
} <span style="color:blue">while</span> (!okay);
<span style="color:blue">double</span> x = in.nextDouble();</td></tr>
</table><p>Although this code looks complicated, it is essentially only three steps:</p><ol class="enumerate" type="1"><li class="li-enumerate">
Display a prompt.
</li><li class="li-enumerate">Check the input; if invalid, display an error and start over.
</li><li class="li-enumerate">Read the input.
</li></ol><p><a name="hevea_default382"></a></p><p>The code uses a flag variable, <code>okay</code>, to indicate whether we need to repeat the loop body.
If <code>hasNextDouble()</code> returns <code><span style="color:blue">false</span></code>, we consume the invalid input by calling <code>next()</code>.
We then display an error message via <code>System.err</code>.
The loop terminates when <code>hasNextDouble()</code> return <code><span style="color:blue">true</span></code>.</p>
<h2 name="sec88" class="section">7.7  Break and continue</h2>
<p>Sometimes neither a pretest nor a posttest loop will provide exactly what you need.
In the previous example, the “test” needed to happen in the middle of the loop.
As a result, we used a flag variable and a nested <code><span style="color:blue">if</span></code>-<code><span style="color:blue">else</span></code> statement.</p><p><a name="hevea_default383"></a></p><p>A simpler way to solve this problem is to use a <code><span style="color:blue">break</span></code> statement.
When a program reaches a <code><span style="color:blue">break</span></code> statement, it exits the current loop.</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">Scanner in = <span style="color:blue">new</span> Scanner(System.in);
<span style="color:blue">while</span> (<span style="color:blue">true</span>) {
    System.out.print(<span style="color:#B20000">"Enter a number: "</span>);
    <span style="color:blue">if</span> (in.hasNextDouble()) {
        <span style="color:blue">break</span>;
    }
    String word = in.next();
    System.err.println(word + <span style="color:#B20000">" is not a number"</span>);
}
<span style="color:blue">double</span> x = in.nextDouble();</td></tr>
</table><p>Using <code><span style="color:blue">true</span></code> as a conditional in a <code><span style="color:blue">while</span></code> loop is an idiom that means “loop forever”, or in this case “loop until you get to a <code><span style="color:blue">break</span></code> statement.”</p><p><a name="hevea_default384"></a></p><p>In addition to the <code><span style="color:blue">break</span></code> statement, which exits the loop, Java provides a <code><span style="color:blue">continue</span></code> statement that moves on to the next iteration.
For example, the following code reads integers from the keyboard and computes a running total.
The <code><span style="color:blue">continue</span></code> statement causes the program to skip over any negative values.</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">Scanner in = <span style="color:blue">new</span> Scanner(System.in);
<span style="color:blue">int</span> x = -1;
<span style="color:blue">int</span> sum = 0;
<span style="color:blue">while</span> (x != 0) {
    x = in.nextInt();
    <span style="color:blue">if</span> (x &lt;= 0) {
        <span style="color:blue">continue</span>;
    }
    System.out.println(<span style="color:#B20000">"Adding "</span> + x);
    sum += x;
}</td></tr>
</table><p>Although <code><span style="color:blue">break</span></code> and <code><span style="color:blue">continue</span></code> statements give you more control of the loop execution, they can make code difficult to understand and debug.
Use them sparingly.</p>
<h2 name="sec89" class="section">7.8  Vocabulary</h2>
<dl class="description"><dt class="dt-description"><span style="font-weight:bold">iteration:</span></dt><dd class="dd-description"><a name="hevea_default385"></a>
Executing a sequence of statements repeatedly.</dd><dt class="dt-description"><span style="font-weight:bold">loop:</span></dt><dd class="dd-description"><a name="hevea_default386"></a>
A statement that executes a sequence of statements repeatedly.</dd><dt class="dt-description"><span style="font-weight:bold">loop body:</span></dt><dd class="dd-description"><a name="hevea_default387"></a>
The statements inside the loop.</dd><dt class="dt-description"><span style="font-weight:bold">infinite loop:</span></dt><dd class="dd-description"><a name="hevea_default388"></a>
A loop whose condition is always true.</dd><dt class="dt-description"><span style="font-weight:bold">program development:</span></dt><dd class="dd-description"><a name="hevea_default389"></a>
A process for writing programs.
So far we have seen “incremental development” and “encapsulation and generalization”.</dd><dt class="dt-description"><span style="font-weight:bold">encapsulate:</span></dt><dd class="dd-description"><a name="hevea_default390"></a>
To wrap a sequence of statements in a method.</dd><dt class="dt-description"><span style="font-weight:bold">generalize:</span></dt><dd class="dd-description"><a name="hevea_default391"></a>
To replace something unnecessarily specific (like a constant value) with something appropriately general (like a variable or parameter).</dd><dt class="dt-description"><span style="font-weight:bold">loop variable:</span></dt><dd class="dd-description"><a name="hevea_default392"></a>
A variable that is initialized, tested, and updated in order to control a loop.</dd><dt class="dt-description"><span style="font-weight:bold">increment:</span></dt><dd class="dd-description"><a name="hevea_default393"></a>
Increase the value of a variable.</dd><dt class="dt-description"><span style="font-weight:bold">decrement:</span></dt><dd class="dd-description"><a name="hevea_default394"></a>
Decrease the value of a variable.</dd><dt class="dt-description"><span style="font-weight:bold">pretest loop:</span></dt><dd class="dd-description"><a name="hevea_default395"></a>
A loop that tests the condition before each iteration.</dd><dt class="dt-description"><span style="font-weight:bold">posttest loop:</span></dt><dd class="dd-description"><a name="hevea_default396"></a>
A loop that tests the condition after each iteration.</dd></dl>
<h2 name="sec90" class="section">7.9  Exercises</h2>
<p>The code for this chapter is in the <span style="font-family:monospace">ch07</span> directory of <span style="font-family:monospace">ThinkJavaCode</span>.
See page <a href="/thinkjava/preface.html#code">??</a> for instructions on how to download the repository.
Before you start the exercises, we recommend that you compile and run the examples.</p><p>If you have not already read Appendix <a href="/thinkjava/appendix-a.html#checkstyle">A.5</a>, now might be a good time.
It describes Checkstyle, a tool that analyzes many aspects of your source code.</p><div class="theorem"><span style="font-weight:bold">Exercise 1</span>  <p><em>Consider the following methods:</em></p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><em><span style="color:blue">public static void</span> main(String[] args) {
    loop(10);
}

<span style="color:blue">public static void</span> loop(<span style="color:blue">int</span> n) {
    <span style="color:blue">int</span> i = n;
    <span style="color:blue">while</span> (i &gt; 1) {
        System.out.println(i);
        <span style="color:blue">if</span> (i % 2 == 0) {
            i = i / 2;
        } <span style="color:blue">else</span> {
            i = i + 1;
        }
    }
}</em></td></tr>
</table><ol class="enumerate" type="1"><li class="li-enumerate"><em>Draw a table that shows the value of the variables <code>i</code> and <code>n</code> during the execution of <code>loop</code>.
The table should contain one column for each variable and one line for each iteration.</em></li><li class="li-enumerate"><em>What is the output of this program?</em></li><li class="li-enumerate"><em>Can you prove that this loop terminates for any positive value of <code>n</code>?</em></li></ol></div><div class="theorem"><span style="font-weight:bold">Exercise 2</span>  <p><em>Let’s say you are given a number, </em><span style="font-style:italic">a</span><em>, and you want to find its square root.
One way to do that is to start with a rough guess about the answer, </em><span style="font-style:italic">x</span><sub>0</sub><em>, and then improve the guess using this formula:
</em></p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span><sub>1</sub> =(<span style="font-style:italic">x</span><sub>0</sub> + <span style="font-style:italic">a</span>/<span style="font-style:italic">x</span><sub>0</sub>) / 2 </td></tr>
</table><p><em>
For example, if we want to find the square root of 9, and we start with </em><span style="font-style:italic">x</span><sub>0</sub> = 6<em>, then </em><span style="font-style:italic">x</span><sub>1</sub> = (6 + 9/6) / 2 = 3.75<em>, which is closer.
We can repeat the procedure, using </em><span style="font-style:italic">x</span><sub>1</sub><em> to calculate </em><span style="font-style:italic">x</span><sub>2</sub><em>, and so on.
In this case, </em><span style="font-style:italic">x</span><sub>2</sub> = 3.075<em> and </em><span style="font-style:italic">x</span><sub>3</sub> = 3.00091<em>.
So it converges quickly on the correct answer.</em></p><p><em>Write a method called <code>squareRoot</code> that takes a <span style="color:blue"><code>double</code></span> and returns an approximation of the square root of the parameter, using this technique.
You should not use <code>Math.sqrt</code>.</em></p><p><em>As your initial guess, you should use </em><span style="font-style:italic">a</span>/2<em>.
Your method should iterate until it gets two consecutive estimates that differ by less than 0.0001.
You can use <code>Math.abs</code> to calculate the absolute value of the difference.</em></p></div><div class="theorem"><span style="font-weight:bold">Exercise 3</span>  <p><em>In Exercise </em><a href="/thinkjava/chapter6.html#ex.power"><em>9</em></a><em> we wrote a recursive version of <code>power</code>, which takes a double <code>x</code> and an integer <code>n</code> and returns </em><span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span></sup><em>.
Now write an iterative method to perform the same calculation.</em></p></div><div class="theorem"><span style="font-weight:bold">Exercise 4</span>  <p><em>Section </em><a href="/thinkjava/chapter6.html#factorial"><em>6.7</em></a><em> presents a recursive method that computes the factorial function.
Write an iterative version of <code>factorial</code>.</em></p></div><div class="theorem"><span style="font-weight:bold">Exercise 5</span>  <p><em>One way to calculate </em><span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span></sup><em> is to use the infinite series expansion:
</em></p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span></sup> = 1 + <span style="font-style:italic">x</span> + <span style="font-style:italic">x</span><sup>2</sup> / 2! + <span style="font-style:italic">x</span><sup>3</sup> / 3! + <span style="font-style:italic">x</span><sup>4</sup> / 4! + … </td></tr>
</table><p><em>
The </em><span style="font-style:italic">i</span><em>th term in the series is </em><span style="font-style:italic">x</span><sup><span style="font-style:italic">i</span></sup> / <span style="font-style:italic">i</span>!<em>.</em></p><ol class="enumerate" type="1"><li class="li-enumerate"><em>Write a method called <code>myexp</code> that takes <code>x</code> and <code>n</code> as parameters and estimates </em><span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span></sup><em> by adding the first <code>n</code> terms of this series.
You can use the <code>factorial</code> method from Section </em><a href="/thinkjava/chapter6.html#factorial"><em>6.7</em></a><em> or your iterative version from the previous exercise.</em><p><a name="hevea_default397"></a></p></li><li class="li-enumerate"><em>You can make this method more efficient if you realize that the numerator of each term is the same as its predecessor multiplied by <code>x</code>, and the denominator is the same as its predecessor multiplied by <code>i</code>.
Use this observation to eliminate the use of <code>Math.pow</code> and <code>factorial</code>, and check that you get the same result.</em></li><li class="li-enumerate"><em>Write a method called <code>check</code> that takes a parameter, <code>x</code>, and displays <code>x</code>, <code>myexp(x)</code>, and <code>Math.exp(x)</code>.
The output should look something like:</em><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><em>1.0     2.708333333333333     2.718281828459045</em></td></tr>
</table><p><em>You can use the escape sequence <span style="color:#B20000"><code>"\t"</code></span> to put a tab character between columns of a table.</em></p></li><li class="li-enumerate"><em>Vary the number of terms in the series (the second argument that <code>check</code> sends to <code>myexp</code>) and see the effect on the accuracy of the result.
Adjust this value until the estimated value agrees with the correct answer when <code>x</code> is 1.</em></li><li class="li-enumerate"><em>Write a loop in <code>main</code> that invokes <code>check</code> with the values 0.1, 1.0, 10.0, and 100.0.
How does the accuracy of the result vary as <code>x</code> varies?
Compare the number of digits of agreement rather than the difference between the actual and estimated values.</em></li><li class="li-enumerate"><em>Add a loop in <code>main</code> that checks <code>myexp</code> with the values -0.1, -1.0, -10.0, and -100.0.
Comment on the accuracy.</em></li></ol></div><div class="theorem"><span style="font-weight:bold">Exercise 6</span>  <p><em>One way to evaluate </em>exp(−<span style="font-style:italic">x</span><sup>2</sup>)<em> is to use the infinite series expansion:
</em></p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">exp(−<span style="font-style:italic">x</span><sup>2</sup>) = 1 − <span style="font-style:italic">x</span><sup>2</sup> + <span style="font-style:italic">x</span><sup>4</sup>/2 − <span style="font-style:italic">x</span><sup>6</sup>/6 + … </td></tr>
</table><p><em>
The </em><span style="font-style:italic">i</span><em>th term in this series is </em>(−1)<sup><span style="font-style:italic">i</span></sup> <span style="font-style:italic">x</span><sup>2<span style="font-style:italic">i</span></sup> / <span style="font-style:italic">i</span>!<em>.
Write a method named <code>gauss</code> that takes <code>x</code> and <code>n</code> as arguments and returns the sum of the first <code>n</code> terms of the series.
You should not use <code>factorial</code> or <code>pow</code>.</em></p></div>
</div>
</div>

</div>

</div>
{% endblock %}

{% block toc %}
<li class="has-dropdown"><a href="/thinkjava/chapter7.html">Loops</a>
<ul class="dropdown">
<li><a href="/thinkjava/chapter7.html#sec82">The while statement</a>
</li><li><a href="/thinkjava/chapter7.html#sec83">Generating tables</a>
</li><li><a href="/thinkjava/chapter7.html#sec84">Encapsulation and generalization</a>
</li><li><a href="/thinkjava/chapter7.html#sec85">More generalization</a>
</li><li><a href="/thinkjava/chapter7.html#sec86">The for statement</a>
</li><li><a href="/thinkjava/chapter7.html#sec87">The do-while loop</a>
</li><li><a href="/thinkjava/chapter7.html#sec88">Break and continue</a>
</li><li><a href="/thinkjava/chapter7.html#sec89">Vocabulary</a>
</li><li><a href="/thinkjava/chapter7.html#sec90">Exercises</a>
</li></ul>
</li>
{% endblock %}

{% block title%}Loops | Think Java | Trinket{% endblock %}
