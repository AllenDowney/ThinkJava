

{% extends 'books/thinkjava/base.html' %}
{% block chaptercontent %}
<div class="row">
<div class="columns small-12">


      <div class="row">
        <div class="columns small-12"><h1 name="sec91" class="chapter">Chapter 8  Arrays</h1>
<p>
<a name="arrays"></a></p><p>Up to this point, the only variables we have used were for individual values such as numbers or strings.
In this chapter, we’ll learn how to store multiple values of the same type using a single variable.
This language feature will enable you to write programs that manipulate larger amounts of data.</p>
<h2 name="sec92" class="section">8.1  Creating arrays</h2>
<p><a name="hevea_default398"></a>
<a name="hevea_default399"></a></p><p>An <span style="font-weight:bold">array</span> is a sequence of values; the values in the array are called <span style="font-weight:bold">elements</span>.
You can make an array of <code><span style="color:blue">int</span></code>s, <code><span style="color:blue">double</span></code>s, or any other type, but all the values in an array must have the same type.</p><p><a name="hevea_default400"></a></p><p>To create an array, you have to declare a variable with an <em>array type</em> and then create the array itself.
Array types look like other Java types, except they are followed by square brackets (<code>[]</code>).
For example, the following lines declare that <code>counts</code> is an “integer array” and <code>values</code> is a “double array”:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">int</span>[] counts;
<span style="color:blue">double</span>[] values;</td></tr>
</table><p><a name="hevea_default401"></a>
<a name="hevea_default402"></a></p><p>To create the array itself, you have to use the <code><span style="color:blue">new</span></code> operator, which we first saw in Section <a href="/thinkjava/chapter3.html#scanner">3.2</a>:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">counts = <span style="color:blue">new int</span>[4];
values = <span style="color:blue">new double</span>[size];</td></tr>
</table><p>The first assignment makes <code>count</code> refer to an array of four integers.
The second makes <code>values</code> refer to an array of <code><span style="color:blue">double</span></code>, where the number of elements in <code>values</code> depends on the value of <code>size</code>.</p><p>Of course, you can also declare the variable and create the array in a single line of code:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">int</span>[] counts = <span style="color:blue">new int</span>[4];
<span style="color:blue">double</span>[] values = <span style="color:blue">new double</span>[size];</td></tr>
</table><p><a name="hevea_default403"></a>
<a name="hevea_default404"></a></p><p>You can use any integer expression for the size of an array, as long as the value is nonnegative.
If you try to create an array with −4 elements, for example, you will get a <code>NegativeArraySizeException</code>.
An array with zero elements is allowed, and there are special uses for such arrays that we’ll see later on.</p>
<h2 name="sec93" class="section">8.2  Accessing elements</h2>
<p>
<a name="elements"></a></p><p><a name="hevea_default405"></a>
<a name="hevea_default406"></a></p><p>When you create an array of <code><span style="color:blue">int</span></code>s, the elements are initialized to zero.
Figure <a href="#fig.array">8.1</a> shows a state diagram of the <code>counts</code> array so far.</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></a></div>
<div class="center">
<img src="thinkjava6013.png"/>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;">Figure 8.1: State diagram of an <code><span style="color:blue">int</span></code> array.</td></tr>
</table></div>
<a name="fig.array"></a>
</div>
<div class="center"><hr style="width:80%;height:2"/></div></blockquote><p><a name="hevea_default407"></a></p><p>The arrow indicates that the value of <code>counts</code> is a <span style="font-weight:bold">reference</span> to the array.
You should think of <em>the array</em> and <em>the variable</em> that refers to it as two different things.
As we’ll soon see, we can assign a different variable to refer to the same array, and we can change the value of <code>counts</code> to refer to a different array.</p><p><a name="hevea_default408"></a>
<a name="hevea_default409"></a>
<a name="hevea_default410"></a>
<a name="hevea_default411"></a></p><p>The large numbers inside the boxes are the elements of the array.
The small numbers outside the boxes are the <span style="font-weight:bold">indexes</span> (or indices) used to identify each location in the array.
Notice that the index of the first element is 0, not 1, as you might have expected.</p><p>The <code>[]</code> operator selects elements from an array:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">System.out.println(<span style="color:#B20000">"The zeroth element is "</span> + counts[0]);</td></tr>
</table><p>You can use the <code>[]</code> operator anywhere in an expression:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">counts[0] = 7;
counts[1] = counts[0] * 2;
counts[2]++;
counts[3] -= 60;</td></tr>
</table><p>Figure <a href="#fig.array2">8.2</a> shows the result of these statements.</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></a></div>
<div class="center">
<img src="thinkjava6014.png"/>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;">Figure 8.2: State diagram after several assignment statements.</td></tr>
</table></div>
<a name="fig.array2"></a>
</div>
<div class="center"><hr style="width:80%;height:2"/></div></blockquote><p>You can use any expression as an index, as long as it has type <code><span style="color:blue">int</span></code>.
One of the most common ways to index an array is with a loop variable.
For example:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">int</span> i = 0;
<span style="color:blue">while</span> (i &lt; 4) {
    System.out.println(counts[i]);
    i++;
}</td></tr>
</table><p>This <code><span style="color:blue">while</span></code> loop counts from 0 up to 4.
When <code>i</code> is 4, the condition fails and the loop terminates.
So the body of the loop is only executed when <code>i</code> is 0, 1, 2, and 3.</p><p><a name="hevea_default412"></a>
<a name="hevea_default413"></a></p><p>Each time through the loop we use <code>i</code> as an index into the array, displaying the <code>i</code>th element.
This type of array processing is often written using a <code><span style="color:blue">for</span></code> loop.</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">for</span> (<span style="color:blue">int</span> i = 0; i &lt; 4; i++) {
    System.out.println(counts[i]);
}</td></tr>
</table><p><a name="hevea_default414"></a>
<a name="hevea_default415"></a></p><p>For the <code>counts</code> array, the only legal indexes are 0, 1, 2, and 3.
If the index is negative or greater than 3, the result is an <code>ArrayIndexOutOfBoundsException</code>.</p>
<h2 name="sec94" class="section">8.3  Displaying arrays</h2>
<p>
<a name="printarray"></a></p><p>You can use <code>println</code> to display an array, but it probably doesn’t do what you would like.
For example, the following fragment (1) declares an array variable, (2) makes it refer to an array of four elements, and (3) attempts to display the contents of the array using <code>println</code>:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">int</span>[] a = {1, 2, 3, 4};
System.out.println(a);</td></tr>
</table><p>Unfortunately, the output is something like:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">[I@bf3f7e0</td></tr>
</table><p>The bracket indicates that the value is an array, <code>I</code> stands for “integer”, and the rest represents the address of the array.
If we want to display the elements of the array, we can do it ourselves:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">public static void</span> printArray(<span style="color:blue">int</span>[] a) {
    System.out.print(<span style="color:#B20000">"{"</span> + a[0]);
    <span style="color:blue">for</span> (<span style="color:blue">int</span> i = 1; i &lt; a.length; i++) {
        System.out.print(<span style="color:#B20000">", "</span> + a[i]);
    }
    System.out.println(<span style="color:#B20000">"}"</span>);
}</td></tr>
</table><p>Given the previous array, the output of this method is:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">{1, 2, 3, 4}</td></tr>
</table><p><a name="hevea_default416"></a>
<a name="hevea_default417"></a></p><p>The Java library provides a utility class <code>java.util.Arrays</code> that provides methods for working with arrays.
One of them, <code>toString</code>, returns a string representation of an array.
We can invoke it like this:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">System.out.println(Arrays.toString(a));</td></tr>
</table><p>And the output is:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">[1, 2, 3, 4]</td></tr>
</table><p>As usual, we have to import <code>java.util.Arrays</code> before we can use it.
Notice that the string format is slightly different: it uses square brackets instead of curly braces.
But it beats having to write the <code>printArray</code> method.</p>
<h2 name="sec95" class="section">8.4  Copying arrays</h2>
<p>
<a name="copyarray"></a></p><p><a name="hevea_default418"></a></p><p>As explained in Section <a href="#elements">8.2</a>, array variables contain <em>references</em> to arrays.
When you make an assignment to an array variable, it simply copies the reference.
But it doesn’t copy the array itself!
For example:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">double</span>[] a = <span style="color:blue">new double</span>[3];
<span style="color:blue">double</span>[] b = a;</td></tr>
</table><p>These statements create an array of three <code><span style="color:blue">double</span></code>s and make two different variables refer to it, as shown in Figure <a href="#fig.array3">8.3</a>.</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></a></div>
<div class="center">
<img src="thinkjava6015.png"/>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;">Figure 8.3: State diagram showing two variables that refer to the same array.</td></tr>
</table></div>
<a name="fig.array3"></a>
</div>
<div class="center"><hr style="width:80%;height:2"/></div></blockquote><p><a name="hevea_default419"></a></p><p>Any changes made through either variable will be seen by the other.
For example, if we set <code>a[0] = 17.0</code>, and then display <code>b[0]</code>, the result is <span style="font-family:monospace">17.0</span>.
Because <code>a</code> and <code>b</code> are different names for the same thing, they are sometimes called <span style="font-weight:bold">aliases</span>.</p><p>If you actually want to copy the array, not just a reference, you have to create a new array and copy the elements from the old to the new, like this:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">double</span>[] b = <span style="color:blue">new double</span>[3];
<span style="color:blue">for</span> (<span style="color:blue">int</span> i = 0; i &lt; 3; i++) {
    b[i] = a[i];
}</td></tr>
</table><p><a name="hevea_default420"></a></p><p>Another option is to use <code>java.util.Arrays</code>, which provides a method named <code>copyOf</code> that copies an array.
You can invoke it like this:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">double</span>[] b = Arrays.copyOf(a, 3);</td></tr>
</table><p>The second parameter is the number of elements you want to copy, so you can also use <code>copyOf</code> to copy just part of an array.</p>
<h2 name="sec96" class="section">8.5  Array length</h2>
<p><a name="hevea_default421"></a>
<a name="hevea_default422"></a></p><p>The examples in the previous section only work if the array has three elements.
It would be better to generalize the code to work with arrays of any size.
We can do that by replacing the magic number, <code>3</code>, with <code>a.length</code>:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">double</span>[] b = <span style="color:blue">new double</span>[a.length];
<span style="color:blue">for</span> (<span style="color:blue">int</span> i = 0; i &lt; a.length; i++) {
    b[i] = a[i];
}</td></tr>
</table><p>All arrays have a built-in constant, <code>length</code>, that stores the number of elements.
The expression <code>a.length</code> may look like a method invocation, but there are no parentheses and no arguments.
</p><p>The last time this loop gets executed, <code>i</code> is <code>a.length - 1</code>, which is the index of the last element.
When <code>i</code> is equal to <code>a.length</code>, the condition fails and the body is not executed – which is a good thing, because trying to access <code>a[a.length]</code> would throw an exception.</p><p>You can also use <code>a.length</code> with <code>Arrays.copyOf</code>:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">double</span>[] b = Arrays.copyOf(a, a.length);</td></tr>
</table>
<h2 name="sec97" class="section">8.6  Array traversal</h2>
<p>
<a name="traversal"></a></p><p>Many computations can be implemented by looping through the elements of an array and performing an operation on each element.
For example, the following loop squares the elements of a <code><span style="color:blue">double</span></code> array:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">for</span> (<span style="color:blue">int</span> i = 0; i &lt; a.length; i++) {
    a[i] = Math.pow(a[i], 2.0);
}</td></tr>
</table><p><a name="hevea_default423"></a>
<a name="hevea_default424"></a></p><p>Looping through the elements of an array is called a <span style="font-weight:bold">traversal</span>.
Another common pattern is a <span style="font-weight:bold">search</span>, which involves traversing an array looking for a particular element.
For example, the following method takes an <code><span style="color:blue">int</span></code> array and an integer value, and it returns the index where the value appears:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">public static int</span> search(<span style="color:blue">double</span>[] a, <span style="color:blue">double</span> target) {
    <span style="color:blue">for</span> (<span style="color:blue">int</span> i = 0; i &lt; a.length; i++) {
        <span style="color:blue">if</span> (a[i] == target) {
            <span style="color:blue">return</span> i;
        }
    }
    <span style="color:blue">return</span> -1;
}</td></tr>
</table><p>If we find the target value in the array, we return its index immediately.
If the loop exits without finding the target, it returns <code>-1</code>, a special value chosen to indicate a failed search.</p><p><a name="hevea_default425"></a></p><p>Another common traversal is a <span style="font-weight:bold">reduce</span> operation, which “reduces” an array of values down to a single value.
Examples include the sum or product of the elements, the minimum, and the maximum.
The following method takes a <code><span style="color:blue">double</span></code> array and returns the sum of the elements:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">public static double</span> sum(<span style="color:blue">double</span>[] a) {
    <span style="color:blue">double</span> total = 0.0;
    <span style="color:blue">for</span> (<span style="color:blue">int</span> i = 0; i &lt; a.length; i++) {
        total += a[i];
    }
    <span style="color:blue">return</span> total;
}</td></tr>
</table><p><a name="hevea_default426"></a></p><p>Before the loop, we initialize <code>total</code> to zero.
Each time through the loop, we update <code>total</code> by adding one element from the array.
At the end of the loop, <code>total</code> contains the sum of the elements.
A variable used this way is sometimes called an <span style="font-weight:bold">accumulator</span>.</p>
<h2 name="sec98" class="section">8.7  Random numbers</h2>
<p>
<a name="random"></a></p><p><a name="hevea_default427"></a></p><p>Most computer programs do the same thing every time they run; programs like that are <span style="font-weight:bold">deterministic</span>.
Usually determinism is a good thing, since we expect the same calculation to yield the same result.
But for some applications, we want the computer to be unpredictable.
Games are an obvious example, but there are many others.</p><p><a name="hevea_default428"></a>
<a name="hevea_default429"></a></p><p>Making a program <span style="font-weight:bold">nondeterministic</span> turns out to be hard, because it’s hard for a computer to generate truly random numbers.
But there are algorithms that generate unpredictable sequences called <span style="font-weight:bold">pseudorandom</span> numbers.
For most applications, they are as good as random.</p><p><a name="hevea_default430"></a>
<a name="hevea_default431"></a></p><p>If you did Exercise <a href="/thinkjava/chapter3.html#guess">4</a>, you have already seen <code>java.util.Random</code>, which generates pseudorandom numbers.
The method <code>nextInt</code> takes an integer argument, <code>n</code>, and returns a random integer between <code>0</code> and <code>n - 1</code> (inclusive).</p><p>If you generate a long series of random numbers, every value should appear, at least approximately, the same number of times.
One way to test this behavior of <code>nextInt</code> is to generate a large number of values, store them in an array, and count the number of times each value occurs.</p><p>The following method creates an <code><span style="color:blue">int</span></code> array and fills it with random numbers between 0 and 99.
The argument specifies the size of the array, and the return value is a reference to the new array.</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">public static int</span>[] randomArray(<span style="color:blue">int</span> size) {
    Random random = <span style="color:blue">new</span> Random();
    <span style="color:blue">int</span>[] a = <span style="color:blue">new int</span>[size];
    <span style="color:blue">for</span> (<span style="color:blue">int</span> i = 0; i &lt; a.length; i++) {
        a[i] = random.nextInt(100);
    }
    <span style="color:blue">return</span> a;
}</td></tr>
</table><p>The following fragment generates an array and displays it using <code>printArray</code> from Section <a href="#printarray">8.3</a>:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">int</span> numValues = 8;
<span style="color:blue">int</span>[] array = randomArray(numValues);
printArray(array);</td></tr>
</table><p>The output looks like this:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">{15, 62, 46, 74, 67, 52, 51, 10}</td></tr>
</table><p>If you run it, you will probably get different values.</p>
<h2 name="sec99" class="section">8.8  Traverse and count</h2>
<p><a name="hevea_default432"></a>
<a name="hevea_default433"></a></p><p>If these values were exam scores – and they would be pretty bad exam scores – the teacher might present them to the class in the form of a <span style="font-weight:bold">histogram</span>.
In statistics, a histogram is a set of counters that keeps track of the number of times each value appears.</p><p>For exam scores, we might have ten counters to keep track of how many students scored in the 90s, the 80s, etc.
To do that, we can traverse the array and count the number of elements that fall in a given range.</p><p>The following method takes an array and two integers, <code>low</code> and <code>high</code>.
It returns the number of elements that fall in the range from <code>low</code> to <code>high</code>.</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">public static int</span> inRange(<span style="color:blue">int</span>[] a, <span style="color:blue">int</span> low, <span style="color:blue">int</span> high) {
    <span style="color:blue">int</span> count = 0;
    <span style="color:blue">for</span> (<span style="color:blue">int</span> i = 0; i &lt; a.length; i++) {
        <span style="color:blue">if</span> (a[i] &gt;= low &amp;&amp; a[i] &lt; high) {
            count++;
        }
    }
    <span style="color:blue">return</span> count;
}</td></tr>
</table><p><a name="hevea_default434"></a></p><p>This pattern should look familiar: it is another reduce operation.
Notice that <code>low</code> is included in the range (<code>&gt;=</code>), but <code>high</code> is excluded (<code>&lt;</code>).
This detail keeps us from counting any scores twice.</p><p>Now we can count the number of scores in each grade range:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">int</span>[] scores = randomArray(30);
<span style="color:blue">int</span> a = inRange(scores, 90, 100);
<span style="color:blue">int</span> b = inRange(scores, 80, 90);
<span style="color:blue">int</span> c = inRange(scores, 70, 80);
<span style="color:blue">int</span> d = inRange(scores, 60, 70);
<span style="color:blue">int</span> f = inRange(scores, 0, 60);</td></tr>
</table>
<h2 name="sec100" class="section">8.9  Building a histogram</h2>
<p>The previous code is repetitious, but it is acceptable as long as the number of ranges is small.
But suppose we wanted to keep track of the number of times each score appears.
We would have to write 100 lines of code:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">int</span> count0 = inRange(scores, 0, 1);
<span style="color:blue">int</span> count1 = inRange(scores, 1, 2);
<span style="color:blue">int</span> count2 = inRange(scores, 2, 3);
...
<span style="color:blue">int</span> count99 = inRange(scores, 99, 100);</td></tr>
</table><p>What we need is a way to store 100 counters, preferably so we can use an index to access them.
In other words, we need another array!</p><p>The following fragment creates an array of 100 counters, one for each possible score.
It loops through the scores and uses <code>inRange</code> to count how many times each score appears.
Then it stores the results in the array:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">int</span>[] counts = <span style="color:blue">new int</span>[100];
<span style="color:blue">for</span> (<span style="color:blue">int</span> i = 0; i &lt; counts.length; i++) {
    counts[i] = inRange(scores, i, i + 1);
}</td></tr>
</table><p>Notice that we are using the loop variable <code>i</code> three times: as an index into the <code>counts</code> array, and as two arguments for <code>inRange</code>.
The code works, but it is not as efficient as it could be.
Every time the loop invokes <code>inRange</code>, it traverses the entire array.</p><p><a name="hevea_default435"></a></p><p>It would be better to make a single pass through the array, and for each score, compute which range it falls in and increment the corresponding counter.
This code traverses the array of scores <em>only once</em> to generate the histogram:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">int</span>[] counts = <span style="color:blue">new int</span>[100];
<span style="color:blue">for</span> (<span style="color:blue">int</span> i = 0; i &lt; scores.length; i++) {
    <span style="color:blue">int</span> index = scores[i];
    counts[index]++;
}</td></tr>
</table><p>Each time through the loop, it selects one element from <code>scores</code> and uses it as an index to increment the corresponding element of <code>counts</code>.
Because this code only traverses the array of scores once, it is much more efficient.</p>
<h2 name="sec101" class="section">8.10  The enhanced for loop</h2>
<p>
<a name="enhanced"></a></p><p>Since traversing arrays is so common, Java provides an alternative syntax that makes the code more compact.
For example, consider a <code><span style="color:blue">for</span></code> loop that displays the elements of an array on separate lines:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">for</span> (<span style="color:blue">int</span> i = 0; i &lt; values.length; i++) {
    <span style="color:blue">int</span> value = values[i];
    System.out.println(value);
}</td></tr>
</table><p>We could rewrite the loop like this:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">for</span> (<span style="color:blue">int</span> value : values) {
    System.out.println(value);
}</td></tr>
</table><p><a name="hevea_default436"></a></p><p>This statement is called an <span style="font-weight:bold">enhanced for loop</span>.
You can read it as, “for each <code>value</code> in <code>values</code>”.
It’s conventional to use plural nouns for array variables and singular nouns for element variables.</p><p>Notice how the single line <code><span style="color:blue">for</span> (<span style="color:blue">int</span> value : values)</code> replaces the first two lines of the standard <code><span style="color:blue">for</span></code> loop.
It hides the details of iterating each index of the array, and instead, focuses on the values themselves.</p><p>Using the enhanced <code><span style="color:blue">for</span></code> loop, and removing the temporary variable, we can write the histogram code from the previous section more concisely:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">int</span>[] counts = <span style="color:blue">new int</span>[100];
<span style="color:blue">for</span> (<span style="color:blue">int</span> score : scores) {
    counts[score]++;
}</td></tr>
</table><p>Enhanced <code><span style="color:blue">for</span></code> loops often make the code more readable, especially for accumulating values.
But they are not helpful when you need to refer to the index, as in search operations.</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">for</span> (<span style="color:blue">double</span> d : array) {
    <span style="color:blue">if</span> (d == target) {
        <span style="color:#007C00">// array contains d, but we don't know the index</span>
    }
}</td></tr>
</table>
<h2 name="sec102" class="section">8.11  Vocabulary</h2>
<dl class="description"><dt class="dt-description"><span style="font-weight:bold">array:</span></dt><dd class="dd-description"><a name="hevea_default437"></a>
A collection of values, where all the values have the same type, and each value is identified by an index.</dd><dt class="dt-description"><span style="font-weight:bold">element:</span></dt><dd class="dd-description"><a name="hevea_default438"></a>
One of the values in an array.
The <code>[]</code> operator selects elements.</dd><dt class="dt-description"><span style="font-weight:bold">index:</span></dt><dd class="dd-description"><a name="hevea_default439"></a>
An integer variable or value used to indicate an element of an array.</dd><dt class="dt-description"><span style="font-weight:bold">reference:</span></dt><dd class="dd-description"><a name="hevea_default440"></a>
A value that indicates another value, like an array.
In a state diagram, a reference appears as an arrow.</dd><dt class="dt-description"><span style="font-weight:bold">alias:</span></dt><dd class="dd-description"><a name="hevea_default441"></a>
A variable that refers to the same object as another variable.</dd><dt class="dt-description"><span style="font-weight:bold">traversal:</span></dt><dd class="dd-description"><a name="hevea_default442"></a>
Looping through the elements of an array (or other collection).</dd><dt class="dt-description"><span style="font-weight:bold">search:</span></dt><dd class="dd-description"><a name="hevea_default443"></a>
A traversal pattern used to find a particular element of an array.</dd><dt class="dt-description"><span style="font-weight:bold">reduce:</span></dt><dd class="dd-description"><a name="hevea_default444"></a>
A traversal pattern that combines the elements of an array into a single value.</dd><dt class="dt-description"><span style="font-weight:bold">accumulator:</span></dt><dd class="dd-description"><a name="hevea_default445"></a>
A variable used to accumulate results during a traversal.</dd><dt class="dt-description"><span style="font-weight:bold">deterministic:</span></dt><dd class="dd-description"><a name="hevea_default446"></a>
A program that does the same thing every time it is invoked.</dd><dt class="dt-description"><span style="font-weight:bold">nondeterministic:</span></dt><dd class="dd-description"><a name="hevea_default447"></a>
A program that always behaves differently, even when run multiple times with the same input.</dd><dt class="dt-description"><span style="font-weight:bold">pseudorandom:</span></dt><dd class="dd-description"><a name="hevea_default448"></a>
A sequence of numbers that appear to be random, but which are actually the product of a deterministic computation.</dd><dt class="dt-description"><span style="font-weight:bold">histogram:</span></dt><dd class="dd-description"><a name="hevea_default449"></a>
An array of integers where each integer counts the number of values that fall into a certain range.</dd><dt class="dt-description"><span style="font-weight:bold">enhanced for loop:</span></dt><dd class="dd-description"><a name="hevea_default450"></a>
An alternative syntax for traversing the elements (values) of an array.</dd></dl>
<h2 name="sec103" class="section">8.12  Exercises</h2>
<p>The code for this chapter is in the <span style="font-family:monospace">ch08</span> directory of <span style="font-family:monospace">ThinkJavaCode</span>.
See page <a href="/thinkjava/preface.html#code">??</a> for instructions on how to download the repository.
Before you start the exercises, we recommend that you compile and run the examples.</p><div class="theorem"><span style="font-weight:bold">Exercise 1</span>  <em>
The goal of this exercise is to practice encapsulation with some of the examples in this chapter.</em><ol class="enumerate" type="1"><li class="li-enumerate"><em>Starting with the code in Section </em><a href="#traversal"><em>8.6</em></a><em>, write a method called <code>powArray</code> that takes a <span style="color:blue"><code>double</code></span> array, <code>a</code>, and returns a new array that contains the elements of <code>a</code> squared.
Generalize it to take a second argument and raise the elements of <code>a</code> to the given power.</em></li><li class="li-enumerate"><em>Starting with the code in Section </em><a href="#enhanced"><em>8.10</em></a><em>, write a method called <code>histogram</code> that takes an <span style="color:blue"><code>int</code></span> array of scores from 0 to (but not including) 100, and returns a histogram of 100 counters.
Generalize it to take the number of counters as an argument.</em></li></ol></div><div class="theorem"><span style="font-weight:bold">Exercise 2</span>  <em>
The purpose of this exercise is to practice reading code and recognizing the traversal patterns in this chapter.
The following methods are hard to read, because instead of using meaningful names for the variables and methods, they use names of fruit.</em><p><em>For each method, write one sentence that describes what the method does, without getting into the details of how it works.
For each variable, identify the role it plays.</em></p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><em><span style="color:blue">public static int</span> banana(<span style="color:blue">int</span>[] a) {
    <span style="color:blue">int</span> kiwi = 1;
    <span style="color:blue">int</span> i = 0;
    <span style="color:blue">while</span> (i &lt; a.length) {
        kiwi = kiwi * a[i];
        i++;
    }
    <span style="color:blue">return</span> kiwi;
}</em></td></tr>
</table><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><em><span style="color:blue">public static int</span> grapefruit(<span style="color:blue">int</span>[] a, <span style="color:blue">int</span> grape) {
    <span style="color:blue">for</span> (<span style="color:blue">int</span> i = 0; i &lt; a.length; i++) {
        <span style="color:blue">if</span> (a[i] == grape) {
            <span style="color:blue">return</span> i;
        }
    }
    <span style="color:blue">return</span> -1;
}</em></td></tr>
</table><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><em><span style="color:blue">public static int</span> pineapple(<span style="color:blue">int</span>[] a, <span style="color:blue">int</span> apple) {
    <span style="color:blue">int</span> pear = 0;
    <span style="color:blue">for</span> (<span style="color:blue">int</span> pine: a) {
        <span style="color:blue">if</span> (pine == apple) {
            pear++;
        }
    }
    <span style="color:blue">return</span> pear;
}</em></td></tr>
</table></div><div class="theorem"><span style="font-weight:bold">Exercise 3</span>  <em>
What is the output of the following program?
Describe in a few words what <code>mus</code> does.
Draw a stack diagram just before <code>mus</code> returns.
</em><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><em><span style="color:blue">public static int</span>[] make(<span style="color:blue">int</span> n) {
    <span style="color:blue">int</span>[] a = <span style="color:blue">new int</span>[n];
    <span style="color:blue">for</span> (<span style="color:blue">int</span> i = 0; i &lt; n; i++) {
        a[i] = i + 1;
    }
    <span style="color:blue">return</span> a;
}</em></td></tr>
</table><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><em><span style="color:blue">public static void</span> dub(<span style="color:blue">int</span>[] jub) {
    <span style="color:blue">for</span> (<span style="color:blue">int</span> i = 0; i &lt; jub.length; i++) {
        jub[i] *= 2;
    }
}</em></td></tr>
</table><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><em><span style="color:blue">public static int</span> mus(<span style="color:blue">int</span>[] zoo) {
    <span style="color:blue">int</span> fus = 0;
    <span style="color:blue">for</span> (<span style="color:blue">int</span> i = 0; i &lt; zoo.length; i++) {
        fus += zoo[i];
    }
    <span style="color:blue">return</span> fus;
}</em></td></tr>
</table><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><em><span style="color:blue">public static void</span> main(String[] args) {
    <span style="color:blue">int</span>[] bob = make(5);
    dub(bob);
    System.out.println(mus(bob));
}</em></td></tr>
</table></div><div class="theorem"><span style="font-weight:bold">Exercise 4</span>  <em>
Write a method called <code>indexOfMax</code> that takes an array of integers and returns the index of the largest element.
Can you write this method using an enhanced <span style="color:blue"><code>for</code></span> loop?
Why or why not?
</em></div><div class="theorem"><span style="font-weight:bold">Exercise 5</span>  <em>
The Sieve of Eratosthenes is “a simple, ancient algorithm for finding all prime numbers up to any given limit,” which you can read about at </em><a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"><em><span style="font-family:monospace">https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes</span></em></a><em>.</em><p><em>Write a method called <code>sieve</code> that takes an integer parameter, <code>n</code>, and returns a <span style="color:blue"><code>boolean</code></span> array that indicates, for each number from <code>0</code> to <code>n - 1</code>, whether the number is prime.
</em></p></div><div class="theorem"><span style="font-weight:bold">Exercise 6</span>  <em>
Write a method named <code>areFactors</code> that takes an integer <code>n</code> and an array of integers, and that returns <span style="color:blue"><code>true</code></span> if the numbers in the array are all factors of <code>n</code> (which is to say that <code>n</code> is divisible by all of them).
</em></div><div class="theorem"><span style="font-weight:bold">Exercise 7</span>  <em>
Write a method named <code>arePrimeFactors</code> that takes an integer <code>n</code> and an array of integers, and that returns <span style="color:blue"><code>true</code></span> if the numbers in the array are all prime </em>and<em> their product is <code>n</code>.
</em></div><div class="theorem"><span style="font-weight:bold">Exercise 8</span>  <em>
Many of the patterns we have seen for traversing arrays can also be written recursively.
It is not common, but it is a useful exercise.</em><ol class="enumerate" type="1"><li class="li-enumerate"><em>Write a method called <code>maxInRange</code> that takes an array of integers and two indexes, <code>lowIndex</code> and <code>highIndex</code>, and finds the maximum value in the array, but only considering the elements between <code>lowIndex</code> and <code>highIndex</code>, including both.</em><p><em>This method should be recursive.
If the length of the range is 1, that is, if <code>lowIndex == highIndex</code>, we know immediately that the sole element in the range must be the maximum.
So that’s the base case.</em></p><p><em>If there is more than one element in the range, we can break the array into two pieces, find the maximum in each of the pieces, and then find the maximum of the maxima.</em></p></li><li class="li-enumerate"><em>Methods like <code>maxInRange</code> can be awkward to use.
To find the largest element in an array, we have to provide the range for the entire array.</em><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><em><span style="color:blue">double</span> max = maxInRange(a, 0, a.length - 1);</em></td></tr>
</table><p><em>Write a method called <code>max</code> that takes an array and uses <code>maxInRange</code> to find and return the largest element.</em></p></li></ol></div>
</div>
</div>

</div>

</div>
{% endblock %}

{% block toc %}
<li class="has-dropdown"><a href="/thinkjava/chapter8.html">Arrays</a>
<ul class="dropdown">
<li><a href="/thinkjava/chapter8.html#sec92">Creating arrays</a>
</li><li><a href="/thinkjava/chapter8.html#sec93">Accessing elements</a>
</li><li><a href="/thinkjava/chapter8.html#sec94">Displaying arrays</a>
</li><li><a href="/thinkjava/chapter8.html#sec95">Copying arrays</a>
</li><li><a href="/thinkjava/chapter8.html#sec96">Array length</a>
</li><li><a href="/thinkjava/chapter8.html#sec97">Array traversal</a>
</li><li><a href="/thinkjava/chapter8.html#sec98">Random numbers</a>
</li><li><a href="/thinkjava/chapter8.html#sec99">Traverse and count</a>
</li><li><a href="/thinkjava/chapter8.html#sec100">Building a histogram</a>
</li><li><a href="/thinkjava/chapter8.html#sec101">The enhanced for loop</a>
</li><li><a href="/thinkjava/chapter8.html#sec102">Vocabulary</a>
</li><li><a href="/thinkjava/chapter8.html#sec103">Exercises</a>
</li></ul>
</li>
{% endblock %}

{% block title%}Arrays | Think Java | Trinket{% endblock %}
