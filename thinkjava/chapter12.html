
            
{% extends 'books/thinkjava/base.html' %}
{% block chaptercontent %}
<div class="row">
<div class="columns small-12">


      <div class="row">
        <div class="columns small-12"><h1 id="sec141" class="chapter">Chapter 12  Arrays of objects</h1>
<p>In the remaining chapters, we will develop programs that work with playing cards and decks of cards.
Here is an outline of the road ahead:</p><ul class="itemize"><li class="li-itemize">In this chapter, we define a <code>Card</code> class and write methods that work with cards and arrays of cards.</li><li class="li-itemize">In Chapter <a href="/thinkjava/chapter13.html#deck">13.1</a>, we create a <code>Deck</code> class that encapsulates an array of cards, and we write methods that operate on decks.</li><li class="li-itemize">In Chapter <a href="/thinkjava/chapter14.html#eights">14</a>, we introduce inheritance as a way to create new classes that extend existing classes.
We then use all these classes to implement the card game <span style="font-style:italic">Crazy Eights</span>.</li></ul><p>The code for this chapter is in <span style="font-family:monospace">Card.java</span>, which is in the directory <span style="font-family:monospace">ch12</span> in the repository for this book.
Instructions for downloading this code are on page <a href="/thinkjava/preface.html#code">??</a>.</p>
<h2 id="sec142" class="section">12.1  Card objects</h2>
<p>
<a id="card"/></p><p><a id="hevea_default646"/>
<a id="hevea_default647"/></p><p>If you are unfamiliar with traditional playing cards, now would be a good time to get a deck or read through <a href="https://en.wikipedia.org/wiki/Standard_52-card_deck"><span style="font-family:monospace">https://en.wikipedia.org/wiki/Standard_52-card_deck</span></a>.</p><p><a id="hevea_default648"/>
<a id="hevea_default649"/></p><p>There are 52 cards in a standard deck.
Each card belongs to one of four suits and one of 13 ranks.
The suits are Spades, Hearts, Diamonds, and Clubs.
The ranks are Ace, 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, and King.</p><p>If we want to define a class to represent a playing card, it is pretty obvious what the instance variables should be: <code>rank</code> and <code>suit</code>.
It is not as obvious what types they should be.
One possibility is a <code>String</code> containing things like <span style="color:#B20000"><code>"Spade"</code></span> for suits and <span style="color:#B20000"><code>"Queen"</code></span> for ranks.
A problem with this design is that it would not be easy to compare cards to see which had a higher rank or suit.</p><p><a id="hevea_default650"/>
<a id="hevea_default651"/></p><p>An alternative is to use integers to <span style="font-weight:bold">encode</span> the ranks and suits.
By “encode” we don’t mean to encrypt or translate into a secret code.
We mean “define a mapping between a sequence of numbers and the things we want to represent.”</p><p>Here is a mapping for suits:</p><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap">Clubs</td><td style="text-align:center;white-space:nowrap">↦</td><td style="text-align:left;white-space:nowrap">0 </td></tr>
<tr><td style="text-align:left;white-space:nowrap">Diamonds</td><td style="text-align:center;white-space:nowrap">↦</td><td style="text-align:left;white-space:nowrap">1 </td></tr>
<tr><td style="text-align:left;white-space:nowrap">Hearts</td><td style="text-align:center;white-space:nowrap">↦</td><td style="text-align:left;white-space:nowrap">2 </td></tr>
<tr><td style="text-align:left;white-space:nowrap">Spades</td><td style="text-align:center;white-space:nowrap">↦</td><td style="text-align:left;white-space:nowrap">3
</td></tr>
</table><p>We use the mathematical symbol ↦ to make it clear that these mappings are not part of the program.
They are part of the program design, but they never appear explicitly in the code.</p><p>Each of the numerical ranks (2 through 10) maps to the corresponding integer, and for face cards:</p><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap">Ace</td><td style="text-align:center;white-space:nowrap">↦</td><td style="text-align:left;white-space:nowrap">1 </td></tr>
<tr><td style="text-align:left;white-space:nowrap">Jack</td><td style="text-align:center;white-space:nowrap">↦</td><td style="text-align:left;white-space:nowrap">11 </td></tr>
<tr><td style="text-align:left;white-space:nowrap">Queen</td><td style="text-align:center;white-space:nowrap">↦</td><td style="text-align:left;white-space:nowrap">12 </td></tr>
<tr><td style="text-align:left;white-space:nowrap">King</td><td style="text-align:center;white-space:nowrap">↦</td><td style="text-align:left;white-space:nowrap">13 </td></tr>
</table><p>So far, the class definition for the <code>Card</code> type looks like this:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">public class</span> Card {
    <span style="color:blue">private int</span> rank;
    <span style="color:blue">private int</span> suit;

    <span style="color:blue">public</span> Card(<span style="color:blue">int</span> rank, <span style="color:blue">int</span> suit) {
        <span style="color:blue">this</span>.rank = rank;
        <span style="color:blue">this</span>.suit = suit;
    }
}</td></tr>
</table><p><a id="hevea_default652"/></p><p>The instance variables are <code><span style="color:blue">private</span></code>: we can access them from inside this class, but not from other classes.</p><p>The constructor takes a parameter for each instance variable.
To create a <code>Card</code> object, we use the <code><span style="color:blue">new</span></code> operator:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">Card threeOfClubs = <span style="color:blue">new</span> Card(3, 0);</td></tr>
</table><p>The result is a reference to a <code>Card</code> that represents the 3 of Clubs.</p>
<h2 id="sec143" class="section">12.2  Card toString</h2>
<p>
<a id="printcard"/></p><p><a id="hevea_default653"/></p><p>When you create a new class, the first step is to declare the instance variables and write constructors.
A good next step is to write <code>toString</code>, which is useful for debugging and incremental development.</p><p><a id="hevea_default654"/>
<a id="hevea_default655"/></p><p>To display <code>Card</code> objects in a way that humans can read easily, we need to map the integer codes onto words.
A natural way to do that is with an array of <code>String</code>s.
We can create the array like this:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">String[] suits = <span style="color:blue">new</span> String[4];</td></tr>
</table><p>And then assign values to the elements:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">suits[0] = <span style="color:#B20000">"Clubs"</span>;
suits[1] = <span style="color:#B20000">"Diamonds"</span>;
suits[2] = <span style="color:#B20000">"Hearts"</span>;
suits[3] = <span style="color:#B20000">"Spades"</span>;</td></tr>
</table><p>Or we can create the array and initialize the elements at the same time, as we saw in Section <a href="/thinkjava/chapter8.html#printarray">8.3</a>:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">String[] suits = {<span style="color:#B20000">"Clubs"</span>, <span style="color:#B20000">"Diamonds"</span>, <span style="color:#B20000">"Hearts"</span>, <span style="color:#B20000">"Spades"</span>};</td></tr>
</table><p><a id="hevea_default656"/>
<a id="hevea_default657"/>
<a id="hevea_default658"/></p><p>The state diagram in Figure <a href="#fig.stringarray">12.1</a> shows the result.
Each element of the array is a reference to a <code>String</code>.</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"/></div>
<div class="center">
<img src="thinkjava6027.png"/>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;">Figure 12.1: State diagram of an array of strings.</td></tr>
</table></div>
<a id="fig.stringarray"/>
</div>
<div class="center"><hr style="width:80%;height:2"/></div></blockquote><p>Now we need an array to decode the ranks:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">String[] ranks = {<span style="color:blue">null</span>, <span style="color:#B20000">"Ace"</span>, <span style="color:#B20000">"2"</span>, <span style="color:#B20000">"3"</span>, <span style="color:#B20000">"4"</span>, <span style="color:#B20000">"5"</span>, <span style="color:#B20000">"6"</span>,
           <span style="color:#B20000">"7"</span>, <span style="color:#B20000">"8"</span>, <span style="color:#B20000">"9"</span>, <span style="color:#B20000">"10"</span>, <span style="color:#B20000">"Jack"</span>, <span style="color:#B20000">"Queen"</span>, <span style="color:#B20000">"King"</span>};</td></tr>
</table><p>The zeroth element should never be used, because the only valid ranks are 1–13.
We set it to <code><span style="color:blue">null</span></code> to indicate an unused element.</p><p>Using these arrays, we can create a meaningful <code>String</code> using <code>suit</code> and <code>rank</code> as indexes.</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">String s = ranks[card.rank] + <span style="color:#B20000">" of "</span> + suits[card.suit];</td></tr>
</table><p>The expression <code>suits[card.suit]</code> means “use the instance variable <code>suit</code> from the object <code>card</code> as an index into the array <code>suits</code>.”</p><p>Now we can wrap all that in a <code>toString</code> method.</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">public</span> String toString() {
    String[] ranks = {<span style="color:blue">null</span>, <span style="color:#B20000">"Ace"</span>, <span style="color:#B20000">"2"</span>, <span style="color:#B20000">"3"</span>, <span style="color:#B20000">"4"</span>, <span style="color:#B20000">"5"</span>, <span style="color:#B20000">"6"</span>,
               <span style="color:#B20000">"7"</span>, <span style="color:#B20000">"8"</span>, <span style="color:#B20000">"9"</span>, <span style="color:#B20000">"10"</span>, <span style="color:#B20000">"Jack"</span>, <span style="color:#B20000">"Queen"</span>, <span style="color:#B20000">"King"</span>};
    String[] suits = {<span style="color:#B20000">"Clubs"</span>, <span style="color:#B20000">"Diamonds"</span>, <span style="color:#B20000">"Hearts"</span>, <span style="color:#B20000">"Spades"</span>};
    String s = ranks[<span style="color:blue">this</span>.rank] + <span style="color:#B20000">" of "</span> + suits[<span style="color:blue">this</span>.suit];
    <span style="color:blue">return</span> s;
}</td></tr>
</table><p>When we display a card, <code>println</code> automatically calls <code>toString</code>:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">Card card = <span style="color:blue">new</span> Card(11, 1);
System.out.println(card);</td></tr>
</table><p>The output is <span style="font-family:monospace">Jack of Diamonds</span>.</p>
<h2 id="sec144" class="section">12.3  Class variables</h2>
<p>
<a id="classvar"/></p><p>So far we have seen local variables, which are declared inside a method, and instance variables, which are declared in a class definition, usually before the method definitions.</p><p>Local variables are created when a method is invoked, and their space is reclaimed when the method ends.
Instance variables are created when you construct an object and reclaimed when the object is garbage-collected.</p><p><a id="hevea_default659"/>
<a id="hevea_default660"/>
<a id="hevea_default661"/></p><p>Now it’s time to learn about <span style="font-weight:bold">class variables</span>.
Like instance variables, class variables are defined in a class definition, before the method definitions.
But they are identified by the keyword <code><span style="color:blue">static</span></code>.
They are created when the program begins (or when the class is used for the first time) and survive until the program ends.
Class variables are <em>shared</em> across all instances of the class.</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">public class</span> Card {

    <span style="color:blue">public static final</span> String[] RANKS = {
        <span style="color:blue">null</span>, <span style="color:#B20000">"Ace"</span>, <span style="color:#B20000">"2"</span>, <span style="color:#B20000">"3"</span>, <span style="color:#B20000">"4"</span>, <span style="color:#B20000">"5"</span>, <span style="color:#B20000">"6"</span>, <span style="color:#B20000">"7"</span>,
        <span style="color:#B20000">"8"</span>, <span style="color:#B20000">"9"</span>, <span style="color:#B20000">"10"</span>, <span style="color:#B20000">"Jack"</span>, <span style="color:#B20000">"Queen"</span>, <span style="color:#B20000">"King"</span>};

    <span style="color:blue">public static final</span> String[] SUITS = {
        <span style="color:#B20000">"Clubs"</span>, <span style="color:#B20000">"Diamonds"</span>, <span style="color:#B20000">"Hearts"</span>, <span style="color:#B20000">"Spades"</span>};

    <span style="color:#007C00">// instance variables and constructors go here</span>

    <span style="color:blue">public</span> String toString() {
        <span style="color:blue">return</span> RANKS[<span style="color:blue">this</span>.rank] + <span style="color:#B20000">" of "</span> + SUITS[<span style="color:blue">this</span>.suit];
    }
}</td></tr>
</table><p><a id="hevea_default662"/></p><p>Class variables are often used to store constant values that are needed in several places.
In that case, they should also be defined as <code><span style="color:blue">final</span></code>.
Note that whether a variable is <code><span style="color:blue">static</span></code> or <code><span style="color:blue">final</span></code> involves two separate considerations:
<code><span style="color:blue">static</span></code> means the variable is shared, and <code><span style="color:blue">final</span></code> means the variable is constant.</p><p>Naming <code><span style="color:blue">static</span> <span style="color:blue">final</span></code> variables with capital letters is a common convention that makes it easier to recognize their role in the class.
Inside <code>toString</code> we can refer to <code>SUITS</code> and <code>RANKS</code> as if they were local variables, but we can tell that they are class variables.</p><p>One advantage of defining <code>SUITS</code> and <code>RANKS</code> as class variables is that they don’t need to be created (and garbage-collected) every time <code>toString</code> is called.
They may also be needed in other methods and classes, so it’s helpful to make them available everywhere.
Since the array variables are <code><span style="color:blue">final</span></code>, and the strings they reference are immutable, there is no danger in making them <code><span style="color:blue">public</span></code>.</p>
<h2 id="sec145" class="section">12.4  The compareTo method</h2>
<p>
<a id="compare"/></p><p><a id="hevea_default663"/></p><p>As we saw in Section <a href="/thinkjava/chapter11.html#equals">11.7</a>, it’s helpful to create an <code>equals</code> method to test whether two objects are equivalent.</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">public boolean</span> equals(Card that) {
    <span style="color:blue">return this</span>.rank == that.rank
        &amp;&amp; <span style="color:blue">this</span>.suit == that.suit;
}</td></tr>
</table><p><a id="hevea_default664"/>
<a id="hevea_default665"/></p><p>It would also be nice to have a method for comparing cards, so we can tell if one is higher or lower than another.
For primitive types, we can use the comparison operators – <code>&lt;</code>, <code>&gt;</code>, etc. – to compare values.
But these operators don’t work for object types.</p><p>For <code>String</code>s, Java provides a <code>compareTo</code> method, as we saw in Section <a href="/thinkjava/chapter9.html#strcmp">9.6</a>.
Like the <code>equals</code> method, we can write our own version of <code>compareTo</code> for the classes that we define.
</p><p><a id="hevea_default666"/>
<a id="hevea_default667"/>
<a id="hevea_default668"/></p><p>Some types are “totally ordered”, which means that you can compare any two values and tell which is bigger.
Integers and strings are totally ordered.</p><p>Other types are “unordered”, which means that there is no meaningful way to say that one element is bigger than another.
In Java, the <code><span style="color:blue">boolean</span></code> type is unordered; if you try to compare <code><span style="color:blue">true</span> &lt; <span style="color:blue">false</span></code>, you get a compiler error.</p><p>The set of playing cards is “partially ordered”, which means that sometimes we can compare cards and sometimes not.
For example, we know that the 3 of Clubs is higher than the 2 of Clubs, and the 3 of Diamonds is higher than the 3 of Clubs.
But which is better, the 3 of Clubs or the 2 of Diamonds?
One has a higher rank, but the other has a higher suit.</p><p><a id="hevea_default669"/></p><p>To make cards comparable, we have to decide which is more important: rank or suit.
The choice is arbitrary, and it might be different for different games.
But when you buy a new deck of cards, it comes sorted with all the Clubs together, followed by all the Diamonds, and so on.
So for now, let’s say that suit is more important.</p><p>With that decided, we can write <code>compareTo</code> as follows:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">public int</span> compareTo(Card that) {
    <span style="color:blue">if</span> (<span style="color:blue">this</span>.suit &lt; that.suit) {
        <span style="color:blue">return</span> -1;
    }
    <span style="color:blue">if</span> (<span style="color:blue">this</span>.suit &gt; that.suit) {
        <span style="color:blue">return</span> 1;
    }
    <span style="color:blue">if</span> (<span style="color:blue">this</span>.rank &lt; that.rank) {
        <span style="color:blue">return</span> -1;
    }
    <span style="color:blue">if</span> (<span style="color:blue">this</span>.rank &gt; that.rank) {
        <span style="color:blue">return</span> 1;
    }
    <span style="color:blue">return</span> 0;
}</td></tr>
</table><p><code>compareTo</code> returns 1 if <code><span style="color:blue">this</span></code> wins, -1 if <code>that</code> wins, and 0 if they are equivalent.
It compares suits first.
If the suits are the same, it compares ranks.
If the ranks are also the same, it returns 0.</p>
<h2 id="sec146" class="section">12.5  Cards are immutable</h2>
<p>The instance variables of <code>Card</code> are <code><span style="color:blue">private</span></code>, so they can’t be accessed from other classes.
We can provide getters to allow other classes to read the <code>rank</code> and <code>suit</code> values:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">public int</span> getRank() {
    <span style="color:blue">return this</span>.rank;
}

<span style="color:blue">public int</span> getSuit() {
    <span style="color:blue">return this</span>.suit;
}</td></tr>
</table><p><a id="hevea_default670"/></p><p>Whether or not to provide setters is a design decision.
If we did, cards would be mutable, so you could transform one card into another.
That is probably not a feature we need, and in general mutable objects are more error-prone.
So it might be better to make cards immutable.
To do that, all we have to do is <em>not</em> provide any modifier methods (including setters).</p><p><a id="hevea_default671"/></p><p>That’s easy enough, but it is not foolproof, because some fool might come along later and add a modifier.
We can prevent that possibility by declaring the instance variables <code><span style="color:blue">final</span></code>:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">public class</span> Card {
    <span style="color:blue">private final int</span> rank;
    <span style="color:blue">private final int</span> suit;

    ...
}</td></tr>
</table><p>You can still assign values to these variables inside a constructor.
But if someone writes a method that tries to modify these variables, they’ll get a compiler error.</p>
<h2 id="sec147" class="section">12.6  Arrays of cards</h2>
<p>
<a id="cardarray"/></p><p><a id="hevea_default672"/>
<a id="hevea_default673"/></p><p>Just as you can create an array of <code>String</code> objects, you can create an array of <code>Card</code> objects.
The following statement creates an array of 52 cards:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">Card[] cards = <span style="color:blue">new</span> Card[52];</td></tr>
</table><p>Figure <a href="#fig.cardarray">12.2</a> shows the state diagram for this array.</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"/></div>
<div class="center">
<img src="thinkjava6028.png"/>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;">Figure 12.2: State diagram of an unpopulated <code>Card</code> array.</td></tr>
</table></div>
<a id="fig.cardarray"/>
</div>
<div class="center"><hr style="width:80%;height:2"/></div></blockquote><p><a id="hevea_default674"/></p><p>Although we call it an “array of cards”, the array contains <em>references</em> to objects; it does not contain the <code>Card</code> objects themselves.
The elements are initialized to <code><span style="color:blue">null</span></code>.
You can access the elements of the array in the usual way:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">if</span> (cards[0] == <span style="color:blue">null</span>) {
    System.out.println(<span style="color:#B20000">"No card yet!"</span>);
}</td></tr>
</table><p><a id="hevea_default675"/>
<a id="hevea_default676"/></p><p>But if you try to access the instance variables of the non-existent <code>Card</code>s, you will get a <code>NullPointerException</code>.</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">cards[0].rank      <span style="color:#007C00">// NullPointerException</span></td></tr>
</table><p><a id="hevea_default677"/>
<a id="hevea_default678"/></p><p>That code won’t work until we put cards in the array.
One way to populate the array is to write nested <code><span style="color:blue">for</span></code> loops:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">int</span> index = 0;
<span style="color:blue">for</span> (<span style="color:blue">int</span> suit = 0; suit &lt;= 3; suit++) {
    <span style="color:blue">for</span> (<span style="color:blue">int</span> rank = 1; rank &lt;= 13; rank++) {
        cards[index] = <span style="color:blue">new</span> Card(rank, suit);
        index++;
    }
}</td></tr>
</table><p>The outer loop iterates suits from 0 to 3.
For each suit, the inner loop iterates ranks from 1 to 13.
Since the outer loop runs 4 times, and the inner loop runs 13 times for each suit, the body is executed 52 times.</p><p><a id="hevea_default679"/></p><p>We use a separate variable <code>index</code> to keep track of where in the array the next card should go.
Figure <a href="#fig.cardarray2">12.3</a> shows what the array looks like after the first two cards have been created.</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"/></div>
<div class="center">
<img src="thinkjava6029.png"/>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;">Figure 12.3: State diagram of a <code>Card</code> array with two cards.</td></tr>
</table></div>
<a id="fig.cardarray2"/>
</div>
<div class="center"><hr style="width:80%;height:2"/></div></blockquote><p><a id="hevea_default680"/></p><p>When you work with arrays, it is convenient to have a method that displays the contents.
We have seen the pattern for traversing an array several times, so the following method should be familiar:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">public static void</span> printDeck(Card[] cards) {
    <span style="color:blue">for</span> (<span style="color:blue">int</span> i = 0; i &lt; cards.length; i++) {
        System.out.println(cards[i]);
    }
}</td></tr>
</table><p>Since <code>cards</code> has type <code>Card[]</code>, an element of <code>cards</code> has type <code>Card</code>.
So <code>println</code> invokes the <code>toString</code> method in the <code>Card</code> class.
This method is similar to invoking <code>System.out.println(Arrays.toString(cards))</code>.</p>
<h2 id="sec148" class="section">12.7  Sequential search</h2>
<p>
<a id="findcard"/></p><p><a id="hevea_default681"/></p><p>The next method we’ll write is <code>search</code>, which takes an array of cards and a <code>Card</code> object as parameters.
It returns the index where the <code>Card</code> appears in the array, or <code>-1</code> if it doesn’t.
This version of <code>search</code> uses the algorithm we saw in Section <a href="/thinkjava/chapter8.html#traversal">8.6</a>, which is called <span style="font-weight:bold">sequential search</span>:</p><p><a id="hevea_default682"/>
<a id="hevea_default683"/></p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">public static int</span> search(Card[] cards, Card target) {
    <span style="color:blue">for</span> (<span style="color:blue">int</span> i = 0; i &lt; cards.length; i++) {
        <span style="color:blue">if</span> (cards[i].equals(target)) {
            <span style="color:blue">return</span> i;
        }
    }
    <span style="color:blue">return</span> -1;
}</td></tr>
</table><p><a id="hevea_default684"/>
<a id="hevea_default685"/></p><p>The method returns as soon as it discovers the card, which means we don’t have to traverse the entire array if we find the target.
If we get to the end of the loop, we know the card is not in the array.
Notice that this algorithm depends on the <code>equals</code> method.</p><p><a id="hevea_default686"/></p><p>If the cards in the array are not in order, there is no way to search faster than sequential search.
We have to look at every card, because otherwise we can’t be certain the card we want is not there.
But if the cards are in order, we can use better algorithms.</p><p>We will learn in the next chapter how to sort arrays.
If you pay the price to keep them sorted, finding elements becomes much easier.
Especially for large arrays, sequential search is rather inefficient.</p>
<h2 id="sec149" class="section">12.8  Binary search</h2>
<p><a id="hevea_default687"/></p><p>When you look for a word in a dictionary, you don’t just search page by page from front to back.
Since the words are in alphabetical order, you probably use a <span style="font-weight:bold">binary search</span> algorithm:</p><ol class="enumerate" type="1"><li class="li-enumerate">Start on a page near the middle of the dictionary.</li><li class="li-enumerate">Compare a word on the page to the word you are looking for.
If you find it, stop.</li><li class="li-enumerate">If the word on the page comes before the word you are looking for, flip to somewhere later in the dictionary and go to step 2.</li><li class="li-enumerate">If the word on the page comes after the word you are looking for, flip to somewhere earlier in the dictionary and go to step 2.</li></ol><p>If you find two adjacent words on the page and your word comes between them, you can conclude that your word is not in the dictionary.</p><p>Getting back to the array of cards, we can write a faster version of <code>search</code> if we know the cards are in order:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">public static int</span> binarySearch(Card[] cards, Card target) {
    <span style="color:blue">int</span> low = 0;
    <span style="color:blue">int</span> high = cards.length - 1;
    <span style="color:blue">while</span> (low &lt;= high) {
        <span style="color:blue">int</span> mid = (low + high) / 2;                 <span style="color:#007C00">// step 1</span>
        <span style="color:blue">int</span> comp = cards[mid].compareTo(target);

        <span style="color:blue">if</span> (comp == 0) {                            <span style="color:#007C00">// step 2</span>
            <span style="color:blue">return</span> mid;
        } <span style="color:blue">else if</span> (comp &lt; 0) {                      <span style="color:#007C00">// step 3</span>
            low = mid + 1;
        } <span style="color:blue">else</span> {                                    <span style="color:#007C00">// step 4</span>
            high = mid - 1;
        }
    }
    <span style="color:blue">return</span> -1;
}</td></tr>
</table><p>First, we declare <code>low</code> and <code>high</code> variables to represent the range we are searching.
Initially we search the entire array, from <code>0</code> to <code>length - 1</code>.</p><p>Inside the <code><span style="color:blue">while</span></code> loop, we repeat the four steps of binary search:</p><ol class="enumerate" type="1"><li class="li-enumerate">Choose an index between <code>low</code> and <code>high</code> – call it <code>mid</code> – and compare the card at <code>mid</code> to the target.</li><li class="li-enumerate">If you found the target, return the index.</li><li class="li-enumerate">If the card at <code>mid</code> is lower than the target, search the range from <code>mid + 1</code> to <code>high</code>.</li><li class="li-enumerate">If the card at <code>mid</code> is higher than the target, search the range from <code>low</code> to <code>mid - 1</code>.</li></ol><p>If <code>low</code> exceeds <code>high</code>, there are no cards in the range, so we break out of the loop and return <code>-1</code>.
Notice that this algorithm depends on the <code>compareTo</code> method of the object.</p>
<h2 id="sec150" class="section">12.9  Tracing the code</h2>
<p>To see how binary search works, it’s helpful to add the following print statement at the beginning of the loop:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">System.out.println(low + <span style="color:#B20000">", "</span> + high);</td></tr>
</table><p>If we invoke <code>binarySearch</code> like this:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">Card card = <span style="color:blue">new</span> Card(11, 0);
System.out.println(binarySearch(cards, card));</td></tr>
</table><p>We expect to find this card at position 10.
Here is the result:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">0, 51
0, 24
0, 11
6, 11
9, 11
10</td></tr>
</table><p>If we search for a card that’s not in the array, like <code><span style="color:blue">new</span> Card(15, 1)</code>, which is the “15 of Diamonds”, we get the following:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting">0, 51
26, 51
26, 37
26, 30
26, 27
-1</td></tr>
</table><p>Each time through the loop, we cut the distance between <code>low</code> and <code>high</code> in half.
After <span style="font-style:italic">k</span> iterations, the number of remaining cards is 52 / 2<sup><span style="font-style:italic">k</span></sup>.
To find the number of iterations it takes to complete, we set 52 / 2<sup><span style="font-style:italic">k</span></sup> = 1 and solve for <span style="font-style:italic">k</span>.
The result is log<sub>2</sub> 52, which is about 5.7.
So we might have to look at 5 or 6 cards, as opposed to all 52 if we did a sequential search.</p><p>More generally, if the array contains <span style="font-style:italic">n</span> elements, binary search requires log<sub>2</sub> <span style="font-style:italic">n</span> comparisons, and sequential search requires <span style="font-style:italic">n</span>.
For large values of <span style="font-style:italic">n</span>, binary search can be much faster.</p>
<h2 id="sec151" class="section">12.10  Recursive version</h2>
<p><a id="hevea_default688"/></p><p>Another way to write a binary search is with a recursive method.
The trick is to write a method that takes <code>low</code> and <code>high</code> as parameters, and turn steps 3 and 4 into recursive invocations.
Here’s what the code looks like:</p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><span style="color:blue">public static int</span> binarySearch(Card[] cards, Card target,
                               <span style="color:blue">int</span> low, <span style="color:blue">int</span> high) {
    <span style="color:blue">if</span> (high &lt; low) {
        <span style="color:blue">return</span> -1;
    }
    <span style="color:blue">int</span> mid = (low + high) / 2;                     <span style="color:#007C00">// step 1</span>
    <span style="color:blue">int</span> comp = cards[mid].compareTo(target);

    <span style="color:blue">if</span> (comp == 0) {                                <span style="color:#007C00">// step 2</span>
        <span style="color:blue">return</span> mid;
    } <span style="color:blue">else if</span> (comp &lt; 0) {                          <span style="color:#007C00">// step 3</span>
        <span style="color:blue">return</span> binarySearch(cards, target, mid + 1, high);
    } <span style="color:blue">else</span> {                                        <span style="color:#007C00">// step 4</span>
        <span style="color:blue">return</span> binarySearch(cards, target, low, mid - 1);
    }
}</td></tr>
</table><p>Instead of a <code><span style="color:blue">while</span></code> loop, we have an <code><span style="color:blue">if</span></code> statement to terminate the recursion.
If <code>high</code> is less than <code>low</code>, there are no cards between them, and we conclude that the card is not in the array.</p><p><a id="hevea_default689"/>
<a id="hevea_default690"/>
<a id="hevea_default691"/></p><p>Two common errors in recursive programs are (1) forgetting to include a base case, and (2) writing the recursive call so that the base case is never reached.
Either error causes infinite recursion and a <code>StackOverflowException</code>.</p>
<h2 id="sec152" class="section">12.11  Vocabulary</h2>
<dl class="description"><dt class="dt-description"><span style="font-weight:bold">encode:</span></dt><dd class="dd-description"><a id="hevea_default692"/>
To represent one set of values using another set of values, by constructing a mapping between them.</dd><dt class="dt-description"><span style="font-weight:bold">class variable:</span></dt><dd class="dd-description"><a id="hevea_default693"/>
A variable declared within a class as <code><span style="color:blue">static</span></code>.
There is only one copy of a class variable, no matter how many objects there are.</dd><dt class="dt-description"><span style="font-weight:bold">sequential search:</span></dt><dd class="dd-description"><a id="hevea_default694"/>
An algorithm that searches array elements, one by one, until a target value is found.</dd><dt class="dt-description"><span style="font-weight:bold">binary search:</span></dt><dd class="dd-description"><a id="hevea_default695"/>
An algorithm that searches a sorted array by starting in the middle, comparing and element to the target, and eliminating half of the remaining elements.</dd></dl>
<h2 id="sec153" class="section">12.12  Exercises</h2>
<p>The code for this chapter is in the <span style="font-family:monospace">ch12</span> directory of <span style="font-family:monospace">ThinkJavaCode</span>.
See page <a href="/thinkjava/preface.html#code">??</a> for instructions on how to download the repository.
Before you start the exercises, we recommend that you compile and run the examples.</p><div class="theorem"><span style="font-weight:bold">Exercise 1</span>  <em>
Encapsulate the deck-building code from Section </em><a href="#cardarray"><em>12.6</em></a><em> in a method called <code>makeDeck</code> that takes no parameters and returns a fully-populated array of <code>Card</code>s.
</em></div><div class="theorem"><span style="font-weight:bold">Exercise 2</span>  <em>
In some card games, Aces are ranked higher than Kings.
Modify the <code>compareTo</code> method to implement this ordering.
</em></div><div class="theorem"><span style="font-weight:bold">Exercise 3</span>  <em>
In Poker a “flush” is a hand that contains five or more cards of the same suit.
A hand can contain any number of cards.</em><p><a id="hevea_default696"/></p><ol class="enumerate" type="1"><li class="li-enumerate"><em>Write a method called <code>suitHist</code> that takes an array of cards as a parameter and that returns a histogram of the suits in the hand.
Your solution should only traverse the array once.</em></li><li class="li-enumerate"><em>Write a method called <code>hasFlush</code> that takes an array of cards as a parameter and returns <span style="color:blue"><code>true</code></span> if the hand contains a flush (and <span style="color:blue"><code>false</code></span> otherwise).</em></li></ol></div><div class="theorem"><span style="font-weight:bold">Exercise 4</span>  <p><em>Working with cards is more interesting if you can display them on the screen.
If you have not already read Appendix </em><a href="/thinkjava/appendix-b.html#graphics"><em>B</em></a><em> about 2D graphics, you should read it before working on this exercise.
In the code directory for this chapter, <span style="font-family:monospace">ch12</span>, you will find:</em></p><ul class="itemize"><li class="li-itemize"><em><span style="font-family:monospace">cardset-oxymoron</span>: A directory containing images of playing cards.</em></li><li class="li-itemize"><em><span style="font-family:monospace">CardTable.java</span>: A sample program that demonstrates how to read and display images.</em></li></ul><p><a id="hevea_default697"/></p><p><em>This code demonstrates the use of a 2D array, specifically an array of images.
The declaration looks like this:</em></p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><em><span style="color:blue">private</span> Image[][] images;</em></td></tr>
</table><p><em>The variable <code>images</code> refers to a 2D array of <code>Image</code> objects, which are defined in the <code>java.awt</code> package.
Here’s the code that creates the array itself:</em></p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><em>images = <span style="color:blue">new</span> Image[14][4];</em></td></tr>
</table><p><em>The array has 14 rows (one for each rank plus an unused row for rank 0) and 4 columns (one for each suit).
Here’s the loop that populates the array:</em></p><table class="lstframe" style="padding:1ex;background-color:#FAFAFA;"><tr><td class="lstlisting"><em>String cardset = <span style="color:#B20000">"cardset-oxymoron"</span>;
String suits = <span style="color:#B20000">"cdhs"</span>;

<span style="color:blue">for</span> (<span style="color:blue">int</span> suit = 0; suit &lt;= 3; suit++) {
    <span style="color:blue">char</span> c = suits.charAt(suit);

    <span style="color:blue">for</span> (<span style="color:blue">int</span> rank = 1; rank &lt;= 13; rank++) {
        String s = String.format(<span style="color:#B20000">"%s/%02d%c.gif"</span>,
                                 cardset, rank, c);
        images[rank][suit] = <span style="color:blue">new</span> ImageIcon(s).getImage();
    }
}</em></td></tr>
</table><p><em>The variable <code>cardset</code> contains the name of the directory that contains the image files.
<code>suits</code> is a string that contains the single-letter abbreviations for the suits.
These strings are used to assemble <code>s</code>, which contains the filename for each image.
For example, when <code>rank=1</code> and <code>suit=2</code>, the value of <code>s</code> is <span style="color:#B20000"><code>"cardset-oxymoron/01h.gif"</code></span>, which is an image of the Ace of Hearts.</em></p><p><em>The last line of the loop reads the image file, extracts an <code>Image</code> object, and assigns it to a location in the array, as specified by the indexes <code>rank</code> and <code>suit</code>.
For example, the image of the Ace of Hearts is stored in row 1, column 2.</em></p><p><em>If you compile and run <span style="font-family:monospace">CardTable.java</span>, you should see images of a deck of cards laid out on a green table.
You can use this class as a starting place to implement your own card games.</em></p></div>
</div>
</div>

</div>
    
</div>
{% endblock %}

{% block toc %}
<li class="has-dropdown"><a href="/thinkjava/chapter12.html">Arrays of objects</a>
    <ul class="dropdown">
      <li><a href="/thinkjava/chapter12.html#sec142">Card objects</a>
      </li>
      <li><a href="/thinkjava/chapter12.html#sec143">Card toString</a>
      </li>
      <li><a href="/thinkjava/chapter12.html#sec144">Class variables</a>
      </li>
      <li><a href="/thinkjava/chapter12.html#sec145">The compareTo method</a>
      </li>
      <li><a href="/thinkjava/chapter12.html#sec146">Cards are immutable</a>
      </li>
      <li><a href="/thinkjava/chapter12.html#sec147">Arrays of cards</a>
      </li>
      <li><a href="/thinkjava/chapter12.html#sec148">Sequential search</a>
      </li>
      <li><a href="/thinkjava/chapter12.html#sec149">Binary search</a>
      </li>
      <li><a href="/thinkjava/chapter12.html#sec150">Tracing the code</a>
      </li>
      <li><a href="/thinkjava/chapter12.html#sec151">Recursive version</a>
      </li>
      <li><a href="/thinkjava/chapter12.html#sec152">Vocabulary</a>
      </li>
      <li><a href="/thinkjava/chapter12.html#sec153">Exercises</a>
      </li>
    </ul>
  </li>
  
{% endblock %}

{% block title%}Arrays of objects | Think Java | Trinket{% endblock %}
