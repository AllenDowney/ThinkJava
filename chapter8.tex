\documentclass[12pt]{book}

\newcommand{\thetitle}{Think Java: How to Think Like a Computer Scientist}
\title{\thetitle}

\newcommand{\theauthors}{Allen Downey and Chris Mayfield}
\author{\theauthors}

\newcommand{\theversion}{Version 6.0 Draft -- \today}
\date{\theversion}

\usepackage{geometry}
\geometry{
    width=5.5in,
    height=8.5in,
    hmarginratio=3:2,
    vmarginratio=1:1,
    includehead=true,
    headheight=15pt
}

% paragraph spacing
\setlength{\parindent}{0pt}                      % 17.62482pt
\setlength{\parskip}{12pt plus 4pt minus 4pt}    % 0.0pt plus 1.0pt
\linespread{1.05}
\def\arraystretch{1.5}

% list spacing
\setlength{\topsep}{5pt plus 2pt minus 3pt}      % 10.0pt plus 4.0pt minus 6.0pt
\setlength{\partopsep}{-6pt plus 2pt minus 2pt}  %  3.0pt plus 2.0pt minus 2.0pt
\setlength{\itemsep}{0pt}                        %  5.0pt plus 2.5pt minus 1.0pt

% these are copied from tex/latex/base/book.cls
% all I changed is afterskip
\makeatletter
\renewcommand{\section}{\@startsection {section}{1}{\z@}%
    {-3.5ex \@plus -1ex \@minus -.2ex}%
    {0.7ex \@plus.2ex}%
    {\normalfont\Large\bfseries}}
\renewcommand\subsection{\@startsection{subsection}{2}{\z@}%
    {-3.25ex\@plus -1ex \@minus -.2ex}%
    {0.3ex \@plus .2ex}%
    {\normalfont\large\bfseries}}
\renewcommand\subsubsection{\@startsection{subsubsection}{3}{\z@}%
    {-3.25ex\@plus -1ex \@minus -.2ex}%
    {0.3ex \@plus .2ex}%
    {\normalfont\normalsize\bfseries}}
\makeatother

% table of contents vertical spacing
\usepackage{tocloft}
\setlength\cftparskip{8pt plus 4pt minus 4pt}

% The following line adds a little extra space to the column
% in which the Section numbers appear in the table of contents
\makeatletter
\renewcommand{\l@section}{\@dottedtocline{1}{1.5em}{3.0em}}
\makeatother

% customize page headers
\usepackage{fancyhdr}
\pagestyle{fancyplain}
\renewcommand{\chaptermark}[1]{\markboth{Chapter \thechapter ~~ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection ~~ #1}}
\lhead[\fancyplain{}{\bfseries\thepage}]%
      {\fancyplain{}{\bfseries\rightmark}}
\rhead[\fancyplain{}{\bfseries\leftmark}]%
      {\fancyplain{}{\bfseries\thepage}}
\cfoot{}
%\rfoot{\textcolor{gray}{\tiny ThinkJava Draft \today}}

% balanced index with TOC entry
\usepackage{makeidx}
\makeindex
%\usepackage[totoc]{idxlayout}

% automatically index glossary terms
\newcommand{\term}[1]{%
\index{#1}
\item[#1:]}
% TODO: doesn't work with plastex
%\newcommand{\term}[1]{\item[#1:]}

% where to find graphics
\usepackage{graphicx}
%\graphicspath{{figs/}}

%% tweak spacing of figures and captions
%\usepackage{floatrow}
%\usepackage{caption}
%\captionsetup{
%    font=small,
%    labelformat=empty,
%    justification=centering,
%    skip=4pt
%}

% format end of chapter excercises
\usepackage{amsmath}
\usepackage{amsthm}
\newtheoremstyle{exercise}
  {12pt}        % space above
  {12pt}        % space below
  {}            % body font
  {}            % indent amount
  {\bfseries}   % head font
  {}            % punctuation
  {12pt}        % head space
  {}            % custom head
\theoremstyle{exercise}
\newtheorem{exercise}{Exercise}[chapter]

% colors for code listings and output
\usepackage{xcolor}
\definecolor{bgcolor}{HTML}{FAFAFA}
\definecolor{comment}{HTML}{007C00}
\definecolor{keyword}{HTML}{0000FF}
\definecolor{strings}{HTML}{B20000}

% syntax highlighting in code listings
\usepackage{textcomp}
\usepackage{listings}
\lstset{
    language=java,
    basicstyle=\ttfamily,
    backgroundcolor=\color{bgcolor},
    commentstyle=\color{comment},
    keywordstyle=\color{keyword},
    stringstyle=\color{strings},
    columns=fullflexible,
    keepspaces=true,
    showstringspaces=false,
    upquote=true,
    aboveskip=\parskip,
    belowskip=\parskip
}

% code listing environments
\lstnewenvironment{code}
{\minipage{\linewidth}}
{\endminipage}
\lstnewenvironment{stdout}
{\lstset{commentstyle=,keywordstyle=,stringstyle=}\minipage{\linewidth}}
{\endminipage}

% pdf hyperlinks, table of contents, and document properties
\usepackage[pdftex]{hyperref}
\hypersetup{%
  pdftitle={\thetitle},
  pdfauthor={\theauthors},
  pdfsubject={\theversion},
  pdfkeywords={},
  bookmarksopen=false,
  colorlinks=true,
  citecolor=black,
  filecolor=black,
  linkcolor=black,
  urlcolor=blue
}

% inline syntax formatting
\newcommand{\java}[1]{\lstinline{#1}} %\end{
%\newcommand{\java}[1]{\verb"#1"}
%\newcommand{\java}[1]{{\tt #1}}

\begin{document}
\setcounter{chapter}{7}

\chapter{Strings and things}
\label{strings}

\index{object}
\index{class!String}
\index{method!string}

In Java and other object-oriented languages, an {\bf object} is a collection of data that provides a set of methods.
These methods operate on the object, performing computations and sometimes modifying the its data.
Strings are objects, and their data is a sequence of characters; that is,
letters, numbers, spaces, and symbols.
The {\tt String} class provides many methods for manipulating character data; we will explore some of them in this chapter.


\section{Characters}

\index{charAt}
\index{char}
\index{type!char}

The first method we will look at is {\tt charAt}, which extracts a character from a {\tt String}.
It returns a \java{char}, a primitive type that can store individual characters (as opposed to strings of them).

\begin{code}
    String fruit = "banana";
    char letter = fruit.charAt(1);
    System.out.println(letter);
\end{code}

The expression {\tt fruit.charAt(1)} means we invoke the {\tt charAt} method on the object referenced by {\tt fruit}.
The argument {\tt 1} means that we want to know the letter at position 1.
The result is a character, which is stored in a \java{char} variable named {\tt letter}.
When you print the value of {\tt letter}, you might be surprised:

\begin{stdout}
a
\end{stdout}

Unless you already think like a computer scientist, the letter {\tt a} is not the {\em first} letter of {\tt "banana"}.
For technical reasons, computer scientists start counting from zero.
The 0th (``zeroeth'') letter of {\tt "banana"} is the {\tt b}.
The 1th letter (``oneth'') is {\tt a} and the 2th (``twooth'') letter is {\tt n}.
So if you want the first letter of a string, you have to pass 0 as the argument:

\begin{code}
    char letter = fruit.charAt(0);
\end{code}

\index{quote}
\index{double-quote}
\index{value!char}

Character literals appear in single quotes like \java{'c'}.
Unlike string literals, which appear in double quotes, characters may only contain a single letter or symbol.

\begin{code}
    char letter = 'c';
    if (letter == 'd') {
        System.out.println('?');
    }
\end{code}

Characters work much like the other primitive types we have seen.
You can use them in arithmetic, decisions, loops, and so forth.

\begin{code}
    System.out.print("Roman alphabet: ");
    for (char c = 'A'; c <= 'Z'; c++) {
        System.out.print(c);
    }
    System.out.println();
\end{code}

\index{Unicode}

Java uses {\bf Unicode} for its character set (see \url{http://unicode.org/}) so that strings may store text in any language.
Unicode supports alphabets like Cyrillic and Greek, and left-to-right scripts like Arabic and Hebrew.
%Regardless, both the data type \java{char} and the method {\tt charAt} work the same.

\begin{code}
    System.out.print("Greek alphabet: ");
    for (int i = 913; i <= 937; i++) {
        System.out.print((char) i);
    }
    System.out.println();
\end{code}

This example demonstrates how you can convert a Unicode ``code unit'',
represented as an integer, to a \java{char} using a cast operator.


\section{String traversal}
\label{traverse}

\index{traverse}

A common task with strings is to start at the beginning, select each character in turn, do some computation with it, and continue until the end.
This pattern is called a {\bf traversal}.
A natural way to traverse a string is with a \java{for} statement:

\begin{code}
    for (int i = 0; i < fruit.length(); i++) {
        char letter = fruit.charAt(i);
        System.out.println(letter);
    }
\end{code}

\index{loop variable}
\index{variable!loop}
\index{index}

This loop prints each character of the string {\tt fruit} on a line by itself.
The name of the loop variable is {\tt i}, which stands for {\bf index}; an
index is an integer that indicates the position of a character.
Notice that the condition is {\tt i < fruit.length()}, which means that when {\tt i} is equal to the length of the string, the condition is \java{false} and the loop terminates.
%The last character we access is the one with the index {\tt fruit.length() - 1}.

\index{String!length}
\index{length!String}

The {\tt length} method returns the number of characters in the string.
It takes no arguments and returns an integer; the length of \java{"banana"} is 6.
%Notice that it is legal to have a variable with the same name as a method (although it can be confusing for human readers).
To find the last letter of a string, you might be tempted to try something like:

\begin{code}
    int length = fruit.length();
    char last = fruit.charAt(length);      // WRONG!
\end{code}

This code compiles and runs, but it causes a runtime error.
The reason is that there is no sixth letter in {\tt "banana"}.
Since we started counting at 0, the 6 letters are indexed from 0 to 5.
To get the last character, you have to subtract 1 from {\tt length}.

\begin{code}
    char last = fruit.charAt(length - 1);  // CORRECT
\end{code}

Many string traversals involve reading one string and creating another.
For example, to reverse the characters of a string we simply add one character at a time:

\begin{code}
    public static String reverse(String s) {
        String r = "";
        for (int i = s.length()-1; i >= 0; i--) {
            r = r + s.charAt(i);
        }
        return r;
    }
\end{code}

\index{empty string}

The initial value of \java{r} is \java{""}, which is the {\bf empty string}.
The loop traverses the letters of \java{s} in reverse order.
Each time through the loop, it creates a new string and assigns it to \java{r}.
When the loop exits, \java{r} contains the letters from {\tt s} in reverse order.
So the result of \java{reverse("banana")} is \java{"ananab"}.

%\section{Looping and counting}
%\label{loopcount}

\index{loop!counting}
\index{traverse!counting}

Other string traversals involve looping and counting.
The following method counts the number of times a given character appears in a string.
For example, \java{numberOf("banana", 'a')} returns 3.

\begin{code}
    public static int numberOf(String s, char c) {
        int count = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == c) {
                count++;
            }
        }
        return count;
    }
\end{code}

\index{counter}

This method demonstrates a common idiom, called a {\bf counter}.
The variable {\tt count} is initialized to zero and then incremented each time we find an {\tt 'a'}.
%To {\bf increment} is to increase by one; it is the opposite of {\bf decrement}.
% TODO: check whether we define increment and decrement somewhere
When we exit the loop, {\tt count} contains the result: the total number of a's.


\section{Substrings}

The {\tt substring} method returns new string that copies letters from an existing string, beginning at the given index.
\begin{itemize}
\item \java{fruit.substring(0)} returns \java{"banana"}
\item \java{fruit.substring(2)} returns \java{"nana"}
\item \java{fruit.substring(6)} returns \java{""}
\end{itemize}

As the last example shows, {\tt substring} returns the empty string if the argument is the length of the string.
To visualize how this method works, it helps to draw a picture:

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
b & a & n & a & n & a \\
\hline
0 & 1 & 2 & 3 & 4 & 5 \\
\hline
\end{tabular}
\end{center}

Like many string methods, {\tt substring} is overloaded.
If it's invoked with two argments, they are treated as a start and end index:

\begin{itemize}
\item \java{fruit.substring(0, 3)} returns \java{"ban"}
\item \java{fruit.substring(2, 5)} returns \java{"nan"}
\item \java{fruit.substring(6, 6)} returns \java{""}
\end{itemize}

Notice that the character indicated by the end index is not included.
%In other words, substrings are for the interval $[beg, end)$.
One way to remember this detail is to think about how loops work.
Here is a simplified version of \java{substring(2, 5)}:

\begin{code}
    String str = "banana";
    int beg = 2;
    int end = 5;
    String sub = "";
    for (int i=beg; i < end; i++) {
        sub = sub + str.charAt(i);
    }
    System.out.println(sub);  // prints "nan"
\end{code}

Because of \java{<}, the loop terminates when \java{i == end}.
Designing substring this way simplifies many common operations.
For example, to select a substring with length \java{len}, starting at index \java{i}, you could write \java{fruit.substring(i, i+len)}.

% ABD: I generally agree that operators should have spaces around
% them, but make an exception for readable short expressions like
% length+1 and simple initializers in for loops.  S'okay?

\section{Bounds checking}
\label{StringIndexOutOfBounds}

\index{runtime error}
\index{error!runtime}

\index{exception}
\index{stack trace}

%TODO: is this the first use of exception?!

If you call the {\tt charAt} method with an index that is negative or greater than {\tt length - 1}, you will get an {\bf exception}.
%The same is true when calling {\tt substring} with invalid start or end indexes.
When that happens, Java prints an error message and terminates the program.

For example, notice the error in the {\tt getLastLetter} method below.
It should be looking at \java{index-1} instead of \java{index}.

\begin{code}
public class BadString {
    public static void main(String[] args) {
        processWord("banana");
    }
    public static void processWord(String s) {
        char c = getLastLetter(s);
        System.out.println(c);
    }
    public static char getLastLetter(String s) {
        int index = s.length();
        char c = s.charAt(index);  // WRONG!
        return c;
    }
}
\end{code}

When you run the {\tt BadString} program, Java prints the following message.

\begin{small}
\begin{stdout}
Exception in thread "main" java.lang.StringIndexOutOfBoundsException:
String index out of range: 6
	at java.lang.String.charAt(String.java:658)
	at BadString.getLastLetter(BadString.java:14)
	at BadString.processWord(BadString.java:8)
	at BadString.main(BadString.java:4)
\end{stdout}
\end{small}

\index{stack trace}

This information is called a {\bf stack trace}, which shows the methods that were running when the error occurred.
The stack trace can be difficult to read, but it contains a lot of useful information.
For one, it tells you that the index 6 was out of range.

More importantly, it shows the line of code where the error occurred.
It may be helpful to read the stack trace bottom-up.
On line~4, {\tt main} called {\tt processWord}, which on line~8 called {\tt getLastLetter}, which on line~14 called {\tt charAt}.
The actual error occurred on line 658 of String.java, which is in the source code for the {\tt String} class itself.

Although possible, it's unlikely that the Java library code has mistakes that cause programs to crash.
When reading stack diagrams, look for the top line that refers to a file you wrote.
In this example, {\tt BadString.java:14} is the most useful debugging information.


\section{The indexOf method}
\index{indexOf}

At first glance, {\tt indexOf} is the inverse of {\tt charAt}.
The {\tt charAt} method takes an index and returns the character at that index.
The {\tt indexOf} method takes a character and finds an index where that character appears.

\begin{code}
    String fruit = "banana";
    int index = fruit.indexOf('a');
\end{code}

This example finds the index of the letter \java{'a'} in the string.
But the letter appears three times, so it's not obvious what {\tt indexOf} should do.
According to the documentation, it returns the index of the {\em first} appearance.

To find subsequent appearances, you can use another version of {\tt indexOf}, which takes a second argument that indicates where in the string to start looking.
%For an explanation of this kind of overloading, see Section~\ref{overloading}.

\begin{code}
    int index = fruit.indexOf('a', 2);
\end{code}

This code starts at the third letter (the first \java{'n'}) and finds the next \java{'a'}, which is at index 3.
If the letter happens to appear at the starting index, the starting index is the answer.
So \java{fruit.indexOf('a', 5)} returns 5.

There are subtle differences between {\tt charAt} and {\tt indexOf}:
\java{charAt} throws an exception if the index is out of range;
{\tt indexOf} returns the value {\tt -1} if the character does not appear in the string.

You can also use {\tt indexOf} to search for an entire string.
For example, \java{fruit.indexOf("nan")} returns 2 and \java{fruit.indexOf("zzz")} returns -1.


\section{String comparison}
\label{immutable}
\label{incomparable}

\index{toUpperCase}
\index{toLowerCase}
\index{immutable}

As you read the documentation of the {\tt String} methods, you might notice {\tt toUpperCase} and {\tt toLowerCase}.
These methods are often a source of confusion, because it sounds like they have the effect of changing (or mutating) an
existing string.
Actually, neither these methods nor any others change a string, because strings are {\bf immutable}.

When you invoke {\tt toUpperCase} on a {\tt String}, you get a {\em new} {\tt String} as a return value.
For example:

\begin{code}
    String name = "Alan Turing";
    String upperName = name.toUpperCase();
\end{code}

\index{Turing, Alan}

After the second line is executed, {\tt upperName} contains the value \java{"ALAN TURING"}.
But {\tt name} still contains \java{"Alan Turing"} as before.

\index{equals}
\index{compareTo}

It is often useful to compare strings to see if they are the same, or to see which comes first in alphabetical order.
It would be nice if we could use the comparison operators, like {\tt ==} and {\tt >}, but we can't.
To compare {\tt String}s, we have to use the {\tt equals} and {\tt compareTo} methods.

\begin{code}
    String name1 = "Alan Turing";
    String name2 = "Ada Lovelace";
    if (name1.equals(name2)) {
        System.out.println("The names are the same.");
    }
\end{code}

The syntax here may seem awkward.
To compare two strings, you have to invoke a method on one of them and pass the other as an argument.
The return value from {\tt equals} is straightforward: \java{true} if the strings contain the same characters, and \java{false} otherwise.

\begin{code}
    int diff = name1.compareTo(name2);
    if (diff == 0) {
        System.out.println("The names are the same.");
    } else if (diff < 0) {
        System.out.println("name1 comes before name2.");
    } else if (diff > 0) {
        System.out.println("name2 comes before name1.");
    }
\end{code}

The return value from {\tt compareTo} is the {\em difference} between the first characters in the strings that differ.
If the strings are equal, their difference is 0.
If the first string (the one on which the method is invoked) comes first in the alphabet, the difference is negative.
Otherwise, the difference is positive.

In the example above, the return value is positive 8, because the second letter of \java{"Ada"} comes before the second letter of \java{"Alan"} by 8 letters.


\section{Character arithmetic}

% ABD: I propose that we kill this section.  The first example demonstrates
% a bad solution, and the second example is string concatentation,
% not character arithmetic.

% Instead, let's have a section that introduces the Character class
% and some of the methods it provides.

\index{arithmetic!char}

Like the \java{compareTo} method, you too can do arithmetic with characters.
For example, if \java{letter} refers to a lowercase letter, \java{letter - 'a'} yields its position in the alphabet (keeping in mind that 'a' is the zeroeth letter of the alphabet and 'z' is the 25th).

This technique is useful for converting between characters that contain numbers (e.g., \java{'0'}, \java{'1'}, \java{'2'}) and the corresponding integers.
For example, try this code:

\begin{code}
    char letter = '3';
    int x = (int) letter;
    System.out.println(x);
\end{code}

You might expect the value 3, but instead you get 51, which is the Unicode value for the character \java{'3'}.
%Remember, not all languages in the world use Arabic numerals like English does.
To convert '3' to the corresponding integer value, you can subtract \java{'0'}:

\begin{code}
    int x = (int) (letter - '0');
\end{code}

In both of these examples the typecast \java{(int)} is not strictly necessary, since Java will do the conversion automatically.

Since this conversion can be a bit ugly, it is preferable to use the {\tt digit} method in the {\tt Character} class.
For example, this code converts {\tt letter} to the corresponding digit, interpreting it as a base 10 number.

\begin{code}
    int x = Character.digit(letter, 10);
\end{code}

Another use for character arithmetic is to loop through the letters of the alphabet in order.
For example, in Robert McCloskey's book {\em Make Way for Ducklings}, the names of the ducklings form an Abecedarian series: Jack, Kack, Lack, Mack, Nack, Ouack, Pack and Quack.
Here is a loop that prints these names in order:

\begin{code}
    char letter = 'J';
    while (letter <= 'Q') {
        System.out.println(letter + "ack");
        letter++;
    }
\end{code}

Notice that in addition to the arithmetic operators, we can also use the conditional operators on characters.
The output of this program is:

\begin{stdout}
Jack
Kack
Lack
Mack
Nack
Oack
Pack
Qack
\end{stdout}

Of course, that's not quite right because it misspelled ``Ouack'' and ``Quack.''
As an exercise, you can modify the program to correct this error.


\section{Wrapper classes}

% ABD: Have we mentioned byte, short, or long?  double?

In the previous section, we introduced the {\tt Character} class.
There are similar classes for the other primitive data types: {\tt Boolean}, {\tt Byte}, {\tt Short}, {\tt Integer}, {\tt Long}, {\tt Float}, and {\tt Double}.
These classes are in the {\tt java.lang} package, so can use them without explicitly importing them.

Each of these classes defines constants \java{MIN_VALUE} and \java{MAX_VALUE}.
For example, \java{Integer.MIN_VALUE} is the \java{int} $-2147483648$, and \java{Integer.MAX_VALUE} is $2147483647$.
Rather than remember these unusual numbers, you can simply refer to the built-in constants.

Another purpose of wrapper classes is converting values to and from Strings.
For example, we can convert a string to an integer using the \java{parseInt} method:

\begin{code}
String str = "12345";
int num = Integer.parseInt(str);
\end{code}

You will find similar methods in the other wrapper classes, for example, \java{Double.parseDouble}.

These wrapper classes also provide \java{toString}, which returns a string
representation of a number:

\begin{code}
int num = 12345;
String str = Integer.toString(num);
\end{code}

% ABD: There is a jump here from talking about wrapper classes to talking
% about instances of those classes.  I think we don't want to do the
%second part yet.

%As a convenience, Java will automatically convert primitive values to/from their wrapper types.
%We will see later why this code is inefficient.

%\begin{code}
%Integer i = 12345;
%Double d = 123.45;
%\end{code}

%For now, it's important to note that {\tt i} and {\tt d} are references to %objects.
%In other words, the values {\tt 12345} and {\tt 123.45} have been wrapped %inside objects.
%Like strings, these objects have a variety of methods that can be applied.
%Refer to the documentation for {\tt Integer} and {\tt Double} for more details.


\section{Vocabulary}

\begin{description}

\term{object}
A collection of related data that comes with a set of methods that operate on it.

\term{Unicode}
A standard for representing characters in most of the world's languages.

\term{traverse}
To iterate through the elements of a set performing a similar operation on each.

\term{index}
A variable or value used to indicate one of the members of a collection, like a character from a string.

\term{empty string}
The string \java{""}, what contains no characters and has a length of zero.

\term{counter}
A variable used to count something, usually initialized to zero and then incremented.

\term{exception}
A runtime error like ArithmeticException or IndexOutOfBoundsException.

% ABD: have we seen these exceptions yet?

\term{stack trace}
An error message that shows the state of a program when an exception occurs.

\term{immutable}
An object that, once created, cannot be modified.
Strings are immutable.

\end{description}


\section{Exercises}

\begin{exercise}

\index{encapsulation}
\index{generalization}

Encapsulate the code in Section~\ref{loopcount} into a method named
{\tt countLetters}, and generalize it so that it accepts the
string and the letter as arguments.
Then rewrite the method so that it uses
{\tt indexOf} to locate the a's, rather than checking
the characters one by one.

\end{exercise}

\begin{exercise}
The purpose of this exercise is to review encapsulation
and generalization.

\begin{enumerate}

\item Encapsulate the following code fragment, transforming it
into a method that takes a String as an argument and
returns the final value of {\tt count}.

\item In a sentence or two, describe what the resulting method does
(without getting into the details of how).

\item Now that you have generalized the code
so that it works on any String, what could you do to
generalize it more?

\end{enumerate}

\begin{code}
    String s = "((3 + 7) * 2)";
    int len = s.length();

    int i = 0;
    int count = 0;

    while (i < len) {
        char c = s.charAt(i);

        if (c == '(') {
           count = count + 1;
        } else if (c == ')') {
           count = count - 1;
        }
        i = i + 1;
    }

    System.out.println(count);
\end{code}
\end{exercise}


\begin{exercise}

The point of this exercise is to explore Java types and fill in some of the details that aren't covered in the chapter.

\begin{enumerate}

% ABD: have we defined concatenation?

\item Create a new program named {\tt Test.java} and write
a {\tt main} method that contains expressions that combine
various types using the {\tt +} operator.  For example, what
happens when you ``add'' a {\tt String} and a {\tt char}?
Does it perform addition or concatenation?   What is the type
of the result? (How can you determine the type of the result?)

\item Make a bigger copy of the following table and fill it in.  At the
intersection of each pair of types, you should indicate whether it is
legal to use the {\tt +} operator with these types, what operation is
performed (addition or concatenation), and what the type of the result
is.

\begin{tabular}{|l|l|l|l|l|} \hline
        &  boolean  &  char  &  int  &  String \\ \hline
boolean &           &        &       &         \\ \hline
char    &           &        &       &         \\ \hline
int     &           &        &       &         \\ \hline
String  &           &        &       &         \\ \hline
\end{tabular}

\item Think about some of the choices the designers of Java
made when they filled in this table.  How many of the entries
seem unavoidable, as if there were no other choice?
How many seem like arbitrary choices from several equally
reasonable possibilities?  How many seem problematic?

\item Here's a puzzler: normally, the statement {\tt x++} is exactly
  equivalent to {\tt x = x + 1}.  But if {\tt x} is a {\tt char}, it's
  not!  In that case, {\tt x++} is legal, but {\tt x = x + 1} causes
  an error.  Try it out and see what the error message is, then see if
  you can figure out what is going on.

\end{enumerate}
\end{exercise}


\begin{exercise}

What is the output of this program?  Describe in a sentence
what {\tt mystery} does (not how it works).

\begin{code}
public class Mystery {

    public static String mystery(String s) {
        int i = s.length() - 1;
        String total = "";

        while (i >= 0 ) {
            char ch = s.charAt(i);
            System.out.println(i + "     " + ch);

            total = total + ch;
            i--;
        }
        return total;
    }

    public static void main(String[] args) {
        System.out.println(mystery("Think Java"));
    }
}
\end{code}

\end{exercise}


\begin{exercise}
A friend of yours shows you the following method and
explains that if {\tt number} is any two-digit number, the program
will output the number backwards.  He claims that if {\tt number} is
17, the method will output {\tt 71}.

Is he right?  If not, explain what the program actually does and
modify it so that it does the right thing.

\begin{code}
     int number = 17;
     int lastDigit = number%10;
     int firstDigit = number/10;
     System.out.println(lastDigit + firstDigit);
\end{code}

\end{exercise}

\begin{exercise}
What is the output of the following program?

\begin{code}
public class Enigma {

    public static void enigma(int x) {
        if (x == 0) {
            return;
        } else {
            enigma(x/2);
        }
        System.out.print(x%2);
    }

    public static void main(String[] args) {
        enigma(5);
        System.out.println("");
    }
}
\end{code}

Explain in 4-5 words what the method {\tt enigma} really does.
\end{exercise}


\begin{exercise}
\label{palindrome}

\begin{enumerate}

\item Create a new program named {\tt Palindrome.java}.

\item Write a method named {\tt first}
that takes a String and returns the first letter, and one named
{\tt last} that returns the last letter.

\item Write a method named {\tt middle} that takes a String and
returns a substring that contains everything {\em except} the
first and last characters.

Hint: read the documentation of the {\tt substring} method in
the {\tt String} class.
Run a few tests to make sure you understand how {\tt substring} works
before you try to write {\tt middle}.

What happens if you invoke {\tt middle} on a string that has only
two letters?  One letter?  No letters?

\item The usual definition of a palindrome is a word that reads the
same both forward and backward, like ``otto'' and
``palindromeemordnilap.''  An alternative way to define a property
like this is to specify a way of testing for the property.  For
example, we might say, ``a single letter is a palindrome, and a
two-letter word is a palindrome if the letters are the same, and
any other word is a palindrome if
the first letter is the same as the
last and the middle is a palindrome.''

Write a recursive method named {\tt isPalindrome} that takes
a {\tt String} and returns a boolean indicating whether the
word is a palindrome or not.

\item Once you have a working palindrome checker, look for ways
to simplify it by reducing the number of conditions you check.
Hint: it might be useful to adopt the definition that the empty
string is a palindrome.

\item On a piece of paper, figure out a strategy for checking
palindromes iteratively.  There are several possible approaches,
so make sure you have a solid plan before you start writing code.

\item Implement your strategy in a method called {\tt isPalindromeIter}.

\item Optional: Appendix~\ref{javaio} provides code for reading a list
of words from a file.  Read a list of words and print the palindromes.

\end{enumerate}
\end{exercise}


\begin{exercise}
\label{abecedarian}

A word is said to be ``abecedarian'' if the letters in the
word appear in alphabetical order.  For example, the following
are all 6-letter English abecedarian words.

\begin {quote}
abdest, acknow, acorsy, adempt, adipsy, agnosy, befist, behint,
beknow, bijoux, biopsy, cestuy, chintz, deflux, dehors, dehort,
deinos, diluvy, dimpsy
\end{quote}

\begin{enumerate}

\item Describe a process for checking whether a given word (String)
is abecedarian, assuming that the word contains only lower-case
letters.  Your process can be iterative or recursive.

\item Implement your process in a method called {\tt isAbecedarian}.

\end{enumerate}
\end{exercise}


\begin{exercise}
\label{dupledrome}
A dupledrome is a word that contains only double letters,
like ``llaammaa'' or ``ssaabb''.  I conjecture that there
are no dupledromes in common English use.  To test that
conjecture, I would like a program that reads
words from a file one at a time and checks them for
dupledromity.

Write a method called {\tt isDupledrome} that takes a String
and returns a boolean indicating whether the word is a dupledrome.
\end{exercise}



\begin{exercise}
\begin{enumerate}

\item A Caesar cypher works by taking each letter in a
string and adding 13 to it.  For example, 'a' becomes 'n' and 'b'
becomes 'o'.  The letters ``wrap around'' at the end, so 'z' becomes
'm'.

Write a method that takes a String and that returns a new String
containing the encoded version.  You should assume that the String
contains upper and lower case letters, and spaces, but no other
punctuation.  Lower case letters should be tranformed into other lower
case letters; upper into upper.  You should not encode the spaces.

\item Generalize the method so that instead of adding
13 to the letters, it adds any given amount.  Now you should be able
to encode things by adding 13 and decode them by adding -13.  Try it.

\end{enumerate}
\end{exercise}


\begin{exercise}

% ABD: We're killing GridWorld, right?

If you did the GridWorld exercises in Chapter~\ref{gridworld}, you
might enjoy this exercise.  The goal is to use trigonometry to get the
Bugs to chase each other.

Make a copy of {\tt BugRunner.java} named {\tt ChaseRunner.java} and
import it into your development environment.  Before you change
anything, check that you can compile and run it.

\begin{itemize}

\item Create two Bugs, one red and one blue.

\item Write a method called {\tt distance} that takes two Bugs
and computes the distance between them.  Remember that you can
get the x-coordinate of a Bug like this:

\begin{code}
    int x = bug.getLocation().getCol();
\end{code}

\item Write a method called {\tt turnToward} that takes two
Bugs and turns one to face the other.  HINT: use {\tt Math.atan2},
but remember that the result is in radians, so you have to
convert to degrees.  Also, for Bugs, 0 degress is North, not East.

\item Write a method called {\tt moveToward} that takes two
Bugs, turns the first to face the second, and then moves the
first one, if it can.

\item Write a method called {\tt moveBugs} that takes two Bugs
and an integer {\tt n}, and moves each Bug toward the other {\tt n}
times.  You can write this method recursively, or use a while loop.

\item Test each of your methods as you develop them.  When they are
  all working, look for opportunities to improve them.  For example,
  if you have redundant code in {\tt distance} and {\tt turnToward},
  you could encapsulate the repeated code in a method.

\end{itemize}

\end{exercise}


\end{document}
