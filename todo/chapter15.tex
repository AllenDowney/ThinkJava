\chapter{Object-oriented programming}
\label{chap13}

\section{Programming languages and styles}
\index{programming language}
\index{language!programming}
\index{programming style}
\index{object-oriented programming}
\index{functional programming}
\index{procedural programming}
\index{programming!object-oriented}
\index{programming!functional}
\index{programming!procedural}

There are many programming languages and almost as many
programming styles (sometimes called paradigms).
The programs we have written so far are {\bf procedural},
because the emphasis has been on specifying computational procedures.

Most Java programs are {\bf object-oriented}, which means that
the focus is on objects and their interactions.
Here are some of the characteristics of object-oriented programming:

\begin{itemize}

\item Objects often represent entities in the real world.
  In the previous chapter, creating the {\tt Deck} class
  was a step toward object-oriented programming.

\item The majority of methods are object methods (like the methods you
  invoke on {\tt Strings}) rather than class methods (like the {\tt Math}
  methods).  The methods we have written so far have
  been class methods.  In this chapter we write some object methods.

\item Objects are isolated from each other by limiting the ways they
  interact, especially by preventing them from accessing
  instance variables without invoking methods.

\item Classes are organized in family trees where
  new classes extend existing classes, adding new methods and
  replacing others.

\end{itemize}

In this chapter I translate the {\tt Card} program from the
previous chapter from procedural to object-oriented style.  You
can download the code from this chapter from
\url{http://thinkapjava.com/code/Card3.java}.


\section{Object methods and class methods}
\index{object method}
\index{method!object}
\index{class method}
\index{method!class}
\index{static}

There are two types of methods in Java, called {\bf class methods} and
{\bf object methods}.  Class methods are identified by the keyword {\tt
  static} in the first line.  Any method that does {\em not} have the
keyword {\tt static} is an object method.

Although we have not written object methods, we have invoked some.
Whenever you invoke a method ``on'' an object, it's an object method.
For example, {\tt charAt} and the other methods we invoked on {\tt String}
objects are all object methods.

Anything that can be written as a class method can also be written as an
object method, and vice versa.  But sometimes it is more natural to
use one or the other.

For example, here is {\tt printCard} as a class method:

\begin{code}
    public static void printCard(Card c) {
        System.out.println(ranks[c.rank] + " of " + suits[c.suit]);
    }
\end{code}

Here it is re-written as an object method:

\begin{code}
    public void print() {
        System.out.println(ranks[rank] + " of " + suits[suit]);
    }
\end{code}

Here are the changes:

\begin{enumerate}

\item I removed {\tt static}.

\item I changed the name of the method to be more idiomatic.

\item I removed the parameter.

\item Inside an object method you can refer to instance variables
as if they were local variables, so I changed {\tt c.rank} to {\tt rank},
and likewise for {\tt suit}.

\end{enumerate}

Here's how this method is invoked:

\begin{code}
    Card card = new Card(1, 1);
    card.print();
\end{code}

When you invoke a method on an object, that object becomes the {\bf
current object}, also known as {\tt this}.  Inside {\tt print},
the keyword {\tt this} refers to the card the method was invoked on.
\index{current object}
\index{object!current}
\index{this}


\section{The {\tt toString} method}
\index{toString}
\index{method!toString}

Every object type has a method called {\tt toString} that returns a
string representation of the object.  When you print an object using
{\tt print} or {\tt println}, Java invokes the object's {\tt toString}
method.

The default
version of {\tt toString} returns a string that contains the type
of the object and a unique identifier (see Section~\ref{printobject}).
When you define a new object
type, you can {\bf override} the default behavior by providing a
new method with the behavior you want.

For example, here is a {\tt toString} method for {\tt Card}:

\begin{code}
public String toString() {
    return ranks[rank] + " of " + suits[suit];
}
\end{code}

The return type is {\tt String}, naturally,
and it takes no parameters.  You can invoke {\tt toString} in
the usual way:

\begin{code}
    Card card = new Card(1, 1);
    String s = card.toString();
\end{code}

or you can invoke it indirectly through {\tt println}:

\begin{code}
    System.out.println(card);
\end{code}


\section{The {\tt equals} method}
\index{equals}
\index{method!equals}

In Section~\ref{equivalence} we talked about two notions of equality:
identity, which means that two variables refer to the same
object, and equivalence, which means that they have the same
value.

The {\tt ==} operator tests identity, but there is no operator
that tests equivalence, because what ``equivalence'' means
depends on the type of the objects.  Instead, objects provide
a method named {\tt equals} that defines equivalence.

Java classes provide {\tt equals} methods that do the right
thing.  But for user defined types the default behavior is the
same as identity, which is usually not what you want.

For {\tt Card}s we already have a method that checks equivalence:

\begin{code}
    public static boolean sameCard(Card c1, Card c2) {
        return (c1.suit == c2.suit && c1.rank == c2.rank);
    }
\end{code}

So all we have to do is rewrite is as an object method:

\begin{code}
    public boolean equals(Card c2) {
        return (suit == c2.suit && rank == c2.rank);
    }
\end{code}

Again, I removed {\tt static} and the first parameter, {\tt c1}.
Here's how it's invoked:

\begin{code}
    Card card = new Card(1, 1);
    Card card2 = new Card(1, 1);
    System.out.println(card.equals(card2));
\end{code}

Inside {\tt equals}, {\tt card} is the current object and {\tt card2}
is the parameter, {\tt c2}.  For methods that operate on two objects
of the same type, I sometimes use {\tt this} explicitly and call
the parameter {\tt that}:

\begin{code}
    public boolean equals(Card that) {
        return (this.suit == that.suit && this.rank == that.rank);
    }
\end{code}

I think it improves readability.


\section{Oddities and errors}
\index{method!object}
\index{method!class}
\index{overloading}

If you have object methods and class methods in the same class, it is
easy to get confused.  A common way to organize a class definition is
to put all the constructors at the beginning, followed by all the
object methods and then all the class methods.

You can have an object method and a class method with the same
name, as long as they do not have the same number and types of
parameters.  As with other kinds of overloading, Java decides
which version to invoke by looking at the arguments you provide.
\index{static}

Now that we know what the keyword {\tt static} means, you
have probably figured out that {\tt main} is a class method,
which means that there is no ``current object'' when it is invoked.
\index{current object}
\index{this}
\index{instance variable}
\index{variable!instance}
%
Since there is no current object in a class method, it is an
error to use the keyword {\tt this}.  If you try, you get
an error message like: ``Undefined variable: this.''

Also, you cannot refer to instance variables without using dot
notation and providing an object name.  If you try, you get a message
like ``non-static variable... cannot be referenced from a static
context.''  By ``non-static variable'' it means ``instance variable.''


\section{Inheritance}
\index{inheritance}

The language feature most often associated with
object-oriented programming is {\bf inheritance}.  Inheritance is the
ability to define a new class that is a modified version of an
existing class.
%
Extending the metaphor, the existing
class is sometimes called the {\bf parent} class and the new
class is called the {\bf child}.

The primary advantage of this feature is that you can add methods
and instance variables without modifying the
parent.  This is particularly useful for Java classes,
since you can't modify them even if you want to.

If you did the GridWorld exercises (Chapters~\ref{gridworld} and
\ref{gridworld2}) you have seen examples of inheritance:

\begin{code}
public class BoxBug extends Bug {
    private int steps;
    private int sideLength;

    public BoxBug(int length) {
        steps = 0;
        sideLength = length;
    }
}
\end{code}

{\tt BoxBug extends Bug} means that {\tt BoxBug} is a new
kind of {\tt Bug} that inherits the methods and instance
variables of {\tt Bug}.  In addition:

\begin{itemize}

\item The child class can have additional instance variables; in
this example, {\tt BoxBug}s have {\tt steps} and {\tt sideLength}.

\item The child can have additional methods; in this example,
{\tt BoxBugs} have an additional constructor that takes an integer
parameter.

\item The child can {\bf override} a method from the parent; in
this example, the child provides {\tt act} (not shown here),
which overrides the {\tt act} method from the parent.

\end{itemize}

If you did the Graphics exercises in Appendix~\ref{graphics}, you
saw another example:

\begin{code}
public class MyCanvas extends Canvas {

    public void paint(Graphics g) {
        g.fillOval(100, 100, 200, 200);
    }
}
\end{code}

{\tt MyCanvas} is a new kind of {\tt Canvas} with no new methods
or instance variables, but it overrides {\tt paint}.

If you didn't do either of those exercises, now is a good time!


\section{The class hierarchy}
\index{class hierarchy}
\index{Object}
\index{parent class}
\index{class!parent}

In Java, all classes extend some other class.  The most basic class is
called {\tt Object}.  It contains no instance variables, but it
provides the methods {\tt equals} and {\tt toString}, among others.

Many classes extend {\tt Object}, including almost all of the classes
we have written and many Java classes, like {\tt java.awt.Rectangle}.
Any class that does not explicitly name a parent inherits from {\tt
  Object} by default.

Some inheritance chains are much longer, though.  For example, {\tt
  javax.swing.JFrame} extends {\tt java.awt.Frame}, which extends {\tt
  Window}, which extends {\tt Container}, which extends {\tt
  Component}, which extends {\tt Object}.  No matter how long the
chain, {\tt Object} is the common ancestor of all classes.

The ``family tree'' of classes is called the class hierarchy.  {\tt Object}
usually appears at the top, with all the ``child'' classes below.  If
you look at the documentation of {\tt JFrame}, for example, you
see the part of the hierarchy that makes up {\tt JFrame}'s pedigree.


\section{Object-oriented design}
\index{object-oriented design}

Inheritance is a powerful feature.  Some programs that would be
complicated without it can be written concisely and simply
with it.  Also, inheritance can facilitate code reuse, since you can
customize the behavior of existing classes without having to modify
them.

On the other hand, inheritance can make programs hard to read.  When
you see a method invocation, it can be hard to figure out which method
gets invoked.

Also, many of the things that can be done with inheritance can
be done as well or better without it.
A common alternative is {\bf composition}, where new objects are
composed of existing objects, adding new capability without
inheritance.

Designing objects and the relationships among them is the topic
of {\bf object-oriented design}, which is beyond the scope of this
book.  But if you are interested, I recommend {\em Head First Design
Patterns}, published by O'Reilly Media.


\section{Glossary}

\begin{description}

\item[object method:]  A method that is invoked on an object,
and that operates on that object.
%, which is referred to by the keyword {\tt this} in Java
% or ``the current object'' in English.
Object methods do not have the keyword {\tt static}.

\item[class method:]  A method with the keyword {\tt static}.
Class methods are not invoked on objects and they do not have
a current object.

\item[current object:]  The object on which an object method
is invoked.  Inside the method,
the current object is referred to by {\tt this}.

%\item[{\tt this}:]  The keyword that refers to the current object.

\item[implicit:]  Anything that is left unsaid or implied.  Within
an object method, you can refer to the instance variables
implicitly (i.e., without naming the object).

\item[explicit:]  Anything that is spelled out completely.  Within
a class method, all references to the instance variables have to
be explicit.

\index{object method}
\index{class method}
\index{current object}
\index{this}
\index{implicit}
\index{explicit}

\end{description}


\section{Exercises}

\begin{exercise}

Download \url{http://thinkapjava.com/code/CardSoln2.java} and
\url{http://thinkapjava.com/code/CardSoln3.java}.

{\tt CardSoln2.java} contains solutions to the exercises
in the previous chapter.  It uses only class methods (except the
constructors).

{\tt CardSoln3.java} contains the same program, but most of the
methods are object methods.  I left {\tt merge} unchanged because
I think it is more readable as a class method.

Transform {\tt merge} into an object method,
and change {\tt mergeSort} accordingly.  Which version of
{\tt merge} do you prefer?

\end{exercise}


\begin{exercise}

Transform the following class method into an object method.

\begin{code}
public static double abs(Complex c) {
    return Math.sqrt(c.real * c.real + c.imag * c.imag);
}
\end{code}
\end{exercise}


\begin{exercise}
Transform the following object method into a class method.

\begin{code}
public boolean equals(Complex b) {
    return(real == b.real && imag == b.imag);
}
\end{code}
\end{exercise}


\begin{exercise}

This exercise is a continuation of Exercise~\ref{ex.rational}.
The purpose is to practice the syntax of object methods and
get familiar with the relevant error messages.

\begin{enumerate}

\item Transform the methods in the {\tt Rational} class
from class methods to object methods, and make the necessary
changes in {\tt main}.

\item Make a few mistakes.  Try invoking class methods as if
they were object methods and vice-versa.  Try to get a sense for
what is legal and what is not, and for the error messages that
you get when you mess up.

\item Think about the pros and cons of
class and object methods.  Which is more concise (usually)?
Which is a more natural way to express computation (or, maybe
more fairly, what kind of computations can be expressed most
naturally using each style)?

\end{enumerate}
\end{exercise}


\begin{exercise}
The goal of this exercise is to write a program that generates random
poker hands and classifies them, so that we can estimate the
probability of the various poker hands.  If you don't play poker, you
can read about it here
\url{http://en.wikipedia.org/wiki/List_of_poker_hands}.

\begin{enumerate}

\item Start with \url{http://thinkapjava.com/code/CardSoln3.java}
and make sure you can compile and run it.

\item Write a definition for a class named {\tt PokerHand}
that extends {\tt Deck}.

\item Write a {\tt Deck} method named {\tt deal} that creates
a PokerHand, transfers cards from the deck to the hand, and returns
the hand.

\item In {\tt main} use {\tt shuffle} and
{\tt deal} to generate and print four {\tt PokerHands} with
five cards each.  Did you get anything good?

\item Write a {\tt PokerHand} method called {\tt hasFlush}
returns a boolean indicating whether the
hand contains a flush.

\item Write a method called {\tt hasThreeKind} that
indicates whether the hand contains
Three of a Kind.

\item Write a loop that generates a few thousand hands and
checks whether they contain a flush or three of a kind.
Estimate the probability of getting one of those hands.
Compare your results to the probabilities at
\url{http://en.wikipedia.org/wiki/List_of_poker_hands}.

\item Write methods that test for the other poker hands.  Some
are easier than others.  You might find it useful to write some
general-purpose helper methods that can be used for more than one
test.

\item In some poker games, players get seven cards each, and
they form a hand with the best five of the seven.  Modify your
program to generate seven-card hands and recompute the probabilities.

\end{enumerate}
\end{exercise}


