\documentclass[12pt]{book}

\title{Think Java}
\author{Allen Downey and Chris Mayfield}

\newcommand{\thetitle}{Think Java: How to Think Like a Computer Scientist}
\newcommand{\theauthors}{Allen Downey and Chris Mayfield}
\newcommand{\theversion}{Version 6.0 Draft -- \today}

%%%% Both LATEX and PLASTEX

% balanced index with TOC entry
\usepackage{makeidx}
\makeindex

% automatically index glossary terms
\newcommand{\term}[1]{%
\index{#1}
\item[#1:]}

\usepackage{amsmath}
\usepackage{amsthm}

% format end of chapter excercises
\newtheoremstyle{exercise}
  {12pt}        % space above
  {12pt}        % space below
  {}            % body font
  {}            % indent amount
  {\bfseries}   % head font
  {}            % punctuation
  {12pt}        % head space
  {}            % custom head
\theoremstyle{exercise}
\newtheorem{exercise}{Exercise}[chapter]

\usepackage{graphicx}
%\graphicspath{{figs/}}

\usepackage{url}

\newif\ifplastex
\plastexfalse

\ifplastex
%%%% PLASTEX ONLY

\usepackage{localdef}

\newcount\anchorcnt
\newcommand*{\Anchor}[1]{%
  \@bsphack%
    \Hy@GlobalStepCount\anchorcnt%
    \edef\@currentHref{anchor.\the\anchorcnt}%
    \Hy@raisedlink{\hyper@anchorstart{\@currentHref}\hyper@anchorend}%
    \M@gettitle{}\label{#1}%
    \@esphack%
}

\newcommand{\java}[1]{\verb"#1"}
\newcommand{\stdout}[1]{\verb"#1"}

\else
%%%% LATEX ONLY

\usepackage{geometry}
\geometry{
    width=5.5in,
    height=8.5in,
    hmarginratio=3:2,
    vmarginratio=1:1,
    includehead=true,
    headheight=15pt
}

% paragraph spacing
\setlength{\parindent}{0pt}                      % 17.62482pt
\setlength{\parskip}{12pt plus 4pt minus 4pt}    % 0.0pt plus 1.0pt
\linespread{1.05}
\def\arraystretch{1.5}

% list spacing
\setlength{\topsep}{5pt plus 2pt minus 3pt}      % 10.0pt plus 4.0pt minus 6.0pt
\setlength{\partopsep}{-6pt plus 2pt minus 2pt}  %  3.0pt plus 2.0pt minus 2.0pt
\setlength{\itemsep}{0pt}                        %  5.0pt plus 2.5pt minus 1.0pt

% these are copied from tex/latex/base/book.cls
% all I changed is afterskip
\makeatletter
\renewcommand{\section}{\@startsection {section}{1}{\z@}%
    {-3.5ex \@plus -1ex \@minus -.2ex}%
    {0.7ex \@plus.2ex}%
    {\normalfont\Large\bfseries}}
\renewcommand\subsection{\@startsection{subsection}{2}{\z@}%
    {-3.25ex\@plus -1ex \@minus -.2ex}%
    {0.3ex \@plus .2ex}%
    {\normalfont\large\bfseries}}
\renewcommand\subsubsection{\@startsection{subsubsection}{3}{\z@}%
    {-3.25ex\@plus -1ex \@minus -.2ex}%
    {0.3ex \@plus .2ex}%
    {\normalfont\normalsize\bfseries}}
\makeatother

% table of contents vertical spacing
\usepackage{tocloft}
\setlength\cftparskip{8pt plus 4pt minus 4pt}
\usepackage[totoc]{idxlayout}

% The following line adds a little extra space to the column
% in which the Section numbers appear in the table of contents
\makeatletter
\renewcommand{\l@section}{\@dottedtocline{1}{1.5em}{3.0em}}
\makeatother

% customize page headers
\usepackage{fancyhdr}
\pagestyle{fancyplain}
\renewcommand{\chaptermark}[1]{\markboth{Chapter \thechapter ~~ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection ~~ #1}}
\lhead[\fancyplain{}{\bfseries\thepage}]%
      {\fancyplain{}{\bfseries\rightmark}}
\rhead[\fancyplain{}{\bfseries\leftmark}]%
      {\fancyplain{}{\bfseries\thepage}}
\cfoot{}
%\rfoot{\textcolor{gray}{\tiny ThinkJava Draft \today}}

%% tweak spacing of figures and captions
%\usepackage{floatrow}
%\usepackage{caption}
%\captionsetup{
%    font=small,
%    labelformat=empty,
%    justification=centering,
%    skip=4pt
%}

% colors for code listings and output
\usepackage{xcolor}
\definecolor{bgcolor}{HTML}{FAFAFA}
\definecolor{comment}{HTML}{007C00}
\definecolor{keyword}{HTML}{0000FF}
\definecolor{strings}{HTML}{B20000}

% syntax highlighting in code listings
\usepackage{textcomp}
\usepackage{listings}
\lstset{
    language=java,
    basicstyle=\ttfamily,
    backgroundcolor=\color{bgcolor},
    commentstyle=\color{comment},
    keywordstyle=\color{keyword},
    stringstyle=\color{strings},
    columns=fullflexible,
    keepspaces=true,
    showstringspaces=false,
    upquote=true,
    aboveskip=\parskip,
    belowskip=\parskip
}

% code listing environments
\lstnewenvironment{code}
{\minipage{\linewidth}}
{\endminipage}
\lstnewenvironment{stdout}
{\lstset{commentstyle=,keywordstyle=,stringstyle=}\minipage{\linewidth}}
{\endminipage}

% inline syntax formatting
\newcommand{\java}[1]{\lstinline{#1}} %\end{

% pdf hyperlinks, table of contents, and document properties
\usepackage[pdftex]{hyperref}
\hypersetup{%
  pdftitle={\thetitle},
  pdfauthor={\theauthors},
  pdfsubject={\theversion},
  pdfkeywords={},
  bookmarksopen=false,
  colorlinks=true,
  citecolor=black,
  filecolor=black,
  linkcolor=black,
  urlcolor=blue
}

%%%% END OF LATEX ONLY
\fi

%%%% END OF PREAMBLE

\begin{document}

\frontmatter

\ifplastex
%%%% PLASTEX ONLY
    \maketitle

\else
%%%% LATEX ONLY

%--title page--------------------------------------------------
\pagebreak
\thispagestyle{empty}

\begin{flushright}
\vspace*{2.0in}

{\huge Think Java}

\vspace{0.25in}
{\LARGE How to Think Like a Computer Scientist}

\vspace{1in}
{\Large \theauthors}

\vspace{1in}
{\large \theversion}

\vfill

\end{flushright}

%--copyright--------------------------------------------------
\pagebreak
\thispagestyle{empty}

Copyright \copyright ~2016 Allen Downey and Chris Mayfield.

{\bf NOTE: This version of the book is a work in progress and won't be completed until February 2016.}

\vspace{0.25in}

Permission is granted to copy, distribute, transmit, and adapt this work under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License: \url{http://creativecommons.org/licenses/by-nc-sa/3.0/}

The original form of this book is \LaTeX\ source code.
Compiling the \LaTeX\ source has the effect of generating a device-independent representation of the book, which can be converted to other formats and printed.

The \LaTeX\ source for this book is available from \url{http://thinkjava.org}.
%-----------------------------------------------------------------

%\input{todo-tex/preface.tex}

% table of contents
\cleardoublepage
\setcounter{tocdepth}{1}
\tableofcontents

%%%% END OF LATEX ONLY
\fi

\mainmatter


\chapter{The way of the program}

The goal of this book is to teach you to think like a computer scientist.
This way of thinking combines some of the best features of mathematics, engineering, and natural science.
Like mathematicians, computer scientists use formal languages to denote ideas (specifically computations).
Like engineers, they design things, assembling components into systems and evaluating trade-offs among alternatives.
And like scientists, they observe the behavior of complex systems, form hypotheses, and test predictions.
\index{problem-solving}

The single most important skill for a computer scientist is {\bf problem-solving}.
It involves the ability to formulate problems, think creatively about solutions, and express solutions clearly and accurately.
As it turns out, the process of learning to program is an excellent opportunity to develop problem-solving skills.
That's why this chapter is called, ``The way of the program.''

On one level you will be learning to program, a useful skill by itself.
But on another level you will use programming as a means to an end.
As we go along, that end will become clearer.
Learning how to think in terms of computation is much more valuable than simply learning how to write code.


\section{What is programming?}

\index{program}
A {\bf program} is a sequence of instructions that specifies how to perform a computation.
%\footnote{This definition does not apply to all programming languages; for alternatives, see \url{http://en.wikipedia.org/wiki/Declarative_programming}.}
The computation might be something mathematical, like solving a system of equations or finding the roots of a polynomial.
It can also be a symbolic computation, like searching and replacing text in a document or (strangely enough) compiling a program.
The details look different in different languages, but a few basic instructions appear in just about every language.

\begin{description}
\item[input:] Get data from the keyboard, a file, a sensor, or some other device.
\item[output:] Display data on the screen or send data to a file or other device.
\item[math:] Perform basic mathematical operations like addition and division.
\item[decisions:] Check for certain conditions and execute the appropriate code.
\item[repetition:] Perform some action repeatedly, usually with some variation.
\end{description}

\index{programming}

Believe it or not, that's pretty much all there is to it.
Every program you've ever used, no matter how complicated, is made up of instructions that look much like these.
So you can think of {\bf programming} as the process of breaking down a large, complex task into smaller and smaller subtasks.
The process continues until the subtasks are simple enough to be performed with the basic instructions provided by computer hardware.


\section{What is computer science?}

One of the most interesting aspects of writing programs is deciding how to solve a particular problem, especially when there are multiple solutions.
For example, there are numerous ways to sort a list of numbers, and each way has its advantages (see \url{http://www.sorting-algorithms.com/}).
In order to determine which way is best for a given situation, we need techniques for describing and analyzing solutions formally.
That is where computer science comes in.

\index{computer science}
\index{algorithm}

Put simply, {\bf computer science} is the science of algorithms, including their discovery and analysis.
An {\bf algorithm} is a sequence of steps that specify exactly how to solve a problem.
Some algorithms are better than others in terms of how long they take or how much memory they use.
As you learn to develop algorithms for problems you haven't solved before, you also learn to think like a computer scientist.
%It's much more fun to discover new algorithms than to write the code for solutions that other people came up with!

\index{bug}
\index{debugging}

Designing algorithms and writing code is difficult and error-prone.
For historical reasons, programming errors are called {\bf bugs}, and the process of tracking them down and correcting them is called {\bf debugging}.
As you learn to debug your programs, you will develop new problem-solving skills.
You will need to think creatively when unexpected errors happen.

%In the old days, computer scientists had to deal with real bugs flying into their systems.
%You probably won't have that problem, but you will need to think creatively when unexpected errors happen.

%\begin{figure}[!h]
%\begin{center}
%\includegraphics[height=2.2in]{figs/firstbug.jpg}
%\caption{The first computer bug, taped to Grace Hopper's log book in 1947.
%\\ She discovered the moth in an electromagnetic relay of the Mark II.}
%\end{center}
%\end{figure}

% ABD: I don't love this particular piece of mythology, partly because it's not accurate, and partly because stories about the old days bore students.

Although it can be frustrating, debugging is an intellectually rich, challenging, and interesting part of computer programming.
In some ways, debugging is like detective work.
You are confronted with clues, and you have to infer the processes and events that led to the results you see.
Thinking about how to correct programs and improve their performance sometimes even leads to the discovery of new algorithms.


\section{Introduction to Java}

\index{high-level language}
\index{language!high-level}

The programming language you will learn is Java, which is relatively new (Sun released the first version in May 1995).
Java is an example of a {\bf high-level language}.
Other high-level languages you may have heard of include C and C++, JavaScript, Python, Ruby, and Visual Basic.

\index{low-level language}
\index{language!low-level}

There are also {\bf low-level languages}, sometimes referred to as ``machine languages'' or ``assembly languages.''
Loosely speaking, computers can only run programs written in low-level languages.
So programs written in a high-level language have to be translated before they can run.
This translation takes some time, which is a small disadvantage of high-level languages.
But the advantages of high-level languages are enormous.
As a result, low-level languages are only used for programs that need to interact directly with hardware.

\index{portable}

Due to the advantages, almost all programs are written in high-level languages.
First, it is {\em much} easier to program in a high-level language.
Programs take less time to write, are shorter and easier to read, and are more likely to be correct.
Second, high-level languages are {\bf portable}, meaning that they can run on different kinds of computers with few or no modifications.
Low-level programs can only run on one kind of computer, and have to be rewritten to run on another.

\index{interpreter}

Two kinds of programs translate high-level languages into low-level languages: interpreters and compilers.
An {\bf interpreter} reads a high-level program and executes it, meaning that it does what the program says.
It processes the program a little at a time, alternately reading lines and performing computations.
% Figure 1.1 shows the structure of an interpreter.

\begin{figure}[!h]
\begin{center}
\includegraphics{figs/interpreter.pdf}
\caption{How interpreted languages like Python and Ruby are executed.}
\end{center}
\end{figure}

\index{compiler}
\index{source code}
\index{object code}
\index{executable}

In contrast, a {\bf compiler} reads the entire program and translates it completely before the program starts running.
In this context, the high-level program is called the {\bf source code}, and the translated program is called the {\bf object code} or the {\bf executable}.
Once a program is compiled, you can execute it repeatedly without further translation.
As a result, compiled programs often run faster than interpreted programs.
% Figure 1.2 shows the structure of a compiler.

\index{byte code}

Java is {\em both} compiled and interpreted.
Instead of translating programs directly into machine language, the Java compiler generates {\bf byte code}.
Similar to machine language, byte code is easy (and fast) to interpret.
But it is also portable, like a high-level language.
Thus it is possible to compile a Java program on one machine, transfer the byte code to another machine, and then execute (interpret) the byte code on the other machine.
%This ability is an advantage of Java over some other high-level languages.

\begin{figure}[!h]
\begin{center}
\includegraphics{figs/compiler.pdf}
\caption{The process of editing, compiling, and running a Java program.}
\end{center}
\end{figure}

Although this process may seem complicated, in most program development environments these steps are automated for you.
Usually you will only have to write a program and press a button or type a single command to compile and run it.
On the other hand, it is important to know what steps are happening in the background, so if something goes wrong you can figure out what it is.


\section{Formal languages}

\index{natural language}
\index{language!natural}

Learning a programming language is very different from learning a {\bf natural language} such as English, Spanish, or German.
The languages that people speak evolved naturally over time.
%They were not designed by people, although we try to impose order on them for practical reasons.

\index{formal language}
\index{language!formal}

In contrast, {\bf formal languages} are designed by people for specific applications.
For example, the notation that mathematicians use is a formal language that is particularly good at denoting relationships among numbers and symbols.
Chemists use a formal language to represent the chemical structure of molecules.
And most importantly:

\index{programming language}
\index{language!programming}

\begin{quote}
{\bf Programming languages are formal languages that have been designed to express computations.}
\end{quote}

\index{syntax}
\index{semantics}

Formal languages have strict rules about both the {\bf syntax} (structure) and the {\bf semantics} (meaning) of statements.
For example, $3 + 3 = 6$ is a syntactically correct mathematical statement, but $3\ + = 3\ \$\ 6$ is not.
$1 + 2 = 4$ uses correct syntax, but is semantically incorrect.
$H_2O$ is a syntactically correct chemical formula, but $_2Zz$ is not.

%\subsection{Tokens and grammar}

\index{token}

Syntax rules come in two flavors, pertaining to tokens and grammar.
{\bf Tokens} are the basic elements of the language, like words, numbers, and chemical elements.
One of the problems with $3\ + = 3\ \$\ 6$ is that $\$$ is not a legal token in mathematics.
Similarly, $_2Zz$ is not legal because there is no element with the abbreviation $Zz$.

\index{grammar}

The second type of syntax rule pertains to the {\bf grammar} of the language, or the way tokens can be arranged.
The statement $3\ + = 3$ is structurally illegal, even though $+$ and $=$ are legal tokens, because you can't have one right after the other.
Similarly, in a chemical formula the subscript comes after the element name, not before.

\index{parse}

When you read a sentence in English or a statement in a formal language, you have to figure out its structure.
This process is called {\bf parsing}, and in a natural language you learn to do it unconsciously.
As you learn to program, you will learn to parse Java code.

%For example, when you hear the statement ``the penny dropped,'' you understand that the penny is the subject and ``dropped'' is the predicate.
%After you have parsed the statement, you can begin to figure out what it means.
%Assuming that you know what a penny is and what it means to drop, you will understand the general implication of this statement.

%\subsection{Reading source code}


Beginning programmers, who are used to natural languages, often have a hard time adjusting to formal languages.
Although formal and natural languages have features in common---tokens, grammar, and meaning---there are some differences:

\begin{description}

\term{ambiguity}
Natural languages are full of ambiguity, which people deal with by using contextual clues and other information.
Formal languages are designed to be nearly or completely unambiguous, which means that any statement has exactly one meaning, regardless of context.

\term{redundancy}
In order to make up for ambiguity and reduce misunderstandings, natural languages employ lots of redundancy.
As a result, they are often verbose.
Formal languages are less redundant and more concise.

\term{literalness}
Natural languages are full of idiom and metaphor.
When someone says ``the penny dropped'' there is no penny and nothing dropping.
This idiom means that someone finally realized something after a period of confusion.
In contrast, formal languages mean exactly what they say.

\end{description}

%In some ways, the difference between natural and formal language is like the difference between poetry and prose, but more so.

%\begin{description}

%\term{poetry}
%Words are used for their sounds as well as for their meaning, and the whole poe%m together creates an effect or emotional response.
%Ambiguity is not only common but often deliberate.

%\term{prose}
%The literal meaning of words is more important, and the structure contributes more meaning.
%Prose is more amenable to analysis than poetry but still often ambiguous.

%\term{program}
%The meaning of a computer program is unambiguous and literal, and can be understood entirely by analysis of the tokens and grammar.

%\end{description}

%Here are some suggestions for reading programs (and other formal languages).

Small errors in spelling and punctuation, which you can get away with in natural languages, can make a big difference in a formal language.

Also, formal languages are more dense than natural languages, so it takes longer to read them.
The structure is very important, so it is not always a good idea to read from top to bottom, left to right.
Over time you will learn to parse programs in your head, identifying the tokens and interpreting the structure.
And you will learn to read and write programs more quickly.



\section{The hello world program}
\label{sec:hello}

\index{hello world}

Traditionally, the first program you write when learning a new programming language is called the hello world program.
All it does is display the words ``Hello, World!''\ on the screen.
In Java, it looks like this:

\begin{code}
public class Hello {

    public static void main(String[] args) {
        // generate some simple output
        System.out.println("Hello, World!");
    }

}
\end{code}

Note the output of this program does not include the quote marks:

\begin{stdout}
Hello, World!
\end{stdout}

\index{public}
\index{static}

Unfortunately in Java, even this simple example requires language features that are difficult to explain to beginners.
But it provides a preview of topics that we will see in detail later on.
The word \java{public} means the code can be accessed from other source files.
The word \java{static} means that memory is allocated for the program in advance.
We will discuss \java{void}, \java{String}, and \java{args} in the next few chapters.
For now, let's focus on the overall structure.

\index{class!definition}
\index{method!definition}

Java programs are made up of {\bf class} and {\bf method} definitions, which generally have the form:

\begin{code}
public class CLASSNAME {

    METHOD {
        STATEMENTS
    }

    METHOD {
        STATEMENTS
    }

}
\end{code}

\index{class!name}

Here \java{CLASSNAME} indicates the name chosen by the programmer.
Java requires the class name to match the source file name.
In the hello world example, the file name must be {\tt Hello.java} because the class name is \java{Hello}.

\index{statement}
\index{main}

Classes define a program's methods, or named sequences of {\bf statements}.
The \java{Hello} class has only one method:

\begin{code}
    public static void main(String[] args)
\end{code}

The name and format of \java{main} is special; it marks the place in the class where execution begins.
When the program runs, it starts at the first statement in \java{main} and ends when it finishes the last statement.

\index{braces}
\index{squiggly braces}

Java uses squiggly braces (\{ and \}) to group things together.
In {\tt Hello.java}, the outermost braces (lines 1 and 8) contain the class definition, and the inner braces (lines 3 and 6) contain the definition of \java{main} method.

% ABD: It looks like we don't have line numbers in the listings.
% Is that a problem for the text here?

\index{println}
\index{statement!print}

The main method can have any number of statements, but the \java{Hello} example has only one.
It is a {\bf print statement}, meaning that it displays a message on the screen.
Confusingly, print can mean both ``display something on the screen'' and ``send something to the printer.''
%I won't say much about sending things to the printer;
In this book, we'll do all our printing on the screen.
The print statement ends with a semicolon (\java{;}).

\index{comments!inline}
\index{statement!comment}

Line 4 contains a {\bf comment}, or a bit of English text that explains the code that follows.
When the compiler sees \java{//}, it ignores everything from there until the end of the line.
It is a good idea to write a comment before every major block of code so that other programmers (including your future self) can understand what you meant to do.


\section{Setting up a programming environment}

\index{JDK}

In order to compile Java programs on your own computer, you will need to install the Java Development Kit (JDK).
This free software by Oracle includes tools for developing and debugging Java programs.
All the examples in this book were developed and tested using Java SE Version 7.
If you are using a more recent version, the examples in this book should still work.
If you are using an older version, a few of them might not.

\begin{figure}[!h]
\begin{center}
\includegraphics[width=\textwidth]{figs/drjava-hello.png}
\caption{Screenshot of DrJava editing the hello world program.}
\end{center}
\end{figure}

\index{DrJava}

We will use DrJava as the primary development environment throughout the book.
A useful feature of DrJava is the Interactions Pane at the bottom of the window.
It provides the ability to try out code quickly, without having to write a class definition and save/compile/run the program.
Refer to the DrJava documentation (\url{http://drjava.org/docs/quickstart/}) for more details.

Step-by-step instructions for installing the JDK and configuring DrJava are available on this book's website: \url{http://thinkjava.org/}

% TODO: when we have the specific URL for the install page, let's put it here.

\subsection{Command-line interface}

\index{command-line}
\index{terminal}

One of the most powerful and useful skills you can learn is how to use the {\bf command-line interface}, also called the {\em terminal}.
The command line is a direct interface to the operating system.
It allows you to run programs, manage files and directories, and monitor system resources.
Many advanced tools, both for software development and general purpose computing, are available only at the command line.

There are many good tutorials online for learning the command-line for your operating system; just search the web for ``command line tutorial.''
To get started, you only need to know four commands: how to change the working directory ({\tt cd}), list directory contents ({\tt ls}), compile Java programs ({\tt javac}), and run Java programs ({\tt java}).

% ABD: There's a conflict here between ``Find the details for your system'' and ``Here are the UNIX commands''.

\begin{figure}[!h]
\begin{center}
\includegraphics[width=4.5in]{figs/terminal.png}
\caption{Compiling and running {\tt Hello.java} from the command line.}
\end{center}
\end{figure}

In this example, the {\tt Hello.java} source file is stored in the {\tt Desktop} directory.
After changing to that location and listing the files, we use the {\tt javac} command to compile {\tt Hello.java}.
Running {\tt ls} again, we see that the compiler generated a new file, {\tt Hello.class}, which contains the byte code.
We run the program using the {\tt java} command, which displays the output on the following line.

Note that the {\tt javac} command requires a {\em file name} (or multiple source files separated by spaces), whereas the {\tt java} command requires a single {\em class name}.
If you use DrJava, it runs these commands for you and displays the output in the Interactions Pane.

Taking time to learn this efficient and elegant way of interacting with your operating system will make you more productive.
People who don't use the command line don't know what they're missing.

% ABD: Maybe add a reference to Neal Stephenson's book?


\section{Printing strings}

You can put as many statements as you want in \java{main}.
For example, to print more than one line:

\begin{code}
public class Hello {

    public static void main(String[] args) {
        // generate some simple output
        System.out.println("Hello, World!");  // print one line
        System.out.println("How are you?");   // print another
    }

}
\end{code}

As this program demonstrates, you can put comments at the end of a line as well as on lines all by themselves.

\index{String}
\index{type!String}

Phrases that appear in quotation marks are called {\bf strings}, because they contain a sequence of characters strung together.
Strings can contain any combination of letters, numbers, punctuation marks, symbols, and even non-printable characters like tab and backspace.

\index{newline}
\index{print}
\index{statement!print}

The name \java{println} is short for ``print line.''
It appends a special character, called a {\bf newline}, that advances the cursor to the beginning of the next line.
%The next time \java{println} is invoked, the new text appears on the next line.
To display the output from multiple print statements on one line, use \java{print}:

\begin{code}
public class Goodbye {

    public static void main(String[] args) {
        System.out.print("Goodbye, ");
        System.out.println("cruel world");
    }

}
\end{code}

The output appears on a single line as {\tt Goodbye, cruel world}.
Notice that there is a space between the word ``Goodbye'' and the second quotation mark.
This space appears in the output, so it affects the {\em behavior} of the program.

\subsection{Code formatting}
\label{sec:formatting}

Spaces that appear outside of quotation marks generally do not affect the behavior of the program.
For example, we could have written:

\begin{code}
public class Goodbye {
public static void main(String[] args) {
System.out.print("Goodbye, ");
System.out.println("cruel world");
}
}
\end{code}

This program would compile and run just as well as the original.
The newlines at the end of each line do not affect the program's behavior either.
So we could have also written:

\begin{code}
public class Goodbye { public static void main(String[] args) {
System.out.print("Goodbye, "); System.out.println
("cruel world");}}
\end{code}

It still works, but the program is getting harder and harder to read.
Newlines and spaces are important for organizing your program visually, making it easier to understand the program and find errors when they occur.
%Formatting your code well does not take much effort, and it pays huge dividends.
%We will discuss readability and style guidelines in the next chapter.

\subsection{Escape sequences}

It is possible to print multiple lines of output in just one line of code.
You just have to tell Java where to put the line breaks.

\begin{code}
public class Hello {

    public static void main(String[] args) {
        System.out.print("Hello!\nHow are you doing?\n");
    }

}
\end{code}

The output is two lines, each ending with a newline character:

\begin{stdout}
Hello!
How are you doing?
\end{stdout}

\index{escape sequence}

The code \verb"\n" is an {\bf escape sequence}, which is a sequence of characters in a string that represents a special character.
The backslash allows you to ``escape'' the string's literal interpretation.
Notice there is no space between \verb"\n" and \verb"How".
If you add a space there, there will be a space at the beginning of the second line.

\begin{table}[!h]
\begin{center}
\begin{tabular}{|c|c|}
\hline
\verb"\n" & newline \\
\hline
\verb"\t" & tab \\
\hline
\verb'\"' & double quote \\
\hline
\verb"\\" & backslash \\
\hline
\end{tabular}
\caption{Common escape sequences}
\end{center}
\end{table}

Another common use of escape sequences is to have quote marks inside of strings.
Since double quotes indicate the beginning and end of strings, you need to escape them with a backslash.

\begin{code}
    System.out.println("She said \"Hello!\" to me.");
\end{code}

The result is:

\begin{stdout}
She said "Hello!" to me.
\end{stdout}


\section{Debugging}
\label{sec:examples}

It is a good idea to read this book in front of a computer so you can try out the examples as you go.
You can run many of the examples directly in DrJava's Interactions Pane, but if you put the code in a source file, it will be easier to try out variations.

Whenever you are experimenting with a new feature, you should also try to make mistakes.
For example, in the hello world program, what happens if you leave out one of the quotation marks?
What if you leave out both?
What if you spell \java{println} wrong?
This kind of experiment helps you remember what you read.
It also helps with debugging, because you get to know what the error messages mean.
It is better to make mistakes now and on purpose than later on and accidentally.

\index{experimental debugging}
\index{debugging!experimental}

%\index{Holmes, Sherlock}
%\index{Doyle, Arthur Conan}

Debugging is like an experimental science.
Once you have an idea about what is going wrong, you modify your program and try again.
If your hypothesis was correct, then you can predict the result of the modification, and you take a step closer to a working program.
If your hypothesis was wrong, you have to come up with a new one.
%As Sherlock Holmes pointed out, ``When you have eliminated the impossible, whatever remains, however improbable, must be the truth.''
%(A.~Conan Doyle, {\em The Sign of Four}.)

Programming and debugging should go hand in hand.
Don't just write a bunch of code and then perform trial and error debugging until it all works.
Instead, start with a program that does {\em something} and make small modifications, debugging them as you go, until the program does what you want.
That way you will always have a working program, and it will be easier to isolate errors.

\index{Linux}
\index{Torvalds, Linus}
\index{Greenfield, Larry}

A great example of this principle is the Linux operating system, which contains millions of lines of code.
It started out as a simple program Linus Torvalds used to explore the Intel 80386 chip.
According to Larry Greenfield, ``One of Linus's earlier projects was a program that would switch between printing AAAA and BBBB.
This later evolved to Linux.'' ({\em The Linux Users' Guide})

%Later chapters will make more suggestions about debugging and other programming practices.

Finally, programming sometimes brings out strong emotions.
If you are struggling with a difficult bug, you might feel angry, despondent, or embarrassed.
Remember that you are not alone, and most if not all programmers have had similar experiences.
Don't hesitate to reach out to a friend and ask questions!

%\index{emotional debugging}
%\index{debugging!emotional response}

%There is evidence that people naturally respond to computers as if they were people.
%When they work well, we think of them as teammates, and when they are obstinate or rude, we respond to them the same way we respond to rude, obstinate people.
%(Reeves and Nass, {\it The Media Equation: How People Treat Computers, Television, and New Media Like Real People and Places})

%Preparing for these reactions might help you deal with them.
%One approach is to think of the computer as an employee with certain strengths, like speed and precision, and particular weaknesses, like lack of empathy and inability to grasp the big picture.

%Your job is to be a good manager: find ways to take advantage of the strengths and mitigate the weaknesses.
%And find ways to use your emotions to engage with the problem, without letting your reactions interfere with your ability to work effectively.

%Learning to debug can be frustrating, but it is a valuable skill that is useful for many activities beyond programming.
%At the end of each chapter there is a debugging section, like this one, with my thoughts about debugging.
%I hope they help!


\section{Vocabulary}

Throughout the book, we try to define each term the first time we use
it.
And the end of each chapter, we include the new terms and their definitions.
If you spend some time learning this vocablary, you will have an easier time reading the following chapters.

\begin{description}

\term{problem-solving}
The process of formulating a problem, finding a solution, and expressing the solution.

\term{program}
A sequence of instructions that specify how to perform tasks on a computer.

\term{programming}
The application of problem-solving to creating executable computer programs.

\term{computer science}
The scientific and practical approach to computation and its applications.

\term{algorithm}
A procedure or formula for solving a problem, with or without a computer.

\term{bug}
An error in a program.

\term{debugging}
The process of finding and removing any of the three kinds of errors.

\term{high-level language}
A programming language that is designed to be easy for humans to read and write.

\term{low-level language}
A programming language that is designed to be easy for a computer to run.
Also called ``machine language'' or ``assembly language.''

\term{portable}
The ability of a program to run on more than one kind of computer.

\term{interpret}
To run a program in a high-level language by translating it one line at a time and immediately executing the corresponding instructions.

\term{compile}
To translate a program in a high-level language into a low-level language, all at once, in preparation for later execution.

\term{source code}
A program in a high-level language, before being compiled.

\term{object code}
The output of the compiler, after translating the program.

\term{executable}
Another name for object code that is ready to run on specific hardware.

\term{byte code}
A special kind of object code used for Java programs.
Byte code is similar to a low-level language, but it is portable like a high-level language.

\term{natural language}
Any of the languages people speak that have evolved naturally.

\term{formal language}
A language people have designed for specific purposes, like representing mathematical ideas or computer programs.

\term{programming language}
A formal language that has been designed to express computations.

\term{syntax}
The structure of a program.

\term{semantics}
The meaning of a program.

\term{token}
A basic element of a program, such as a word, space, symbol, or number.

\term{grammar}
A set of rules that determines whether a statement is legal.

\term{parse}
To examine a program and analyze the syntactic structure.

\term{statement}
A part of a program that specifies a computation.

\term{method}
A named sequence of statements.

\term{class}
For now, a collection of related methods. (We will see later that there is more to it.)

\term{print statement}
A statement that causes output to be displayed on the screen.

\term{comment}
A part of a program that contains information about the program but has no effect when the program runs.

\term{command-line}
A means of interacting with the computer by issuing commands in the form of successive lines of text.

\term{string}
A sequence of characters; the primary data type for text.

\term{newline}
A special character signifying the end of a line of text.
Also known as line ending, end of line (EOL), or line break.

\term{escape sequence}
A sequence of code that represents a special character when used inside a string.

\end{description}


\section{Exercises}

At the end of each chapter we include exercises you can do with the things you've learned.
We encourage you to at least attempt every problem.
You can't learn to program by reading along; you have to practice.

\begin{exercise}

Computer scientists have the annoying habit of using common English words to mean something other than their common English meaning.
For example, in English, statements and comments are the same thing, but in programs they are different.

The glossary at the end of each chapter is intended to highlight words and phrases that have special meanings in computer science.
When you see familiar words, don't assume that you know what they mean!

\begin{enumerate}
\item In computer jargon, what's the difference between a statement and a comment?
\item What does it mean to say that a program is portable?
\item What is an executable?
\end{enumerate}

\end{exercise}


\begin{exercise}

Before you do anything else, find out how to compile and run a Java program in your environment.
Some environments provide sample programs similar to the example in Section~\ref{sec:hello}.

\begin{enumerate}
\item Type in the ``Hello, world'' program, then compile and run it.

\item Add a print statement that prints a second message after the ``Hello, world!''.
Say something witty like, ``How are you?''
Compile and run the program again.

\item Add a comment to the program (anywhere), recompile, and run it again.
The new comment should not affect the result.
\end{enumerate}

This exercise may seem trivial, but it is the starting place for many of the programs we will work with.
To debug with confidence, you have to have confidence in your programming environment.
In some environments, it is easy to lose track of which program is executing.
You might find yourself trying to debug one program while you are accidentally running another.
Adding (and changing) print statements is a simple way to be sure that the program you are looking at is the program you are running.

\end{exercise}


\begin{exercise}

It is a good idea to commit as many errors as you can think of, so that you see what error messages the compiler produces.
Sometimes the compiler tells you exactly what is wrong, and all you have to do is fix it.
But sometimes the error messages are misleading.
You will develop a sense for when you can trust the compiler and when you have to figure things out yourself.

\begin {enumerate}
\item Remove one of the open squiggly-braces.
\item Remove one of the close squiggly-braces.
\item Instead of \java{main}, write \java{mian}.
\item Remove the word \java{static}.
\item Remove the word \java{public}.
\item Remove the word \java{System}.
\item Replace \java{println} with {Println}.
\item Replace \java{println} with {print}.
This one is tricky because it is a logic error, not a syntax error.
The statement \java{System.out.print} is legal, but it may or may not do what you expect.
\item Delete one of the parentheses.  Add an extra one.
\end {enumerate}

\end{exercise}


\chapter{Variables and arithmetic}

This chapter is about storing values in computer memory and doing basic arithmetic.
More importantly, it discusses how to {\em compose} statements using smaller building blocks such as variables and operators.
We also discuss code quality, which is almost as important as correctness.
High quality code is easier to read, which makes it easier to maintain and debug.

%For better or worse, Java performs some conversions automatically when you have different types of data in the same statement.
%Following style guidelines helps you to avoid common programming mistakes that are difficult to debug.


\section{Types of errors}

\index{error!message}

%As you begin writing your own programs, you will encounter various error messages.
Three kinds of errors can occur in a program: syntax errors, runtime errors, and logic errors.
It is useful to distinguish between them in order to track them down more quickly.
Regardless of what type of error occurs, remember to {\em read and think about the error messages carefully}.
They will usually point you in the right direction to fix your program.

\subsection{Syntax errors}

\index{syntax error}
\index{error!syntax}

The compiler can only translate a program if the syntax is correct; otherwise, it fails and displays an error message.
For example, parentheses have to come in matching pairs.
So \java{(1 + 2)} is legal, but \java{8)} is a {\bf syntax error}.

In English, readers can tolerate most syntax errors, which is why we can read the poetry of E.\ E.\ Cummings without spewing error messages.
Java is not so forgiving; if there is a single syntax error anywhere in your program, the compiler will display an error message and quit, and you will not be able to run the program.

\begin{figure}[!h]
\begin{center}
\includegraphics[width=\textwidth]{figs/syntax-error.png}
\caption{A syntax error caused by a missing brace.}
\label{fig:syntax}
\end{center}
\end{figure}

To make matters worse, the error messages you get from the compiler are often not very helpful.
As shown in Figure~\ref{fig:syntax}, removing the closing brace on line 8 of the hello world program results in ``Error: reached end of file while parsing.''
The compiler also reports that the problem was found on line 6, which in this case is not at fault.
Since line 8 was deleted, the compiler simply reported the last line of the file.

During the first few weeks of your programming career, you will probably spend a lot of time tracking down syntax errors.
But as you gain experience, you will make fewer mistakes and find them more quickly.

\subsection{Runtime errors}

\index{runtime error}
\index{error!runtime}
%\index{type-safe}
%\index{language!type-safe}

The second type of error is a {\bf runtime error}, so called because it does not appear until after the program has started running.
In Java, these errors occur when the interpreter is executing the byte code and something goes wrong.
%Java is designed to be a {\bf type-safe} language, which means that the compiler can detect many potential errors cased by common programming mistakes.
Runtime errors are rare in the simple programs you will see in the first few chapters, so it might be a while before you encounter one.

\index{exception}

These errors are also called {\em exceptions} because they usually indicate that something exceptional (and bad) has happened.
In most environments they appear as windows or dialog boxes that contain information about what happened and what the program was doing when it happened.
For example, if you accidentally divide by zero you will get an \java{ArithmeticException}:

\begin{small}
\begin{stdout}
Exception in thread "main" java.lang.ArithmeticException: / by zero
    at Hello.main(Hello.java:5)
\end{stdout}
\end{small}

This information is useful for debugging.
The first line gives a brief description of the error (/ by zero).
The subsequent lines report the class and method names (Hello.main), along with the file name and line number where the error occurred (Hello.java:5).
Keep in mind that the line where the program crashed may not be the line that needs to be fixed.

\subsection{Logic errors}

\index{logic error}
\index{error!logic}

The third type of error is the {\bf logic error}.
If there is an error in your program's logic, it will compile and run successfully in the sense that the computer will not generate any error messages.
But it will not do the right thing.
It will do something else.
Specifically, it will do what you told it to do.
Here is an example of a logic error in the hello world program:

\begin{code}
public class Hello {

    public static void main(String[] args) {
        System.out.println("Goodbye, world.");
    }

}
\end{code}

This program compiles and runs just fine.
The problem is that the main method is not the program we intended.
The meaning of the program is wrong, because it says goodbye instead of hello.
In addition, world is not capitalized, and it ends with a period instead of an exclamation point.

Identifying logic errors can be tricky because it requires you to challenge your assumptions, both about the code and the requirements.
You will need to work backwards by looking at the output of the program, try to figure out what it is doing, and make sure you understand what it should be doing.


\section{Creating variables}

\index{variable}
\index{value}

One of the most powerful features of a programming language is the ability to define and manipulate {\bf variables}.
A variable is a named location of computer memory that stores a {\bf value}.
Values may be numbers, text, images, sounds, and other types of data.
%They can be printed, and as we'll see later, operated on.
To store a value in memory, you first have to create a variable.
%Since the values we want to store are text, we declare that the new variable is a string:

\begin{code}
    String message;
\end{code}

\index{declaration}
\index{statement!declaration}
\index{type!int}
\index{type!char}
\index{type!String}

This statement is a {\bf declaration}, because it declares that the variable named \java{message} has the type \java{String}.
Each variable has a {\bf type} that determines what kind of values it can store.
For example, the \java{int} type can store integers, and the \java{char} type can store characters.

Some types begin with a capital letter and some with lower-case.
We will learn the significance of this distinction later, but for now you should take care to get it right.
There is no such type as \java{Int} or \java{string}, and the compiler will complain if you make one up.

To declare an integer variable, the syntax is:

\begin{code}
    int x;
\end{code}

Note that \java{x} is an arbitrary name for the variable.
In general, you should use names that indicate what the variables mean.
For example, if you saw these variable declarations, you could probably guess what values would be stored in them:

\begin{code}
    String firstName;
    String lastName;
    int hour, minute;
\end{code}

This example also demonstrates the syntax for declaring multiple variables with the same type: \java{hour} and \java{minute} are both integers.
Note that each declaration statement ends with a semicolon.

You can use any name you want for a variable.
But there are certain words that are reserved in Java, because they are used by the compiler to parse the structure of the program.
These {\bf keywords} include \java{public}, \java{class}, \java{static}, \java{void}, \java{int}, and others (there are currently 50 in Java).
Search the Internet for ``Java keywords'' to see the complete list.

%The complete list is available at \url{https://docs.oracle.com/javase/tutorial/}.
%This site, provided by Oracle, includes Java documentation I refer to throughout the book.

Rather than memorize the keywords, you should take advantage of the syntax highlighting provided in many development environments (including DrJava).
As you type, the tokens in your program will appear in different colors.
For example, keywords might be blue, strings red, comments green, and other code black.
If you type a variable name and it turns blue, watch out!

\subsection{Assignment}

\index{assignment}
\index{statement!assignment}

Now that we have created variables, we want to store values.
We do that with an {\bf assignment} statement.

\begin{code}
    message = "Hello!";  // give message the value "Hello!"
    hour = 10;           // assign the value 10 to hour
    minute = 59;         // set minute to 59
    hour = 11;           // change the hour to 11
\end{code}

This example shows four assignments, and the comments illustrate different ways people sometimes talk about assignment statements.
The vocabulary can be confusing here, but the idea is straightforward:

\begin{itemize}
\item When you declare a variable, you create a named storage location.
\item When you make an assignment to a variable, you give it a value.
\item If you reassign the variable, its value changes.
\end{itemize}

As a general rule, a variable has to have the same type as the value you assign to it.
For example, you cannot store a \java{String} in \java{minute} or an integer in \java{message}.
We will see some examples that seem to break this rule, but we'll get to that later.

%On the other hand, that rule can be confusing.
%There are many ways that you can convert values from one type to another, and Java sometimes converts things automatically.
%For now you should remember the general rule, and we'll talk about exceptions later.

A common source of confusion is that some strings {\em look} like integers, but they are not.
For example, \java{message} can contain the string \java{"123"}, which is made up of the characters \java{'1'}, \java{'2'}, and \java{'3'}.
But that is not the same thing as the integer \java{123}.

\begin{code}
    message = "123";  // legal
    message = 123;    // not legal
\end{code}

\subsection{Memory diagrams}

\index{memory diagram}

A common way to represent variables on paper is to draw a box with the name of the variable on the outside and the value of the variable on the inside.
This diagram shows the effect of the four assignments in the previous section:

\begin{center}
\begin{tabular}{rl}
message & \framebox[2cm]{Hello!} \\
   hour & \framebox[1cm]{11} \\
 minute & \framebox[1cm]{59} \\
\end{tabular}
\end{center}

% ABD: In the hour box, consider showing 10 crossed out, followed by 11?

Each box represents the storage location that holds the variable's value.
Once declared, you cannot change the name of a variable, but you can change the value as many times as you like.
For example, \java{hour} was initially \java{10}, then reassigned to \java{11}.
The diagram shows only the final value.

%Since these locations can be anywhere in memory, we refer to them by the variable name.
%The storage location does not change; those memory cells are simply reused.


\section{Printing variables}
\label{sec:printvar}

You can display the value of a variable using \java{print} or \java{println}.
The following program declares a variable named \java{firstLine}, assigns it the value \java{"Hello, again!"}, and then prints that value.

\begin{code}
public class Hello {
    public static void main(String[] args) {
        String firstLine;
        firstLine = "Hello, again!";
        System.out.println(firstLine);
    }
}
\end{code}

When we talk about printing a variable, we generally mean printing the {\em value} of the variable.
To print the {\em name} of a variable, you have to put it in quotes.
%For example: \java{System.out.println("firstLine");}
For example, you can write:

\begin{code}
    String firstLine;
    firstLine = "Hello, again!";
    System.out.print("The value of firstLine is ");
    System.out.println(firstLine);
\end{code}

The output of this program is:

\begin{stdout}
The value of firstLine is Hello, again!
\end{stdout}

%The output does not contain quote marks around \java{Hello, again!}.
%Those quote marks were part of the source code, not the value.

The syntax for printing a variable is the same regardless of the variable's type.
For example:

\begin{code}
    int hour, minute;
    hour = 11;
    minute = 59;
    System.out.print("The current time is ");
    System.out.print(hour);
    System.out.print(":");
    System.out.print(minute);
    System.out.println(".");
\end{code}

The output of this program is:

\begin{stdout}
The current time is 11:59.
\end{stdout}

To output multiple values on the same line, it's common to use several \java{print} statements followed by a \java{println} at the end.
{\bf Don't forget the \java{println}!}
On many operating systems, the output from \java{print} is stored without being displayed until \java{println} is invoked, at which point the entire line is displayed at once.
If you omit the \java{println}, the program may display the stored output at unexpected times or even terminate without displaying anything.


\section{Arithmetic operators}
\label{sec:arithops}

%Recall that Java programs are organized into {\em classes}, each of which has one or more {\em methods}, each of which has one or more {\em statements}.
%Most statements consist of one or more {\bf expressions}.

\index{operator}

{\bf Operators} are symbols that represent computations like addition and multiplication.
%Most operators in Java do what you expect them to do, since they are common mathematical symbols.
For example, the operator for addition is \java{+}, subtraction is \java{-}, multiplication is \java{*}, and division is \java{/}.
%Variables are replaced with their values before the computation is performed.

The following program converts the time of day to minutes:

\begin{code}
    int hour, minute;
    hour = 11;
    minute = 59;
    System.out.print("Number of minutes since midnight: ");
    System.out.println(hour * 60 + minute);
\end{code}

\index{expression}

In this program, \java{hour * 60 + minute} is an {\bf expression}, which represents a single value to be computed.
When the program runs, each variable is replaced by its current value, and then the operators are applied.
The result is:

\begin{stdout}
Number of minutes since midnight: 719
\end{stdout}

Expressions are generally a combination of numbers, variables, and operators.
When complied and executed, they become a single value:

\begin{code}
    1 + 1     hour - 1     hour * 60 + minute     minute / 60
    2         11 - 1       11 * 60 + 59           59 / 60
              10           660 + 59               0
                           719
\end{code}

Addition, subtraction, and multiplication all do what you expect, but you might be surprised by division.
For example, the following lines try to compute the fraction of an hour that has elapsed:

\begin{code}
    System.out.print("Fraction of the hour that has passed: ");
    System.out.println(minute / 60);
\end{code}

But the program outputs:

\begin{stdout}
Fraction of the hour that has passed: 0
\end{stdout}

\index{division!integer}
\index{integer division}

This result often confuses people.
After all, the value of \java{minute} is 59, and 59 divided by 60 should be 0.98333, not 0.
The problem here is that Java performs {\em integer division}.
When the values being divided are integers, the result is also an integer.
Computer hardware is designed so that integer division always {\em rounds down}, even in cases like this one where the next integer is close.

One solution is to calculate a percentage rather than a fraction:

\begin{code}
    System.out.print("Percent of the hour that has passed: ");
    System.out.println(minute * 100 / 60);
\end{code}

The new output is:

\begin{stdout}
Percent of the hour that has passed: 98
\end{stdout}

Again the result is rounded down, but at least now it's approximately correct.
%To get a more precise answer, we can use a different type of variable that can store fractional values.


\section{Floating-point numbers}

\index{floating-point}
\index{double (floating-point)}
\index{type!double}

A more general solution is to use {\bf floating-point} numbers, which can represent fractions as well as integers.
%As the name implies, the decimal point floats around (i.e., you can have as many decimal places as you want).

In Java, the default floating-point type is called \java{double}, which is short for double-precision.
You can create \java{double} variables and assign values to them using the same syntax we used for the other types:

\begin{code}
    double pi;
    pi = 3.14159;
\end{code}

Although floating-point numbers are useful, they can be a source of confusion.
For example, Java distinguishes the integer value \java{1} from the floating-point value \java{1.0}, even though they seem to be the same number.
They belong to different data types, and strictly speaking, you are not allowed to make assignments between types.

The following is illegal because the variable on the left is an \java{int} and the value on the right is a \java{double}.

\begin{code}
    int x;
    x = 1.1;  // syntax error
\end{code}

But it is easy to forget this rule because in many cases Java {\em automatically} converts from one type to another:

\begin{code}
    double y;
    y = 1;  // bad style
\end{code}

The above example should be illegal, but Java allows it by converting the \java{int} value \java{1} to the \java{double} value \java{1.0} automatically.
This leniency is convenient, but it often causes problems for beginners. For example:

\begin{code}
    double y;
    y = 1 / 3;  // logic error
\end{code}

\index{division!integer}
\index{integer division}

You might expect the variable \java{y} to get the value \java{0.333333}, which is a legal floating-point value.
But instead it gets the value \java{0.0}.
The reason is that the expression on the right divides two integers.
So Java does {\em integer division}, which yields the \java{int} value \java{0}.
Converted to \java{double}, the final result is \java{0.0}.

One way to solve this problem (after you finally discover that bug) is to make the right-hand side a floating-point expression.
The following initializes \java{y} to \java{0.333333}, as expected:

\begin{code}
    double y;
    y = 1.0 / 3.0;  // correct
\end{code}

As a matter of style, you should always assign floating-point values to floating-point variables.
The compiler won't make you do it, but you never know when a bug like this one will come back and haunt you.


\section{Rounding errors}

%The operations we have seen so far---addition, subtraction, multiplication, and division---also work on floating-point values, although you might be interested to know that the underlying mechanism is completely different.
%In fact, most processors have special circuitry just for performing floating-point operations.

\index{rounding error}

On hardware, floating-point numbers are only {\it approximately} correct.
Some numbers, like reasonably-sized integers, can be represented exactly.
But repeating fractions, like $1/3$, and irrational numbers, like $\pi$, cannot.
To represent these numbers, computers have to round off to the nearest floating-point number.
The difference between the number we want and the floating-point number we get is called {\bf rounding error}.

%Notwithstanding, there is a fundamental flaw with floating-point arithmetic.
%In mathematics, there is an infinite number of real numbers.
%But computer processors are finite; they cannot represent {\em every} possible floating-point number.
%Even with double-precision, you will frequently run into problems.

\index{arithmetic!floating-point}

For example, the following two statements should be equivalent:

\begin{code}
    System.out.println(0.1 * 10);
    System.out.println(0.1 + 0.1 + 0.1 + 0.1 + 0.1
                     + 0.1 + 0.1 + 0.1 + 0.1 + 0.1);
\end{code}

But on many machines, the output is:

\begin{stdout}
1.0
0.9999999999999999
\end{stdout}

The problem is that \java{0.1}, which is a terminating fraction in base 10, is a repeating fraction in base 2.
So its floating-point representation is only approximate.
When we add up the approximations, the rounding errors accumulate.

For many applications, like computer graphics, encryption, statistical analysis, and multimedia rendering, floating-point arithmetic has benefits that outweigh the costs.
But if you need {\em absolute} precision, use integers instead.
For example, consider a bank account with a balance of \$123.45:

\begin{code}
    double balance = 123.45;  // potential rounding error
\end{code}

In this example, balances will become inaccurate over time as the variable is used in arithmetic operations like deposits and withdrawals.
The result would be angry customers and potential law suits.
You can avoid the problem by representing the balance as an integer:

\begin{code}
    int balance = 12345;      // total number of cents
\end{code}

\index{type!long}

This solution works as long as the number of cents doesn't exceed the largest integer, which is about 2 billion.
If necessary you can use \java{long} instead, which has a max value of $2^{63}-1$ (about 92 quadrillion dollars).
Hopefully nobody will ever need that much money!


\section{Operators for strings}

\index{string operator}
\index{operator!string}

In general, you cannot perform mathematical operations on strings, even if the strings look like numbers.
The following expressions are illegal:

\begin{code}
    "Hello" - 1     "World" / 123     "Hello" * "World"
\end{code}

%Note that it's unclear looking at these expressions whether \java{message} is an integer or a string.
%The only way to tell the type of a variable is to look at the place where it is declared.

\index{concatenate}

The \java{+} operator does work with strings, but it might not do what you expect.
For strings, the \java{+} operator performs {\bf concatenation}, which means joining each part end-to-end.
So \java{"Hello, " + "world!"} yields the string \java{"Hello, world!"}.
Likewise, the expression \java{"Hello, " + name} adds the value of \java{name} to the hello string, which is handy for creating a personalized greeting.

%When you append two strings, make sure one of them contains a space character.
%Otherwise you will end up with something like \java{"Hello,world!"}.

%\subsection{Adding Strings and numbers}

%If you add an \java{int} and a \java{double}, Java automatically converts the \java{int} into a \java{double} before performing the addition:

%\begin{code}
%    System.out.println(1 + 2.0);
%    // prints 3.0
%\end{code}

Since addition is defined for both numbers and strings, Java performs automatic conversions you may not expect:

% TODO: use DrJava interactive format for these examples?

\begin{code}
    System.out.println(1 + 2 + "Hello");
    // the output is 3Hello

    System.out.println("Hello" + 1 + 2);
    // the output is Hello12
\end{code}

Java executes these operations from left to right.
In the first line, \java{1 + 2} is the value \java{3}, and \java{3 + "Hello"} is the value \java{"3Hello"}.
But in the second line, \java{"Hello" + 1} is \java{"Hello1"}, and \java{"Hello1" + 2} is \java{"Hello12"}.
The difference is when the conversion from integer to string actually takes place.

%Fortunately, this situation only happens when using the plus operator.
%You cannot, for example, store an integer directly in a string variable.
%
%\begin{code}
%     String number = 5;  // syntax error
%\end{code}

%In general, it's better not to compose multiple additions of varying data types.
%Instead you can break those statements into multiple lines, or use another method like \java{printf} to achieve the same results.


% TODO: add the following subsection before/after this section?
%\section{Type conversion}
%\index{type!conversion}
%\index{typecasting}

%You might wonder how you can get away with an expression like \java{
%"The log of x is " + result}, since one of the operands is a \java{String}
%and the other is a \java{double}.  In this case Java is being
%smart on our behalf, automatically converting the \java{double} to a
%\java{String} before it does the string concatenation.

%This kind of feature is an example of a common problem in designing a
%programming language, which is that there is a conflict between {\em
%formalism}, which is the requirement that formal languages should have
%simple rules with few exceptions, and {\em convenience}, which is the
%requirement that programming languages be easy to use in practice.

%More often than not, convenience wins, which is usually good for
%expert programmers (who are spared from rigorous but unwieldy
%formalism), but bad for beginning programmers, who are often baffled
%by the complexity of the rules and the number of exceptions.  In this
%book I have tried to simplify things by emphasizing the rules and
%omitting many of the exceptions.

%Whenever you try to ``add'' two
%expressions, if one of them is a \java{String}, Java converts the
%other to a \java{String} and then perform string concatenation.
%What do you think happens if you perform an operation between
%an integer and a floating-point value?


\section{Order of operations}

\index{order of operations}
\index{precedence}

When more than one operator appears in an expression, the order of evaluation depends on the rules of {\bf precedence}.
Generally speaking, Java executes individual operations from left to right (as was the case in the previous section).
But for numeric operators, Java follows mathematical conventions:

\begin{itemize}

\item Multiplication and division happen before addition and subtraction.
So \java{2 * 3 - 1} yields 5, not 4, and \java{2 / 3 - 1} yields -1, not 1.
Remember that because of integer division, \java{2 / 3} is 0.

\item If the operators have the same precedence, they are evaluated from left to right.
So in the expression \java{minute * 100 / 60}, the multiplication happens first, yielding \java{5900 / 60}, which in turn yields \java{98}.
If these same operations had gone from right to left, the result would have been \java{59 * 1}, which is incorrect.

\item Any time you want to override the rules of precedence (or you are not sure what they are) you can use parentheses.
Expressions in parentheses are evaluated first, so \java{2 * (3 - 1)} is 4.
You can also use parentheses to make an expression easier to read, as in \java{(minute * 100) / 60}, even though it doesn't change the actual result.

\end{itemize}

Don't work too hard to remember all the rules of precedence, especially for other operators.
If it's not obvious by looking at the expression, use parentheses to make it more clear.


\section{Composition}

\index{composition}

So far we have looked at the elements of a programming language---variables, expressions, and statements---in isolation, without talking about how to put them all together.

One of the most useful features of programming languages is their ability to take small building blocks and {\bf compose} them.
For example, we know how to multiply numbers and we know how to print.
It turns out we can combine these operations into a single statement:

\begin{code}
    System.out.println(17 * 3);
\end{code}

Any expression involving numbers, strings, and variables can be used inside a print statement.
We've already seen one example:

\begin{code}
    System.out.println(hour * 60 + minute);
\end{code}

You can also put arbitrary expressions on the right side of an assignment:

\begin{code}
    int percentage;
    percentage = (minute * 100) / 60;
\end{code}

The left side of an assignment must be a {\em variable name}, not an expression.
That's because the left side indicates where the result will be stored,
and expressions do not represent storage locations.

\begin{code}
    hour = minute + 1;  // correct
    minute + 1 = hour;  // syntax error
\end{code}

\index{readability}

The ability to compose operations may not seem that impressive now, but we will see examples later on that allow us to write complex computations neatly and concisely.

Before you get too carried away with composition, keep in mind that other people will be reading your source code.
In practice, software developers spend the vast majority of their time {\em understanding} and {\em modifying} existing code.
Thus it's far more important to write code that is readable than to write code that is (or appears to be) optimal.
%There is much beauty in simplicity.
In general, each line of code should be a single step of the algorithm.


\section{Formatting and style}

\index{whitespace}

Recall from Section~\ref{sec:formatting} that the compiler generally ignores {\bf whitespace}, i.e., newlines, tab characters, and other spaces.
Programmers have a lot of freedom in how they {\em format} their code in terms of indenting, blank lines, spaces around operators, etc.
However with that freedom comes responsibility, both to yourself (when you look at the code in the future) and to others who will be reading, understanding, and modifying your code.

\index{Google style}

Virtually every organization that does a lot of software development has strict guidelines on how to format source code.
For example, Google published its Java coding standards for use in open-source projects:
\url{http://google.github.io/styleguide/javaguide.html}
It is easier to understand a large codebase when all the source code is formatted consistently.
%Plus following style guidelines helps you to avoid common programming mistakes that are difficult to debug.

\index{Checkstyle}

Style rules can be difficult to learn, especially for beginners who haven't yet seen many of the language features discussed in them.
Fortunately there are many tools that help programmers find and correct formatting errors.
One prominent example is Checkstyle, which has the built-in ability to enforce most of Google's coding standards:
\url{http://checkstyle.sourceforge.net/}

Checkstyle is primarily a command-line tool.
Instructions for downloading and running Checkstyle are available on our website: \url{http://thinkjava.org/}

% TODO: When we have the website up, let's update this with a more specific URL

There are limits to what automatic style checkers can do.
In particular, they can't evaluate the {\em quality} of your comments, the {\em meaning} of your variable names, or the {\em structure} of your algorithms.
Good comments make it easier for experienced developers to identify errors in your code.
Good variable names communicate the intent of your program and how the data is organized.
And good programs are designed to be efficient and demonstrably correct.


\section{Vocabulary}

\begin{description}

\term{syntax error}
An error in a program that makes it impossible to parse (and therefore impossible to compile).

%\term{type-safe}
%A property of Java that makes it possible to catch some errors at compile time.

\term{runtime error}
An error in a program that makes it impossible to execute completely.
In Java, they are ``exceptions'' that terminate the program.

\term{logic error}
An error in a program that makes it do something other than what the programmer intended.

\term{variable}
A named storage location for values.
All variables have a type, which is declared when the variable is created.

\term{value}
A number or string that can be stored in a variable.
Every value belongs to a type (for example, \java{int} or \java{String}).

\term{declaration}
A statement that creates a new variable and specifies its type.

\term{type}
Mathematically speaking, a set of values.
The type of a variable determines which values it can have.

\term{keyword}
A reserved word used by the compiler to parse programs.
You cannot use keywords (like \java{public}, \java{class}, and \java{void}) as variable names.

\term{assignment}
A statement that stores a value in a memory location.

\term{operator}
A symbol that represents a computation like addition, multiplication, or string concatenation.

%\term{operand}
%One of the values on which an operator operates.

\term{expression}
A combination of variables, operators, and values that represents a single value.
Expressions also have types, as determined by their operators and operands.

\term{floating-point}
A data type that represents decimal numbers (numbers that have an integer part and a fractional part).
In Java, the default floating-point type is \java{double}.

\term{rounding error}
The small difference between a floating-point number and its actual representation on computer hardware.

\term{concatenate}
To join two values end-to-end.
For string values, concatenation means to append.

\term{precedence}
The order in which operations are evaluated.

\term{composition}
The ability to combine simple expressions and statements into compound expressions and statements, making it possible to represent complex computations in a concise manner.

\term{whitespace}
Newlines, tab characters, and other spaces in a source program.
Its purpose in the Java language is to separate tokens.

%\term{wildcard}
%A command-line feature that allows you to specify a pattern of file names.

\end{description}


\section{Exercises}


\begin{exercise}

If you are using this book in a class, you might enjoy this exercise.
Find a partner and play {\it Stump the Chump}:

Start with a program that compiles and runs correctly.
One player turns away while the other player adds an error to the program.
Then the first player tries to find and fix the error.
You get two points if you find the error without compiling the program, one point if you find it using the compiler, and your opponent gets a point if you don't find it.

\end{exercise}


\begin{exercise}
\label{ex:date}

The point of this exercise is (1) to use string concatenation to display values with different types (\java{int} and \java{String}), and (2) to practice developing programs gradually by adding a few statements at a time.

\begin{enumerate}

\item Create a new program named {\tt Date.java}.
Copy or type in something like the ``Hello, World!'' program and make sure you can compile and run it.

\item Following the example in Section~\ref{sec:printvar}, write a program that creates variables named \java{day}, \java{date}, \java{month}, and \java{year}.
\java{day} will contain the day of the week and \java{date} will contain the day of the month.
What type is each variable?
Assign values to those variables that represent today's date.

\item Print the value of each variable on a line by itself.
This is an intermediate step that is useful for checking that everything is working so far.

\item Modify the program so that it prints the date in standard American format, for example: {\tt Thursday, July 16, 2015}.

\item Modify the program again so that the total output is:

\begin{stdout}
American format:
Thursday, July 16, 2015
European format:
Thursday 16 July, 2015
\end{stdout}

\end{enumerate}

HINT: You should be able to copy, paste, and modify the code from Step 4 when completing Step 5.

\end{exercise}


\begin{exercise}

The point of this exercise is (1) to use some of the arithmetic operators, and (2) to start thinking about compound entities (like time of day) that that are represented with multiple values.

\begin{enumerate}

\item Create a new program called {\tt Time.java}.
From now on, we won't remind you to start with a small, working program, but you should.

\item Following the example program in Section~\ref{sec:printvar}, create variables named \java{hour}, \java{minute}, and \java{second}.
Assign values that are roughly the current time.
Use a 24-hour clock, i.e., so that at 2pm the value of \java{hour} is 14.

\item Make the program calculate and print the number of seconds since the most recent midnight.

\item Make the program calculate and print the number of seconds remaining in the day.

\item Make the program calculate and print the percentage of the day that has passed.
You might run into problems when computing percentages with integers, so consider using floating-point.

\item Change the values of \java{hour}, \java{minute}, and \java{second} to reflect the current time.
Check that the program works correctly each time you run it.

\end{enumerate}

HINT: You may want to use additional variables to hold values during the computation.
Variables that are used in a computation but never printed are sometimes called intermediate or temporary variables.

\end{exercise}


\chapter{Input and output}

%A number of years ago, Jeannette Wing published a terrific editorial with the title {\it Computational Thinking}, or in her own words, ``Ways to Think Like a Computer Scientist'' (see Communications of the ACM, March 2006).
%This 3-page article summarizes many of the problem-solving techniques you will discover while learning to program.
%Everyone interested in learning computer science beyond programming should read it.
%She defines the field this way:

%\index{computer science}

%\begin{quote}
%{\bf ``Computer science is the study of computation---what can be computed and how to compute it.''}
%\end{quote}

The programs we've looked at so far just display messages, which doesn't involve a lot of real computation.
This chapter will show you how to read input from the keyboard, use that input to calculate a result, and then format that result for output.
%We will also look at some technical details about how operating systems work.


\section{The System class}
\label{sec:system}

\index{System class}
\index{class!System}

\java{System.out.println} can display the value of any type of variable.
You can even use \java{println} to print the value of \java{System.out}:

\begin{code}
    System.out.println(System.out);
\end{code}

The result is:

\begin{stdout}
java.io.PrintStream@685d72cd
\end{stdout}

\index{package}

From this output we can see that \java{System.out} is a \java{PrintStream}, which is defined in a package called \java{java.io}.
A {\bf package} is a collection of related classes; \java{java.io} contains classes for ``I/O'' which stands for input and output.

\index{address}

After the {\tt @} sign is the location of the object in memory, which is called its {\bf address}.
In this example the address is \java{685d72cd}, but if you run the same code you will likely get something different.
%You can think of the address as a unique identifier for the object.

\index{object}

\java{System.out} is an {\bf object}, which means that it is a special value that provides methods.
Specifically, \java{System.out} provides methods for displaying output, including \java{print} and \java{println}.
Numbers with type \java{int} and \java{double} are not objects because they provide no methods.
Strings are objects; we will see some of their methods soon.

\index{library}

The \java{System} class is defined in a file called {\tt System.java}, and {\tt PrintStream} is defined in {\tt PrintStream.java}.
These files are part of the Java {\bf library}, which is an extensive collection of classes you can use in your programs.

\begin{figure}[!h]
\begin{center}
\includegraphics{figs/system.pdf}
\caption{\java{System.out.println} refers to the \java{out} variable of the \java{System} class, which is a \java{PrintStream} that provides a method called \java{println}.}
\end{center}
\end{figure}

%Both \java{System} and \java{PrintStream} are written in Java, and later in the book we'll examine their source code.
%For now, you should understand that \java{System.out} is a \java{PrintStream} object.
%Because Java is an {\em object-oriented} language, much of the library is organized around objects that perform specific actions.

% ABD: there is so much new vocab in these sections, I want to reduce the number of new ideas

%\index{operating system}

%As with most software, Java programs run on top of an {\bf operating system} that manages the keyboard, the display, main memory, disk drives, printers, the network, and other hardware resources.
%Common examples of operating systems include Android, iOS, Linux, Mac OS~X, and Windows.
%When starting Java programs, the operating system directs \java{System.out} to the screen.

%\index{abstraction}

%Note the exact type of display doesn't matter, whether it's a 5-inch touch screen or 30-inch monitor.
%From the programmer's point of view, \java{System.out} simply provides the means for printing messages.
%Computer scientists often use {\bf abstraction} to deal with the complexity of software.
%The \java{System} class is a platform-independent abstraction of the operating system.
%The operating system itself is a layer of abstraction on top of computer hardware.


\section{The Scanner class}

\index{Scanner class}
\index{class!Scanner}

%\index{byte}
%
%From the operating system's point of view, data from the keyboard arrives in a series of hardware control signals.
%The operating system translates these signals into a stream of {\bf bytes} (small integers), which in turn need to be translated into characters.
%\java{System.in} provides the means for reading one byte of input at a time, which is hardly useful for programs that would rather read in an entire word or line of input.

The \java{System} class also provides an object named \java{in}, which is an \java{InputStream} that provides methods for reading input from the keyboard.
%As with \java{System.out}, the exact type of keyboard (or even touch screen) does not matter to the programmer.
These methods perform simple operations, but they are not easy to use.
Fortunately, Java provides other classes that make it easier to handle common input tasks.

\index{class!utility}
\index{utility class}

For example, \java{Scanner} is a class that provides methods for inputting words, numbers, and other data.
\java{Scanner} is provided by \java{java.util}, which is a package that contains classes so useful they are called {\bf utility classes}.
Before you can use \java{Scanner}, you have to import it at the top of your source file:

\begin{code}
import java.util.Scanner;
\end{code}

\index{import}
\index{statement!import}

This {\bf import statement} tells the compiler that when you say \java{Scanner}, you mean the one defined in \java{java.util}.
It's necessary because there might be another class named \java{Scanner} in another package.
Using an import statement makes your code unambiguous.

Next you have to create a \java{Scanner} object using the keyword \java{new}.
%In most programs, you will need only one \java{Scanner}, since there is only one source of input.
The following code declares a \java{Scanner} variable and then creates a \java{Scanner} object:

\begin{code}
    Scanner in;
    in = new Scanner(System.in);
\end{code}

\index{argument}

Although \java{Scanner} is not a method, the syntax is the same as a method call.
We pass \java{System.in} as an argument, which specifies that we are planning to input values from the keyboard.
Alternatively, you can declare the variable and assign it using one line of code.
%This latter syntax is more convenient, since it's a one-time setup for many programs.
%Just make sure you understand that it's two statements in one.

\begin{code}
    Scanner in = new Scanner(System.in);
\end{code}

The new \java{Scanner} object (stored in the variable \java{in}) provides a method called \java{nextLine} that reads a line of input from the keyboard and returns a String.
The following example reads two lines and repeats them back to the user.

\begin{code}
import java.util.Scanner;

public class Echo {
    public static void main(String[] args) {
        String line;
        Scanner in = new Scanner(System.in);

        System.out.print("Type something:");
        line = in.nextLine();
        System.out.println("You said: " + line);

        System.out.print("Type something else:");
        line = in.nextLine();
        System.out.println("You also said: " + line);
    }
}
\end{code}

If you omit the import statement and later refer to \java{Scanner}, you will get a compiler error like ``cannot find symbol.''
That means the compiler doesn't know what you mean by \java{Scanner}.

You might wonder why we can use the \java{System} class without importing it.
\java{System} belongs to the \java{java.lang} package, which is imported automatically.
According to the documentation, \java{java.lang} ``provides classes that are fundamental to the design of the Java programming language.''
The \java{String} class is also part of the \java{java.lang} package.

\subsection{Structure of Java programs}
\label{sec:library}

At this point, we have seen all of the elements that make up Java programs.
The following figure shows these organizational units.

\begin{figure}[!h]
\begin{center}
\includegraphics[width=4in]{figs/package.pdf}
\caption{Elements of the Java language, from largest to smallest.}
\end{center}
\end{figure}

To review, a package is a collection of classes, which define methods.
Methods contain statements, some of which contain expressions.
Expressions are made up of tokens, which include variable names, numbers, operators, keywords, and punctuation like braces and semicolons.

The standard edition of Java comes with {\em several thousand} classes you can \java{import}, which can be both exciting and intimidating.
You can browse this library on Oracle's website: \url{http://docs.oracle.com/javase/7/docs/api/}
Note there is a major difference between the Java {\em language}, which deals with syntax and grammar, and the Java {\em library}, which provides the built-in classes.
In fact, most of the Java library itself is written in Java.

%To help keep things organized, classes are grouped into {\bf packages}.
%Just as each \java{class} is a separate file, each \java{package} is a separate folder.

%In order to use a class defined in another package (and in another folder), you have to {\bf import} it first.

%\begin{code}
%import java.io.File;
%import java.io.PrintStream;
%import java.util.Date;
%import java.util.Scanner;
%\end{code}

%All \java{import} statements appear at the top of the source file, above the class definition.
%It's not uncommon for Java programs to have many import statements.


\section{Inches to centimeters}

Now let's see an example that's a little more useful.
Although most of the world has adopted the metric system for weights and measures, some countries are stuck with English units.
For example, when talking with friends in Europe about the weather, people in the United States may have to convert from Celsius to Fahrenheit and back.
%And when making an international purchase online, you may have to convert your nation's currency into another based on the exchange rate.
Or you might want to convert your height in inches to centimeters.

%An everyday problem that computers are great at solving is converting numbers from one unit into another.
%For the rest of the chapter, we will look at how to write programs that solve these types of problems.
%Specifically, each program will 1) prompt the user for input, 2) read input from the keyboard, 3) calculate a result, and 4) format the result for output.
%The focus will not only be on Java syntax and language features, but also on the {\em process} of solving the problem, documenting the code, and testing the solution.

We can write a program to help.
We can use a \java{Scanner} to input a measurement in inches, convert to centimeters, and then print the results.
These lines declare the variables and create the \java{Scanner}:

% ABD: I am inclined not to include comments in most of the code
% examples because (1) I think it makes the code less cluttered and
% easier to read, and (2) they are often redundant with the text.

% I understand that it would be good to demonstrate good commenting
% style.  Despite this benefit, I think it's better to leave
% them out.  But I don't feel strongly about it.

\begin{code}
    int inch;  // the input
    double cm;  // the output
    Scanner in = new Scanner(System.in);
\end{code}

The first step is to prompt the user for the input.
We'll use \java{print} instead of \java{println} so they can enter the input on the same line.

\begin{code}
    System.out.print("How many inches? ");
    inch = in.nextInt();
\end{code}

Next we multiply the number of inches by 2.54, since that's how many centimeters there are per inch.
Finally we display the results on one line, but use two print statements since it's easier to read.

\begin{code}
    cm = inch * 2.54;
    System.out.print(inch + " in = ");
    System.out.println(cm + " cm");
\end{code}

\index{magic number}

This code works, but it has a problem.
If another programmer reads this code, they might wonder where 2.54 comes from.
Numbers that appear in an expression with no explanation are called {\bf magic numbers}.
For the benefit of other programmers (and yourself in the future), it is helpful to assign magic numbers to variables with informative names:

\begin{code}
    final double cmPerInch = 2.54;
    cm = inch * cmPerInch;
    System.out.print(inch + " in = ");
    System.out.println(cm + " cm");
\end{code}

\subsection{Literals and constants}

\index{literal}

Parts of the output we have been printing (\java{" in = "}, \java{" cm"}, etc.) are {\em literal} string values.
{\bf Literals} are data embedded directly into programs.
In contrast, variables (\java{inch}, \java{cm}, etc.) are the names of values stored in memory.
The English word {\em variable} implies that this data is subject to change.

As we saw with \java{cmPerInch}, it's often useful to give names to literals that will be used throughout the program.
But when doing so, we don't want those variables to be changed accidentally because of an unexpected bug in the code.
As another example, consider the famous card game that comes with most versions of Microsoft Windows.

\begin{code}
    final String title = "Solitaire";
    final int deckSize = 52;
\end{code}

\index{final}
\index{constant}
\index{initialize}

The keyword \java{final} indicates these variables are {\bf constants} and therefore may be assigned only one time.
Constants are generally declared and {\bf initialized} on the same line of code.
%The term initialize means to assign for the first time.
If you attempt to assign \java{title} or \java{deckSize} later in the program, the compiler will report an error.
This feature helps prevent you from making mistakes.

It's good practice to create final variables for constant values, rather than repeat literal values again and again.
For one, it makes the program easier to understand.
When looking at the code, it may not be obvious what the number \java{52} means.
The name \java{deckSize} explains the programmer's intent.
Second, named constants make the program easier to maintain.
If we want to change the title from \java{"Solitaire"} to \java{"Klondike"}, we would only need to change one line of code (as opposed to every line where that title is used).


\section{Formatting output}

When printing floating-point numbers, Java automatically decides how many decimal places to display.

% ABD: What do you think of using the DrJava interpreter format to show the result of simple examples, as in the following?

\begin{code}
    System.out.print(7.0 / 3.0);
    // prints 2.3333333333333335   note: 5 is a rounding error
\end{code}

\index{printf}
\index{argument}

\java{System.out} provides another method called \java{printf}, where the ``f'' stands for ``formatted''.
The first argument of \java{printf} is a {\em format string} that specifies how values should be displayed.
%It contains a template for the text you want to output, as well as positions where it will substitute other values.
The other arguments are the values themselves.

\begin{code}
    System.out.printf("Seven thirds = %.3f", 7.0 / 3.0);
    // prints Seven thirds = 2.333
\end{code}

\index{format specifier}

This format string contains ordinary text followed by a {\bf format specifier}, which is a special sequence that starts with a percent sign.
The format specifier \verb"%.3f" indicates that the value should be displayed as floating-point with three decimal places.
Here's an example that contains two format specifiers:

\begin{code}
   inch = 100;
   cm = inch * cmPerInch;
   System.out.printf("%d in = %f cm\n", inch, cm);
   // prints 100 in = 254.000000 cm
\end{code}

The values are matched up with the format specifiers in order, so \java{inch} is displayed as an integer (``d'' stands for ``decimal'') and \java{cm} is displayed as a floating-point number.
Format strings often end with a newline character (\verb"\n"), since \java{printf} does not append a newline like \java{println} does.

Learning \java{printf} is like learning a sub-language within Java.
There are many options, and the details can be overwhelming.
But here are some common uses, to give you an idea of how it works:

\begin{table}[!h]
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
\verb"%d" & decimal integer & 12345 \\
\hline
\verb"%,d" & decimal integer with comma separators & 12,345 \\
\hline
\verb"%08d" & padded with zeros, at least 8 digits wide & 00012345 \\
\hline
\verb"%f" & floating-point & 6.789000 \\
\hline
\verb"%.2f" & floating-point {\em rounded} to 2 decimal places & 6.79 \\
\hline
\end{tabular}
\caption{Example format specifiers}
\end{center}
\end{table}

For more details, refer to the documentation of \java{java.util.Formatter}
or search the web for ``java formatting.''


\section{Centimeters to inches}
\label{sec:rounding}

Now suppose we have a measurement in centimeters and we want to round it off to the nearest inch.
It is tempting to write:

\begin{code}
    inch = cm / centPerInch;  // syntax error
\end{code}

But the result is an error---you get something like, ``Bad types in assignment: from double to int.''
The problem is that the value on the right is floating-point and the variable on the left is an integer.

%Java converts an \java{int} to a \java{double} automatically, since no information is lost in the process.
%On the other hand, going from \java{double} to \java{int} gets rid of the decimal places.
%Java doesn't perform this operation automatically in order to ensure that you are aware of the loss of the fractional part of the number.

\index{type cast}
\index{operator!cast}

The simplest way to convert a floating-point value to an integer is to use a {\bf type cast}, so called because it molds or ``casts'' a value from one shape to another.
The syntax for type casting is to put the name of the type in parentheses and use it as an operator.

\begin{code}
    double pi = 3.14159;
    int x = (int) pi;
\end{code}

%\index{truncate}

The \java{(int)} operator has the effect of converting what follows into an integer.
In this example, \java{x} gets the value \java{3}.
Converting to an integer always rounds {\em toward zero}, even if the fraction part is \java{0.999999} (or \java{-0.999999}).

Type casting takes precedence over arithmetic operations.
In this example, the value of \java{pi} gets converted to an integer first.
So the result is 60.0, not 62.

\begin{code}
    double pi = 3.14159;
    double x = (int) pi * 20.0;
\end{code}

%Operator precedence and integer truncation make type casting somewhat error-prone.

Keeping that in mind, here's how we can convert a measurement in centimeters to inches.

\begin{code}
    inch = (int) (cm / centPerInch);
    System.out.printf("%f cm = %d in\n", cent, inch);
\end{code}

The parentheses after the cast operator require the division to come before the type cast.
This result will be rounded toward zero, but we will learn in the next chapter how to round floating-point numbers to the closest integer.

\subsection{Modulus operator}

Let's take the example one step further: suppose you have a measurement in inches and you want to convert to feet and inches.
The goal is divide by 12 (the number of inches in a foot) and keep the remainder.

\index{modulus}
\index{operator!modulus}

We have already seen the division operator (\java{/}), which computes the quotient of two numbers.
If the numbers are integers, it performs integer division.
Java also provides the {\bf modulus} operator (\java{\%}), which divides two numbers and computes the remainder.

Assuming the following variables are integers, we can convert 76 inches to feet and inches like this:

\begin{code}
    quotient = 76 / 12;   // division
    remainder = 76 % 12;  // modulus
\end{code}

The first line yields 6.
The second line, which is pronounced ``76 mod 12,'' yields 4.
So 76 inches is 6 feet, 4 inches.

Although the modulus operator is a percent sign, you might find it helpful to think of it as a division sign ($\div$) rotated to the left.
Note that both \java{/} and \java{\%} perform {\em integer division}.
The reason why integer division ``rounds down'' is that the hardware computes the quotient and remainder separately.
%Many algorithms, including the example above, perform division and modulus together.

\index{divisible}
\index{extract digits}

Integer division turns out to be surprisingly useful.
For example, you can check whether one number is divisible by another: if \java{x \% y} is zero, then \java{x} is divisible by \java{y}.
You can also use modulus to ``extract'' digits from a number: \java{x \% 10} yields the rightmost digit of \java{x}, and \java{x \% 100} yields the last two digits.
Also, many encryption algorithms are based on modular arithmetic.


\section{Putting it all together}

%\begin{itemize}

%% Chapter 1
%\item Write a class and main
%\item Display simple output
%\item Compile and run programs
%\item Correct syntax errors

%% Chapter 2
%\item Declare/assign variables
%\item Create named constants
%\item Perform basic arithmetic
%\item Compose multiple operations

%% Chapter 3
%\item Browse the Java library
%\item Import Java library classes
%\item Initialize a Scanner object
%\item Get input from the keyboard
%\item Read/write documentation
%\item Format output with printf
%\item Divide and mod integers

%\end{itemize}

At this point you know enough Java to write useful programs that solve everyday problems.
You've seen how to 1) import Java library classes, 2) initialize a \java{Scanner} object, 3) get input from the keyboard, 4) format output with \java{printf}, and 5) divide and mod integers.
Now we can put them together in a complete program:

%Since we've looked at each of these topics in isolation, it's important to see how they fit together in a complete program.
%If you've been working through the examples on your computer as you've been reading (like we recommended in Section~\ref{sec:examples}), then good job!

\begin{code}
import java.util.Scanner;

/**
 * Converts centimeters to feet and inches.
 */
public class Convert {
    public static void main(String[] args) {
        double cm;
        int feet, inches;
        final double centPerInch = 2.54;
        Scanner in = new Scanner(System.in);

        // prompt the user and get the value
        System.out.print("Exactly how many cm? ");
        cm = in.nextDouble();

        // convert and output the result
        inches = (int) (cm / centPerInch);
        feet = inches / 12;
        inches = inches % 12;
        System.out.printf("%.2f cm = %d ft, %d in\n",
                          cm, feet, inches);
    }
}
\end{code}

\begin{itemize}

\item Although not required, all variables and constants are declared at the top of \java{main}.
This practice makes it easier to find their types later on and helps the reader know what data is involved in the algorithm.

\item For readability, each major step of the algorithm is separated by a blank line and begins with a comment.

\item Integer division and modulus often go together.
Notice how \java{inches} gets reassigned (which replaces its value) just before the \java{printf}.

\item When statements get long (generally wider than 80 characters), a common style convention is to break them across multiple lines.
The reader should never have to scroll horizontally.

\end{itemize}

%As an exercise, try running this code through Checkstyle.


\section{The Scanner bug}

Now that you've had some experience with \java{Scanner}, there is an unexpected behavior we want to warn you about.
Consider a simple program that asks users for their name and age.
Somewhere in the middle of the code, we have the following lines:

\begin{code}
    System.out.print("What is your name? ");
    name = in.nextLine();
    System.out.print("What is your age? ");
    age = in.nextInt();
    System.out.printf("Hello %s, age %d\n", name, age);
\end{code}

The output of the \java{printf} statement looks something like this:

\begin{stdout}
Hello Darth Vader, age 45
\end{stdout}

When you read a \java{String} followed by an \java{int}, everything works just fine.
But when you read an \java{int} followed by a \java{String}, something strange happens.

\begin{code}
    System.out.print("What is your age? ");
    age = in.nextInt();
    System.out.print("What is your name? ");
    name = in.nextLine();
    System.out.printf("Hello %s, age %d\n", name, age);
\end{code}

Try running the above example.
It doesn't let you input your name and immediately displays the output:

\begin{stdout}
What is your name? Hello , age 45
\end{stdout}

To understand what is happening, recall that computers do not {\em see} input as multiple lines like we do.
Instead, the operating system simply forwards a stream of characters to your program via \java{System.in}:

\begin{center}
\includegraphics{figs/vader1.pdf}
\end{center}

The up-arrow represents the next character to be read by \java{Scanner}.
When you call \java{nextInt}, it will read characters until a non-digit is found.

\begin{center}
\includegraphics{figs/vader2.pdf}
\end{center}

At this point, \java{nextInt} returns the \java{int} value \java{45}.
The program then asks \java{"What is your name? "} and calls \java{nextLine}.
\java{Scanner} will read characters until a newline is found.
Since the next character to be read already is a newline, \java{nextLine} returns the empty string \java{""}.

To solve this problem, you need to add an extra call to \java{nextLine} after you call \java{nextInt}.

\begin{code}
    System.out.print("What is your age? ");
    age = in.nextInt();
    in.nextLine();  // read the newline
    System.out.print("What is your name? ");
    name = in.nextLine();
    System.out.printf("Hello %s, age %d\n", name, age);
\end{code}

This technique is common when reading \java{int} or \java{double} values that appear on their own line.
First you read the number, then you read the rest of the line (which is just a newline character).
Note that you do not have to assign the return value of \java{nextLine} to a variable in that case; you can simply ignore it.


\section{Command-line testing}

You should review the advice in Section~\ref{sec:examples}, now that you've written some more substantial programs.
Remember, it's more effective to program and debug your code little by little than to attempt writing everything at once.
And once you've completed programming an algorithm, it's important to test that it works correctly on a variety of inputs.

Throughout the book, we will illustrate techniques for testing your programs.
Most if not all testing is based on a simple idea: does the program do what we expect it to do?
For simple programs, it's not difficult to run them several times and see what happens.
But at some point, you will get tired of typing the same test cases over and over.

We can automate the process of entering input and comparing {\em expected output} with {\em actual output} using the command-line.
The basic idea is to store the test cases in plain text files and trick Java into thinking they are coming from the keyboard.
Here are step by step instructions.

\begin{enumerate}

\item Make sure you can compile and run the {\tt Convert.java} example in the previous section.
%You can also download a copy from \url{http://thinkjava.org/}.

\item In the same directory as {\tt Convert.java}, create a plain text file named {\tt test.in} (``in'' is for input).
Enter the following line and save the file.

\begin{stdout}
193.04
\end{stdout}

\item Create a second plain text file named {\tt test.exp} (``exp'' is for expected).
Enter the following line and save the file.

\begin{stdout}
193.04 cm = 6 ft, 4 in
\end{stdout}

\item Open a command-line, and change to the directory with these files.
Run the following command to test the program.

\begin{stdout}
java Convert < test.in > test.out
\end{stdout}

\end{enumerate}

\index{redirection operator}

On the command-line, {\tt <} and {\tt >} are {\bf redirection operators}.
The first one redirects the contents of {\tt test.in} to \java{System.in}, as if it were entered from the keyboard.
The second one redirects the contents of \java{System.out} to a new file {\tt test.out}, much like a screen capture.
In other words, the {\tt test.out} file contains the output of your program.

% ABD: Since I killed the previous reference to abstraction, I am inclined
% to kill this one too.  The problem in both places is that it pulls the
% focus off topic.

%Redirecting a program's input and output is an example of how computer scientists use abstraction.
%Notice that \java{System.in} is not called \java{Keyboard}, and \java{System.out} is not called \java{Display}.
%In practice, these objects could be text files, network connections, microphones and speakers, or some other byte streams.
%What's great is that doesn't change anything about how you write the code.

By the way, it's perfectly okay to compile your programs in DrJava (or some other environment) and run them from the command-line.
Knowing both techniques allows you to use the right tool for the job.

At this point, we just need to compare the contents {\tt test.out} with {\tt test.exp}.
If the files are the same, then the program outputted what we expected it to output.
If not, then we found a bug, and we can use the output to begin debugging our program.
Fortunately, there's a simple way to compare files on the command-line:

\begin{stdout}
diff test.exp test.out
\end{stdout}

The {\tt diff} utility summarizes the differences between two files.
If there are no differences, then it prints nothing, which in our case is what we want.
If the expected output differs from the actual output, then we need to continue debugging.
Usually the program is at fault, and {\tt diff} provides some insight about what is broken.
But there's also a chance that we have a correct program and the expected output is wrong.

Interpreting the results from {\tt diff} can be confusing, but fortunately there are many graphical tools that show the differences between two files. For example, on Windows you can install WinMerge, on Mac you can use {\tt opendiff} (which comes with Xcode), and on Linux there's {\tt meld}. Regardless what tool you use, the goal is the same. Debug your program until the actual output is {\it identical} to the expected output.

\begin{figure}[!h]
\begin{center}
\includegraphics[width=0.9\textwidth]{figs/meld.png}
\caption{Using {\tt meld} to compare the expected output with the actual output.}
\end{center}
\end{figure}


\section{Vocabulary}

\begin{description}

\term{package}
A group of classes that are related to each other.
Java classes are organized into packages.

\term{address}
The storage location of a variable or object in memory.
Addresses are integers encoded in hexadecimal (base 16).

\term{object}
An abstract entity that represents data and performs actions.
In Java, objects are stored in memory and referenced by variables.

\term{library}
A collection of packages and classes that are available for use in other programs.
Libraries are often distributed in {\tt .jar} (Java Archive) files.

%\term{operating system}
%Software that is always running behind the scenes on your computer.
%It controls the execution of application programs and manages hardware resources.

%\term{abstraction}
%The process of reducing information and/or detail to focus on high-level concepts.

%\term{byte}
%A single unit of data on a computer; enough to represent one character.

\term{utility class}
A class that provides commonly needed functionality.

\term{import}
A statement that allows programs to use classes defined in other packages.

\term{magic number}
A unique value with unexplained meaning or multiple occurrences.
They should generally be replaced with named constants.

\term{literal}
A constant value written directly in the source code.
For example, \java{"Hello"} is a string literal and \java{74} is an integer literal.

\term{constant}
A variable that can only be assigned one time.
Once initialized, its value cannot be changed.

\term{initialize}
To assign an initial value to a variable.

\term{format specifier}
A special code beginning with percent sign and ending with a single letter that stands for the data type.

\term{type cast}
An operation that explicitly converts one data type into another, sometimes with loss of information.
In Java it appears as a type name in parentheses, like \java{(int)}.

%\term{truncate}
%To make shorter by cutting something off.
%Casting a floating-point value to an integer simply removes the fractional part.

\term{modulus}
An operator that yields the remainder when one integer is divided by another.
In Java, it is denoted with a percent sign (e.g., \java{5 \% 2} is \java{1}).

\term{redirection operator}
A command-line feature that substitutes \java{System.in} and/or \java{System.out} with a plain text file.

\end{description}


\section{Exercises}


\begin{exercise}

When you use \java{printf}, the Java compiler does not check your formatting string.
See what happens if you try to display value with type \java{int} using \verb"%f".
And what happens if you display a \java{float} using \verb"%d"?
What if you use two format specifiers, but then only provide one value?

\end{exercise}


\begin{exercise}

TODO

\end{exercise}


\begin{exercise}

TODO

\end{exercise}


\chapter{Void methods}
\label{voidmeth}

So far we've only written short programs that have a single class with a \java{main} method.
In this chapter, we'll show you how to organize longer programs into multiple methods and classes.
%We will also take a look at separate compilation.

\index{method}

% ABD: In theory I like the idea of providing a chapter overview, but
% in practice I find them impossible to write without breaking the rules
% (like using terms before defining them, etc)

At a conceptual level, a {\bf method} represents a mathematical {\em function} or a general {\em procedure}.
Some methods perform a computation and return a result.
For example, \java{Math.sqrt(25)} returns the value \java{5.0}.
Other methods (including \java{main}) carry out a sequence of actions without returning a result.
Java uses the keyword \java{void} to declare such methods.
Regardless whether they return a value or not, methods enable you to break down a complex program into smaller blocks of code.


\section{Math methods}

\index{Math class}
\index{class!Math}
\index{expression}
\index{argument}

In mathematics, you have probably seen functions like $\sin$ and $\log$, and you have learned to evaluate expressions like $\sin(\pi/2)$ and $\log(1/x)$.
First, you evaluate the expression in parentheses, which is called the {\bf argument} of the function.
Then you can evaluate the function itself, maybe by punching it into a calculator.

This process can be applied repeatedly to evaluate more complex expressions like $\log(1/\sin(\pi/2))$.
First we evaluate the argument of the innermost function, then evaluate the function itself, and so on.

\index{invoke}

The Java library includes a \java{Math} class that provides most common mathematical operations.
%These functions are called {\bf methods}.
\java{Math} is in the \java{java.lang} package, so you don't have to import it.
You can {\bf invoke} Math methods like this:

\begin{code}
    double root = Math.sqrt(17.0);
    double angle = 1.5;
    double height = Math.sin(angle);
\end{code}

The first line sets \java{root} to the square root of 17.
The third line finds the sine of the value of \java{angle}.

\index{degrees}
\index{radians}

Arguments of the trigonometric functions---\java{sin}, \java{cos}, and \java{tan}---should be in {\em radians}.
To convert from degrees to radians, you can divide by 180 and multiply by $\pi$.
Conveniently, the \java{Math} class provides a \java{final double} named \java{PI} that contains an approximation of $\pi$:

\begin{code}
    double degrees = 90;
    double angle = degrees / 180.0 * Math.PI;
\end{code}

Notice that \java{PI} is in capital letters.
Java does not recognize \java{Pi}, \java{pi}, or \java{pie}.
Also, \java{PI} is the name of a variable, not a method, so it doesn't have parentheses.
The same is true for the constant \java{Math.E}, which approximates Euler's number.

It turns out that converting to/from radians is a common operation, so the \java{Math} class provides methods for that.

\begin{code}
    double radians = Math.toRadians(180.0);
    double degrees = Math.toDegrees(Math.PI);
\end{code}

\index{type!long}

If you haven't already, take a look at the documentation for \java{Math} so you know what methods are provided.
For example, another useful method is \java{round}, which rounds a floating-point value to the nearest integer and returns a \java{long}.

\begin{code}
    long x = Math.round(Math.PI * 20.0);
\end{code}

In Java, \java{int} values are stored using 32 bits (4 bytes) of memory, whereas \java{long} values are stored in 64 bits (8 bytes).
As a result, \java{long} variables can represent much larger integers.
In the above example, the multiplication happens first, before the method is invoked.
The result is 63 (rounded up from 62.8319).

\subsection{Composition revisited}

\index{composition}
\index{expression}

Just as with mathematical functions, Java methods can be {\bf composed}.
That means you can use one expression as part of another.
For example, you can use any expression as an argument to a method:

\begin{code}
    double x = Math.cos(angle + Math.PI / 2);
\end{code}

This statement takes the value \java{Math.PI}, divides it by two, and then adds the result to the value of the variable \java{angle}.
The sum is then passed as an argument to \java{cos}.
You can also take the result of one method and pass it as an argument to another:

\begin{code}
    double x = Math.exp(Math.log(10.0));
\end{code}

In Java, the \java{log} method always uses base $e$.
So this statement finds the log base $e$ of 10, and then raises $e$ to that power.
The result gets assigned to \java{x}.
%Do you know what it is without reaching for a calculator?

When using \java{Math} methods, it is a common error to forget to specify the class name \java{Math}.
For example, \java{Math.pow} takes two arguments and raises the first argument to the power of the second.

\begin{code}
    pow(2.0, 10.0);  // syntax error
\end{code}

If you try to invoke \java{Math.pow} this way, the compiler will say it ``cannot find symbol'' (i.e., there is no method named \java{pow} in the current class).


\section{Adding new methods}
\label{adding_methods}

\index{method!definition}
\index{main}
\index{method!main}

Like the \java{Math} class, you can write your own set of methods for use in other programs.
%One of the most powerful features of a programming language is the ability to add new methods.
Let's revisit the method definition for \java{main}:

\begin{code}
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
\end{code}

\index{public}
\index{void}
\index{type!void}

The first line contains information about the method:
\java{main} is a \java{public} method, which means it can be invoked from other classes;
it is a \java{static} method, but we're not going to explain what that means yet;
and it is a \java{void} method, which means that it doesn't yield a result (unlike the \java{Math} methods).

\index{parameter}

The statement in parentheses declares a parameter named
\java{args}.  A {\bf parameter} is a variable that stores an argument.
This parameter has type \java{String[]}, which means that whoever invokes \java{main} must provide an array of Strings (we'll get to arrays in a later chapter).

You can define other methods using syntax that is similar to \java{main}:

\begin{code}
    public static void NAME(PARAMETERS) {
        STATEMENTS
    }
\end{code}

By convention, methods start with a lower case letter and use ``camel case,'' which is a cute name for \java{jammingWordsTogetherLikeThis}.
You can use any name you want for your method, except \java{main} or any of the Java keywords.

% TODO: move the definition of ``argument'' to Ch3?

The list of parameters specifies what values, if any, you have to provide in order to invoke the new method.
The first methods we are going to write have no parameters, so the parameter list is empty.  Here's an example:

\begin{code}
    public static void newLine() {
        System.out.println();
    }
\end{code}

The name of this method is \java{newLine}.
It contains only one statement, which prints a blank line.
In \java{main}, we can invoke the new method like this:

\begin{code}
    public static void main(String[] args) {
        System.out.println("First line.");
        newLine();
        System.out.println("Second line.");
    }
\end{code}

Because \java{newLine} is in the same class as \java{main}, we don't have to specify the class name.
The output of this program is:

\begin{stdout}
First line.

Second line.
\end{stdout}

Notice the extra space between the lines.
If we wanted more space between them, we could invoke the same method repeatedly:

\begin{code}
    public static void main(String[] args) {
        System.out.println("First line.");
        newLine();
        newLine();
        newLine();
        System.out.println("Second line.");
    }
\end{code}

Or we could write a new method that prints three blank lines:

\begin{code}
    public static void threeLine() {
        newLine();
        newLine();
        newLine();
    }

    public static void main(String[] args) {
        System.out.println("First line.");
        threeLine();
        System.out.println("Second line.");
    }
\end{code}

You can invoke the same method more than once, and you can have one method invoke another.
In this example, \java{main} invokes \java{threeLine}, and \java{threeLine} invokes \java{newLine}.

%In \java{threeLine} I wrote three statements all on the same line, which is syntactically legal (remember that spaces and new lines usually don't change the meaning of a program).
%It is usually a good idea to put each statement on its own line, but I sometimes break that rule.

You might wonder why it is worth the trouble to create new methods.
There are many reasons, but this example demonstrates a few of them:

\begin{enumerate}

\item Creating a new method gives you an opportunity to give a name to a group of statements, which makes code easier to read and understand.
%Methods simplify a program by hiding complex computations behind a single statement, and by using English words in place of arcane code.
%Which is clearer, \java{newLine} or \java{System.out.println()}?

\item Introducing new methods can make a program smaller by eliminating repetitive code.
For example, to print nine consecutive new lines, you could invoke \java{threeLine} three times.

\item A common problem-solving technique is to break things down into sub-problems.
Methods allow you to focus on each sub-problem in isolation, and then compose them into a complete solution.

\end{enumerate}

%Perhaps most importantly, organizing your code into multiple methods allows you to test individual parts of your program separately.
%It's easier to get a complex program working if you know that each sub-part works correctly.

%In Section~\ref{methods} we will come back to this question and list some additional benefits of dividing programs into methods.


\section{Classes and methods}

\index{class}
\index{method}

Pulling together the code from the previous section, the complete program looks like this:

\begin{code}
public class NewLine {

    public static void newLine() {
        System.out.println();
    }

    public static void threeLine() {
        newLine();
        newLine();
        newLine();
    }

    public static void main(String[] args) {
        System.out.println("First line.");
        threeLine();
        System.out.println("Second line.");
    }
}
\end{code}

\index{case-sensitive}

The first line is the class definition.
Class names should be capitalized; this convention helps readers tell the difference between classes and methods in your source code.
The \java{NewLine} class contains three \java{void} methods: \java{newLine}, \java{threeLine}, and \java{main}.
Java is a case-sensitive language, so \java{NewLine} and \java{newLine} are considered different.

\subsection{Programs with multiple methods}

\index{order of execution}

When you look at a class definition that contains several methods, it is tempting to read it from top to bottom.
But that is likely to be confusing, because that is not the {\bf order of execution} of the program.

Execution always begins at the first statement of \java{main}, regardless of where it is in the source file.
In the previous example, we deliberately put \java{main} at the bottom of the program.
Statements are executed one at a time, in order, until you reach a method invocation.
Think of method invocations as a detour in the flow of execution.
Instead of going to the next statement, you go to the first line of the invoked method, execute the statements there, and then come back and pick up again where you left off.

That sounds simple enough, but remember that one method can invoke another one.
In the middle of \java{main}, we go off to execute the statements in \java{threeLine}.
But while we are executing \java{threeLine}, we go off to execute \java{newLine}.
Then \java{newLine} invokes \java{println}, which causes yet another detour.

Fortunately, Java is adept at keeping track of where it is.
So when \java{println} completes, it picks up where it left off in \java{newLine}, and then gets back to \java{threeLine}, and then finally gets back to \java{main} so the program can terminate.
In summary, when you read a program, don't read from top to bottom.
Instead, follow the flow of execution.

%Technically, the program does not terminate at the end of \java{main}.
%Instead, execution picks up where it left off in the program that invoked \java{main}, which is the Java interpreter.
%The interpreter takes care of things like deleting windows and general cleanup, and {\em then} the program terminates.


\section{Parameters and arguments}

\index{parameter}
\index{argument}

Some of the methods we have used require arguments, which are values that you provide when you invoke the method.
For example, to find the sine of a number, you have to provide the number.
So \java{sin} takes a \java{double} as an argument.
To print a message, you have to provide the string.
So \java{println} takes a \java{String} as an argument.
Some methods take more than one argument.
For example, \java{Math.pow} takes two \java{double}s: the base and the exponent.

When you use a method, you provide the arguments.
When you write a method, you list the parameters.
The parameter list indicates what arguments are required.
Here's a method that takes a string and prints it twice:

\begin{code}
    public static void printTwice(String s) {
        System.out.println(s);
        System.out.println(s);
    }
\end{code}

\java{printTwice} has a parameter named \java{s} with type \java{String}.
The parameter name hints that it is a \java{String}, but you could use any legal variable name.
When we invoke \java{printTwice}, we have to provide an argument with type \java{String}.
Before the method executes, the argument gets assigned to the parameter.

In this example, the argument \java{"Don't make me say this twice!"} gets assigned to the parameter \java{s}.

\begin{code}
    printTwice("Don't make me say this twice!");
\end{code}

\index{parameter passing}

This process is called {\bf parameter passing} because the value gets passed from outside the method to the inside.
An argument can be any kind of expression, so if you have a \java{String} variable, you can use it as an argument:

\begin{code}
    String argument = "Never say never.";
    printTwice(argument);
\end{code}

The value you provide as an argument must have the same type as the parameter.
For example, if you try:

\begin{code}
    printTwice(17);  // syntax error
\end{code}

You will get the compiler error ``cannot find symbol,'' which might be confusing.
Java is looking for a method named \java{printTwice} that can take an integer.
Since there isn't one in the current class, Java can't find such a ``symbol.''

There are some apparent exceptions to this rule, because sometimes Java converts from one type to another automatically.
For example, \java{Math.sqrt} requires a \java{double} value.
If you run \java{Math.sqrt(25)}, the interger value \java{25} is automatically converted to the floating-point value \java{25.0}.

\java{System.out.println} can accept any type as an argument.
But generally speaking, that is an exception; most methods are not so accommodating.

\subsection{Methods with multiple parameters}
\label{time}

\index{parameter!multiple}
\index{method!multiple parameter}
\index{class!Time}

The syntax for declaring and invoking methods with multiple parameters is a common source of confusion.
For one, you have to declare the type of every parameter separately.

\begin{code}
    public static void printTime(int hour, int minute) {
        System.out.print(hour);
        System.out.print(":");
        System.out.println(minute);
    }
\end{code}

It might be tempting to write ``\java{int hour, minute}'' but that format is only legal for variable declarations, not parameter lists.
Another common source of confusion is that you do not have to declare the types of arguments in a method call.
The following is incorrect:

\begin{code}
    int hour = 11;
    int minute = 59;
    printTime(int hour, int minute);  // syntax error
\end{code}

In this case, Java can tell the type of \java{hour} and \java{minute} by looking at their declarations.
It is unnecessary (and therefore not allowed) to include the type when you pass them as arguments.
The correct syntax is:

\begin{code}
    printTime(hour, minute);
\end{code}

When you call a method, Java {\it copies the value} of any arguments you provide into the method's parameters.
It's common for two methods (e.g., \java{main} and \java{printTime}) to have variables with the same name, to show how data passes from one method to the next.
But remember that these variables are stored in different memory locations.
Changing the value of \java{hour} or \java{minute} in \java{printTime} has no effect on the original variables in \java{main}.


\section{Reading documentation}
\label{sec:apidocs}

\index{documentation}

For a comprehensive example of what methods are like, take a look at the documentation for \java{Scanner}.
You can find it in the Java library (see the link in Section~\ref{sec:library}) or simply do a web search for ``java scanner.''
The latter technique is more useful in the long run, especially as Oracle releases new versions of Java.
Either way, you should get something like Figure~\ref{fig:javadoc}.

\begin{figure}[!h]
\begin{center}
\includegraphics[width=0.9\textwidth]{figs/scanner.png}
\caption{Screenshot of the documentation for \java{Scanner} on Oracle's website.}
\label{fig:javadoc}
\end{center}
\end{figure}

Scroll down to the ``Method Summary'' section.
In the previous chapter, we introduced methods for reading the ``next'' input.
As you can see, the \java{Scanner} class provides quite a few of them.
Click on the link for \java{nextInt}, and it will scroll down to more details:

\begin{stdout}
public int nextInt()
Scans the next token of the input as an int.
\end{stdout}

\index{signature}

The first line is the method's {\bf signature}, which specifies the name of the method, its return type, and parameters.
In this example, \java{nextInt} returns an \java{int}.
The empty parentheses mean that \java{nextInt} has no parameters.
The next line explains what the method does.
The subsequent lines (not shown) describe each parameter (if any) and the return value.
Explanations are often redundant, but the documentation is supposed to fit this standard format.
%The last line describes the exceptions this method might throw.

It might take some time to get comfortable reading this kind of information, but it's well worth the effort.
Knowing what methods a class provides helps you avoid reinventing the wheel.
Whenever you learn about a new class, you should take a quick look at its documentation.
On that note, take a few minutes to review the documentation for \java{System} and \java{String}.


\section{Writing documentation}

\index{Javadoc}

A nice feature of the Java language is the ability to write documentation at the same time you are writing the source code.
That way, the documentation stays in sync with the classes and methods themselves.
In fact, the HTML pages you browsed in the previous section were automatically generated using a tool called {\bf Javadoc}.
This tool is part of the standard JDK, and you can run it directly from DrJava by pressing the {\tt Javadoc} button on the toolbar.

\index{comments!documentation}
\index{documentation comments}

Javadoc parses your source files for {\bf documentation comments} and extracts other relevant information about your class and method definitions.
Given the prevalence of this tool, people sometimes refer to documentation as ``Javadoc comments.''
In contrast to inline comments that begin with \java{//}, documentation comments begin with \java{/**} (two stars) and end with \java{*/} (one star).
Anything in between these two tokens becomes part of the documentation.
%As a rule of thumb, you should document every class and every method.

\begin{code}
/**
 * Example program that demonstrates print vs println.
 */
public class Goodbye {

    /**
     * Application entry point; simply prints a greeting.
     */
    public static void main(String[] args) {
        System.out.print("Goodbye, ");  // note the space
        System.out.println("cruel world");
    }

}
\end{code}

This example has perhaps too many comments, since all the program does is print a single message.
But it illustrates the differences between inline and documentation comments:

\begin{itemize}
\item Inline comments tend to be short phrases that help explain complex parts of a method.
Documentation comments are typically complete sentences that begin with a capital letter and end with a period.

\item Documentation comments often span multiple lines.
By convention, each line begins with a \java{*} that is aligned vertically with the start and end of the comment.

\item Some development environments (e.g., Eclipse and NetBeans) automatically display documentation comments when you hover your mouse over the name of a class or method.

\end{itemize}

Writing documentation and inline comments is essential for making source code readable.
As we discussed in an earlier chapter, people spend the majority of their development time understanding and modifying existing code.
You should not only write good comments for others, but for yourself as well.
When you haven't looked at your own code for a while, it takes a long time to remember how it works (or what you were trying to do) if there's no comments.


\section{Stack diagrams and scope}
\label{stack}

\index{stack diagram}
\index{diagram!stack}

Pulling together the code examples from the previous section, here is a complete
class definition:

\begin{code}
public class PrintTwice {

    public static void printTwice(String s) {
        System.out.println(s);
        System.out.println(s);
    }

    public static void main(String[] args) {
        String argument = "Never say never.";
        printTwice(argument);
    }

}
\end{code}

Parameters and other variables only exist inside their own methods.
Within the confines of \java{main}, there is no such thing as \java{s}.
If you try to use it there, the compiler will complain.
Similarly, inside \java{printTwice} there is no such thing as \java{argument}.
That variable belongs to the \java{main} method.

One way to keep track of where each variable is defined is to draw a {\bf stack diagram}.
The stack diagram for this example looks like this:

\begin{figure}[!h]
\begin{center}
\includegraphics[scale=0.9]{figs/stack.pdf}
\caption{Stack diagram for the \java{PrintTwice} program.}
\end{center}
\end{figure}

\index{frame}

For each method there is a box called a {\bf frame} that contains the method's parameters and variables.
The name of the method appears outside the frame.
The value of each variable is drawn inside a box with the name of the variable beside it.
(Note for people who know too much: this diagram leaves out an important detail about strings that we will explain later.)

\index{scope}

Stack diagrams help you to visualize the {\bf scope} of a variable, which is the area of a program where a variable exists.
It's possible to have two variables with the same name in two different methods.
Each only exists within its own method, so they don't interfere with each other.


\section{Tracing with a debugger}
\label{debugger}

\index{debugger}

Keeping track of variables and methods on paper is a useful skill, and you should practice drawing stack diagrams.
Another way to visualize the scope of variables and the flow of execution is to use a {\bf debugger}.
Regardless which development environment you use, the overall process is the same:

\index{breakpoint}

\begin{enumerate}
\item Set {\bf breakpoints} on lines where you want the program to pause.
\item Step through the code one line at a time and watch what it does.
\item Check the values of variables and see when and how they change.
\end{enumerate}

For example, open any program in DrJava and move the cursor to the first line of \java{main}.
Press Ctrl+B to toggle a breakpoint on the current line; it should now be highlighted in red.
Press Ctrl+Shift+D to turn on Debug Mode; a new pane should appear at the bottom of the window.
(These commands are also available from the {\em Debugger} menu, in case you forget the shortcut keys.)

\index{call stack}

When you run the program, execution pauses at the first breakpoint.
The debug pane shows the {\bf call stack}, with the current method on top of the stack.
You might be surprised to see how many methods were called before the \java{main} method!
To the right are several buttons that allow you to step through the code at your own pace.
You can also press ``Automatic Trace'' to watch DrJava run your code one line at a time.

\begin{figure}[!h]
\begin{center}
\includegraphics[width=\textwidth]{figs/debugger.png}
\caption{Screenshot of the DrJava debugger.
Execution is currently paused on the first line of \java{printTwice}.
There is a breakpoint on the first line of \java{main}.}
\end{center}
\end{figure}

Using a debugger is like having the computer proofread your code out loud.
When the program is paused, you can examine (or even change) the value of any variable using the Interactions Pane.
Tracing allows you to verify how control and data passes from one method to another.
%You can edit your code while debugging it, but the changes won't take effect until after you compile.
%The result can be confusing, so we don't recommend it.
%The debugger may get out of sync if you add or delete multiple lines of code while the program is paused.
You might expect the code do one thing, but then the debugger shows it doing something else.
At that moment, you gain insight about what may be wrong with the code.


\section{Vocabulary}

\begin{description}

% Note: expanded definition from Chapter 1
\term{method}
A named sequence of statements that performs a procedure or function.
Methods may or may not take parameters, and may or may not return a value.

\term{invoke}
To call or run a method, i.e., cause it to execute.

\term{parameter}
A piece of information that a method requires before it can run.
Parameters are variables: they contain values and have types.

\term{argument}
A value that you provide when you invoke a method.
This value must have the same type as the corresponding parameter.

% Note: expanded definition from Chapter 2
\term{composition}
The ability to combine simple expressions and statements into compound expressions and statements, making it possible to use intermediate computations as arguments.

\term{order of execution}
The order in which Java executes methods and statements.
It may not necessarily be from top to bottom, left to right.

\term{parameter passing}
The process of assigning an argument value to a parameter variable.

\term{signature}
The first line of a method that defines its name, return type, and parameters.

\term{Javadoc}
A tool that reads Java source code and generates documentation in HTML format.

\term{documentation}
Comments that describe the technical operation of a class or method.

\term{stack diagram}
A memory diagram that shows which variables belong to which methods at a certain point in the program.
The methods calls are ``stacked'' from top to bottom, in the order of execution.

\term{frame}
A structure (represented by a box in stack diagrams) that contains a method's parameters and variables.

\term{scope}
The area of a program where a variable exists.

\term{debugger}
A tool that allows you to run one statement at a time and see the contents of variables.

\term{breakpoint}
A line of code where the debugger will pause a running program.

\term{call stack}
The history of method calls and where to resume execution after each method returns.

\end{description}


\section{Exercises}


\begin{exercise}

The point of this exercise is to practice reading code and to make sure that you understand the flow of execution through a program with multiple methods.

\begin{enumerate}

\item What is the output of the following program?
Be precise about where there are spaces and where there are newlines.
(Hint: Start by describing in words what \java{ping} and \java{baffle} do when they are invoked.)

\item Draw a stack diagram that shows the state of the program the first time \java{ping} is invoked.

%\item What happens if you add a method call to \java{baffle();} at the end of the \java{ping} method? (We will see why in the next chapter.)

\end{enumerate}

\begin{code}
    public static void zoop() {
        baffle();
        System.out.print("You wugga ");
        baffle();
    }
    public static void main(String[] args) {
        System.out.print("No, I ");
        zoop();
        System.out.print("I ");
        baffle();
    }
    public static void baffle() {
        System.out.print("wug");
        ping();
    }
    public static void ping() {
        System.out.println(".");
    }
\end{code}

\end{exercise}


\begin{exercise}
This exercise builds on the previous one by using parameters.
Make sure you understand both the order of execution and the flow of data.

\begin{enumerate}

\item Draw a stack diagram that shows the state of the program the {\it second} time \java{ping} is invoked.

\item What is the complete output of the program?

\end{enumerate}

\begin{code}
    public static void zoop(String fred, int bob) {
        System.out.println(fred);
        if (bob == 5) {
            ping("not ");
        } else {
            System.out.println("!");
        }
    }

    public static void main(String[] args) {
        int bizz = 5;
        int buzz = 2;
        zoop("just for", bizz);
        clink(2 * buzz);
    }

    public static void clink(int fork) {
        System.out.print("It's ");
        zoop("breakfast ", fork) ;
    }

    public static void ping(String strangStrung) {
        System.out.println("any " + strangStrung + "more ");
    }
\end{code}
\end{exercise}


\begin{exercise}

What is the difference between a variable and a method?
In terms of their syntax, how does the Java compiler tell the difference between the two?

%A variable is a {\em location of data}, whereas a method is a {\em location of code}.
%In Java, methods always have parentheses, even if they have no arguments like \java{System.out.println()}.

\end{exercise}


\begin{exercise}

Draw a stack diagram that shows the state of the program in Section~\ref{time} when \java{main} invokes \java{printTime} with the arguments \java{11} and \java{59}.

\end{exercise}


\begin{exercise}

The point of this exercise is to make sure you understand how to write and invoke methods that take parameters.

\begin{enumerate}
\item Write the first line of a method named \java{zool} that takes three parameters: an \java{int} and two \java{Strings}.

\item Write a line of code that calls \java{zool}, passing as arguments the value \java{11}, the name of your first pet, and the name of the street you grew up on.
\end{enumerate}

\end{exercise}


\begin{exercise}

The purpose of this exercise is to take code from a previous exercise and encapsulate it in a method that takes parameters.
You should start with a working solution to Exercise~\ref{ex:date}.

\begin{enumerate}

\item Write a method called \java{printAmerican} that takes the day, date, month and year as parameters and that prints them in American format.

\item Test your method by invoking it from \java{main} and passing appropriate arguments.
The output should look something like this (except that the date might be different):

\begin{stdout}
Saturday, July 16, 2011
\end{stdout}

\item Once you have debugged \java{printAmerican}, write another method called \java{printEuropean} that prints the date in European format.

\end{enumerate}

\end{exercise}


\chapter{Decisions and logic}

\index{boolean}
\index{type!boolean}

% TODO(ABD): I'd like an intro that presents the contents of the chapter in
% terms of new capabilities: what can we do at the end of this chapter
% that we can't do now?

The programs we've seen so far do pretty much the same thing every time, regardless of the input.
For more complex computations, programs usually react to the inputs, check for certain conditions, and generate appropriate results.
This chapter presents the features you need for programs to make complex decisions: a new data type called \java{boolean}, additional operators for expressing logic, and \java{if} statements.

%\java{boolean} is named after George Boole, who developed a formal system that represents logic using the values {\it true} and {\it false} and operations like {\it and}, {\it or}, and {\it not}.
%In Java, the values \java{true} and \java{false} belong to the data type \java{boolean}.

%\java{true} and \java{false} are special values in Java, and together they make up a type called {\bf boolean}.
%You might recall that when I defined a type, I said it was a set of values.
%In the case of \java{int}s, \java{double}s and \java{String}s, those sets are pretty big.
%For \java{boolean}s, there are only two values.
%The values \java{true} and \java{false} are keywords in Java, so they may appear in a different color, depending on your development environment.


\section{Assignment revisited}

\index{assignment}
\index{statement!assignment}

You can make more than one assignment to the same variable; the effect is to replace the old value with the new.
One way to remember this behavior is to think of variables as {\em containers}.
When you assign a value to a variable, you change the contents of the container.

\begin{center}
\includegraphics{figs/assign2.pdf}
\end{center}

%TODO(CSM): multiple assignment means "int x=0, y=0;" using the comma operator
%\index{multiple assignment}
%
%\begin{code}
%    int liz = 5;
%    System.out.print(liz);
%    liz = 7;
%    System.out.println(liz);
%\end{code}
%
%The output of this program is {\tt 57}, because the first time we print \java{liz} her value is 5, and the second time her value is 7.

When there are multiple assignments to a variable, it is especially important to distinguish between an assignment statement and a statement of equality.
Because Java uses the \java{=} symbol for assignment, it is tempting to interpret a statement like \java{a = b} as a statement of equality.
It is not!

First of all, equality is commutative, and assignment is not.
For example, in mathematics if $a = 7$ then $7 = a$.
In Java \java{a = 7;} is a legal assignment statement, but \java{7 = a;} is not.
Assignment {\em always} executes from right to left.

Furthermore, in mathematics, a statement of equality is true for all time.
If $a = b$ now, then $a$ will always equal $b$.
In Java, an assignment statement can make two variables equal, but they don't have to stay that way.

\begin{code}
    int a = 5;
    int b = a;     // a and b are now equal
    a = 3;         // a and b are no longer equal
\end{code}

The third line changes the value of \java{a}, but it does not change the value of \java{b}, so they are no longer equal.
In some programming languages a different symbol is used for assignment, such as {\tt <-} or {\tt :=}, to avoid this confusion.

%Although multiple assignment is frequently useful, you should use it with caution.
%If the values of variables change often, it can make the code difficult to read and debug.


\section{Relational operators}

\index{operator!relational}
\index{relational operator}
\index{operator!comparison}
\index{comparison operator}

{\bf Relational operators} are used to check conditions like whether two values are equal, or whether one is greater than the other.
The following expressions show how they are used:

\begin{code}
    x == y          // x is equal to y
    x != y          // x is not equal to y
    x > y           // x is greater than y
    x < y           // x is less than y
    x >= y          // x is greater than or equal to y
    x <= y          // x is less than or equal to y
\end{code}

The result of a relational operator is one of two special values, \java{true} or \java{false}.
These values belong to the type \java{boolean}; in fact, they are the only values for the type \java{boolean}.

You are probably familiar with these operations, but notice that the Java syntax is different from mathematical symbols like $=$, $\neq$, and $\le$.
A common error is to use a single \java{=} instead of a double \java{==}.
Remember that \java{=} is the assignment operator, and \java{==} is a comparison operator.
Also, there is no such thing as \java{=<} or \java{=>} operators.

The two sides of a relational operator have to be compatible.
For example, the expression \java{5 < "6"} is invalid because \java{5} is an \java{int} and \java{"6"} is a \java{String}.
When comparing values of different numeric types, Java applies the same conversion rules we saw previously with the assignment operator.
For example, when evaluating the expression \java{5 < 6.0}, Java automatically converts the \java{5} to \java{5.0}.

Most relational operators don't work with strings.
Confusingly, \java{==} and \java{!=} do work with strings---they just don't do what you expect.
We'll explain what they do later; in the meantime, don't use them with strings.
Instead, you should use the \java{String} methods \java{equals} and \java{compareTo}:

\begin{code}
    String fruit1 = "Apple";
    String fruit2 = "Orange";
    System.out.println(fruit1.equals(fruit2));
    System.out.println(fruit1.compareTo(fruit2));
\end{code}


\section{Conditional operators}

\index{conditional operator}
\index{operator!conditional}
\index{logical operator}
\index{operator!logical}

Java has three {\bf conditional operators}: \java{&&}, \java{||}, and \java{!}, which respectively stand for {\it and}, {\it or}, and {\it not}.
The semantics of these operators are similar to their meanings in English.

For example, \java{x > 0 && x < 10} is true when \java{x} is both greater than zero and less than 10.
The expression \java{evenFlag || n \% 3 == 0} is true if {\it either} condition is true, that is, if \java{evenFlag} is true or the number \java{n} is divisible by 3.
Finally, the \java{!} operator inverts a boolean expression.
So \java{!evenFlag} is \java{true} if \java{evenFlag} is \java{false}.

\index{short circuit}

Conditional operators evaluate the second expression only when necessary.
For example, \java{true || anything} is always true, so Java does not need to evaluate the expression \java{anything}.
Likewise, \java{false && anything} is always false.
Ignoring the second operand, when possible, is called {\bf short circuit} evaluation, by analogy with an electrical circuit.
Short circuit evaluation can save time, especially if \java{anything} is a method call.
It can also avoid unnecessary errors, if \java{anything} might fail based on the first operand.

\index{De Morgan's laws}

When solving logic problems using conditional operators, you will often need to negate \java{&&} and \java{||} operations.
{\bf De Morgan's laws} show how to simplify such expressions:

\begin{itemize}
\item \java{!(A && B)} ~is the same as~ \java{!A || !B}
\item \java{!(A || B)} ~is the same as~ \java{!A && !B}
\end{itemize}

In other words, negating a conditional expression is the same as negating each term and changing the operator.
Note that since the \java{!} operator has higher precedence than \java{&&} and \java{||}, you don't need to put parentheses around the individual terms \java{!A} and \java{!B}.

De Morgan's laws also apply to the relational operators.
In this case, negating each term means using the ``opposite'' relational operator.

\begin{itemize}
\item \java{!(x < 5 && y == 3)} ~is the same as~ \java{x >= 5 || y != 3}
\item \java{!(x >= 1 || y != 7)} ~is the same as~ \java{x < 1 && y == 7}
\end{itemize}

It may help to read these examples out loud in English.
For instance, ``If I don't want x to be less than 5, and I don't want y to be 3, then I need x to be greater than or equal to 5, or I need y to be anything but 3.''


\section{DrJava interactions}

A good way to gain experience with relational and conditional operators is to use the Interactions Pane of DrJava.
As shown in Figure~\ref{fig:drjava}, you can declare several variables and {\it interactively} test your logic skills.
Don't forget that you can try out many of the examples in this book this same way.

% try to determine their result before running the code.
%
% ABD: I worry about instructions like this, because students seldom follow them.
% Can we create some exercises (and move this section to the end of the chapter)?

\begin{figure}[!h]
\begin{center}
\includegraphics[width=\textwidth]{figs/drjava-logic.png}
\caption{Screenshot of the Interactions Pane in DrJava.}
\label{fig:drjava}
\end{center}
\end{figure}

There is one subtle detail to note when using the Interactions feature.
If you don't end an expression (or statement) with a semicolon, DrJava automatically prints its value.
Notice in Figure~\ref{fig:drjava} how the variable declarations end with semicolons, but the logic expressions in the following lines do not.

What's nice about this feature is that you don't have to create a new class, declare a main method, write arbitrary expressions inside \java{System.out.println} statements, save the source file, and get all of your code to compile in advance.
In addition, you can press the up/down arrows on the keyboard to repeat previous commands and experiment with incremental differences.

\index{order of operations}
\index{precedence}

Notice how none of the expressions in this example require parentheses.
Java evaluates arithmetic operators first, then the relational operators, then conditional operators, and finally the assignment operator.
Do a web search for ``java operator precedence'' to see the complete list of rules.
If two operators have the same precedence, Java evaluates them from left to right.


\section{The if-else statement}

\index{decision statement}
\index{statement!if}

To write useful programs, we almost always need to check conditions and react accordingly.
{\bf Decision statements} give us this ability.
The simplest decision statement in Java is the \java{if} statement:

\begin{code}
    if (x > 0) {
        System.out.println("x is positive");
    }
\end{code}

The expression in parentheses is called the condition.
If it is true, the statements in braces get executed.
If the condition is false, execution skips over that block of code.
The condition in parentheses can be {\it any} boolean expression.

\index{branch}
\index{statement!else}
\index{decision!alternative}

A second form of decision statement is alternative execution, in which there are two possibilities indicated by \java{if} and \java{else}.
The possibilities are called {\bf branches}, and the condition determines which one gets executed:

\begin{code}
    if (x % 2 == 0) {
        System.out.println("x is even");
    } else {
        System.out.println("x is odd");
    }
\end{code}

If the remainder when \java{x} is divided by 2 is zero, we know that \java{x} is even, and this code prints a message to that effect.
If the condition is false, the second print statement is executed instead.
Since the condition must be true or false, exactly one of the alternatives will be executed.

%\label{alternative}
%\index{parity}
%
%To follow up the previous chapter, if you need to check the {\bf parity} (evenness or oddness) of numbers often, you might want to ``wrap'' this code up in a method:
%
%\begin{code}
%    public static void printParity(int x) {
%        if (x % 2 == 0) {
%            System.out.println("x is even");
%        } else {
%            System.out.println("x is odd");
%        }
%    }
%\end{code}
%
%Now you have a method named \java{printParity} that will print an appropriate message for any integer you care to provide.
%In \java{main} you would invoke this method as follows:
%
%\begin{code}
%    printParity(17);
%\end{code}
%
%Always remember that when you invoke a method, you do not have to declare the types of the arguments you provide.
%Java can figure out what type they are.
%You should resist the temptation to write things like:
%
%\begin{code}
%    int number = 17;
%    printParity(int number);        // WRONG!!!
%\end{code}

\index{decision!chained}

Sometimes you want to check related conditions and choose one of several actions.
One way to do this is by {\bf chaining} a series of \java{if} and \java{else} statements:

\begin{code}
    if (x > 0) {
        System.out.println("x is positive");
    } else if (x < 0) {
        System.out.println("x is negative");
    } else {
        System.out.println("x is zero");
    }
\end{code}

These chains can be as long as you want, although they can be difficult to read if they get out of hand.
One way to make them easier to read is to use standard indentation, as demonstrated in these examples.
If you keep all the statements and braces lined up, you are less likely to make syntax errors.

\index{decision!nested}
\index{nested structure}

In addition to chaining, you can also make complex decisions by {\bf nesting} one decision inside another.
We could have written the previous example as:

\begin{code}
    if (x == 0) {
        System.out.println("x is zero");
    } else {
        if (x > 0) {
            System.out.println("x is positive");
        } else {
            System.out.println("x is negative");
        }
    }
\end{code}

The outer conditional has two branches:
the first branch contains a \java{print} statement; the second branch contains another decision statement, which has two branches of its own.
Each of them is a \java{print} statement, but they could have been decision statements as well.

These kinds of nested structures are common, but they get difficult to read very quickly.
Good indentation is essential to make the structure (or intended structure) apparent to the reader.


\section{Flag variables}

\index{expression!boolean}

Recall from Section~\ref{sec:arithops} that an expression is a combination of variables and operators that evaluates to a single value.
Expressions can be as simple as the literal \java{0} or more complex like \java{Math.cos(angle + Math.PI / 2)}.
Boolean expressions and variables work just like other types of expressions and variables:

\begin{code}
    boolean flag;
    flag = true;
    boolean testResult = false;
\end{code}

\index{initialization}
\index{statement!initialization}

The first line is a variable declaration, the second is an assignment, and the third is an initialization.
Since relational operators evaluate to a \java{boolean} value, you can store the result of a comparison in a variable:

\begin{code}
    boolean evenFlag = (n % 2 == 0);    // true if n is even
    boolean positiveFlag = (x > 0);     // true if x is positive
\end{code}

The parentheses are unnecessary, but they make the code easier to read.
A variable defined in this way is called a {\bf flag}, because it signals the presence or absence of some condition.

You can use flag variables as part of a conditional statement later:

\begin{code}
    if (evenFlag) {
        System.out.println("n was even when I checked it");
    }
\end{code}

Notice that you don't need to say \java{if (evenFlag == true)}.
Since \java{evenFlag} is a \java{boolean}, it's already a condition.
Likewise, to check if a flag is \java{false}:

\begin{code}
    if (!evenFlag) {
        System.out.println("n was odd when I checked it");
    }
\end{code}


\section{The return statement}

\index{return}
\index{statement!return}

The \java{return} statement allows you to terminate a method before you reach the end of it.
One reason to use \java{return} is if you detect an error condition:

\begin{code}
    public static void printLogarithm(double x) {
        if (x <= 0.0) {
            System.err.println("Error: x must be positive.");
            return;
        }
        double result = Math.log(x);
        System.out.println("The log of x is " + result);
    }
\end{code}

This example defines a method named \java{printLogarithm} that takes a \java{double} value (named \java{x}) as a parameter.
It checks whether \java{x} is less than or equal to zero, in which case it prints an error message and then uses \java{return} to exit the method.
The flow of execution immediately returns to the caller, and the remaining lines of the method are not executed.

\index{System.err}

Notice the floating-point value \java{0.0} on the right side of the condition.
Since \java{x} is a floating-point variable, you should compare it to a floating-point literal.
This example also uses \java{System.err}, which is the {\it standard error} output stream.
Your development environment might distinguish normal output and error output by using a different color.


\section{Validating input}

Here is a simple program that makes use of the \java{printLogarithm} method defined in the previous section:

\begin{code}
    public static void main(String args[]) {
        Scanner in = new Scanner(System.in);
        System.out.print("Enter a number: ");
        double x = in.nextDouble();
        printLogarithm(x);
    }
\end{code}

Up to this point, we have assumed that users always do what they're told.
But what happens if they make an innocent mistake?
Or even worse, what happens if they deliberately try to crash your program?

\begin{stdout}
Enter a number: Hello
Exception in thread "main" java.util.InputMismatchException
    at java.util.Scanner.throwFor(Scanner.java:909)
    at java.util.Scanner.next(Scanner.java:1530)
    at java.util.Scanner.nextDouble(Scanner.java:2456)
    at Example.main(Example.java:17)
\end{stdout}

In this example, the program calls the \java{nextDouble} method, so the \java{Scanner} attempts to parse a \java{double}.
However the user input is \java{"Hello"}, which causes an \java{InputMismatchException}.
We can prevent this error from happening by checking the input before parsing it:

\begin{code}
    public static void main(String args[]) {
        Scanner in = new Scanner(System.in);
        System.out.print("Enter a number: ");
        if (!in.hasNextDouble()) {
            String word = in.next();
            System.err.println(word + " is not a number");
            return;
        }
        double x = in.nextDouble();
        printLogarithm(x);
    }
\end{code}

The \java{Scanner} class provides \java{hasNext} methods for each of the \java{next} methods.
They return \java{true} or \java{false}, depending on the format of the next token of input.
In this example, we call \java{hasNextDouble} to check if the user entered a \java{double}.
If not, then we display an error message (using \java{System.err}) and abort the program.

If you \java{return} from \java{main}, the program ends immediately.
Notice also the use of the \java{!} operator, instead of the test \java{hasNextDouble() == false}.
Since the \java{hasNextDouble} method returns a boolean result, it is already a condition.


\section{Recursive methods}
\label{recursion}

\index{recursion}

Now that we have methods and if statements, we can explore one of the most magical and interesting things a program can do.
It is common for one method to invoke another, but what happens if a method invokes {\em itself}?
This process is called {\bf recursion}.
Consider the following example:

\begin{code}
    public static void countdown(int n) {
        if (n == 0) {
            System.out.println("Blastoff!");
        } else {
            System.out.println(n);
            countdown(n - 1);
        }
    }
\end{code}

The name of the method is \java{countdown}; it takes a single integer as a parameter.
If the parameter is zero, it prints the word ``Blastoff.''
Otherwise, it prints the number and then invokes itself, passing \java{n - 1} as the argument.

What happens if we invoke \java{countdown(3)} from \java{main}?

\vspace{-1ex}
\begin{quote}
The execution of \java{countdown} begins with \java{n == 3}, and since \java{n} is not zero, it prints the value 3, and then invokes itself...
\begin{quote}
The execution of \java{countdown} begins with \java{n == 2}, and since \java{n} is not zero, it prints the value 2, and then invokes itself...
\begin{quote}
The execution of \java{countdown} begins with \java{n == 1}, and since \java{n} is not zero, it prints the value 1, and then invokes itself...
\begin{quote}
The execution of \java{countdown} begins with \java{n == 0}, and since \java{n} is zero, it prints the word ``Blastoff!'' and then returns.
\end{quote}
The \java{countdown} that got \java{n == 1} returns.
\end{quote}
The \java{countdown} that got \java{n == 2} returns.
\end{quote}
The \java{countdown} that got \java{n == 3} returns.
\end{quote}
\vspace{-1ex}

And then you're back in \java{main}.
So the total output looks like:

\begin{stdout}
3
2
1
Blastoff!
\end{stdout}

As a second example, we'll rewrite the methods \java{newLine} and \java{threeLine} from Section~\ref{adding_methods}.

\begin{code}
    public static void newLine() {
        System.out.println();
    }

    public static void threeLine() {
        newLine();
        newLine();
        newLine();
    }
\end{code}

\index{newline}

Although these methods work, they would not be much help if we wanted to print 2 newlines, or 106.
A better alternative would be:

\begin{code}
    public static void nLines(int n) {
        if (n > 0) {
            System.out.println();
            nLines(n - 1);
        }
    }
\end{code}

This method is similar to \java{countdown}.
As long as $n$ is greater than zero, it prints a newline and then invokes itself to print $(n-1)$ additional newlines.
The total number of newlines is $1 + (n - 1)$, which is just what we wanted: $n$.


\section{Recursive stack diagrams}

\index{stack diagram}
\index{diagram!stack}

In the previous chapter, we used a stack diagram to represent the state of a program during a method invocation.
The same kind of diagram can make it easier to interpret a recursive method.

Remember that every time a method gets called, Java creates a new frame in memory that contains the current method's parameters and variables.
The following figure is a stack diagram for countdown, called with \java{n == 3}:

\begin{figure}[!h]
\begin{center}
\includegraphics{figs/stack2.pdf}
\caption{Stack diagram for the \java{countdown} program.}
\end{center}
\end{figure}

Note that the ``stack'' of method calls is upside down.
It's easier to draw stack diagrams from top to bottom, because you don't always know how much vertical space you will need in advance.

The stack frame for \java{main} is empty because \java{main} does not have any local variables.
It has one parameter, \java{args}, but since we're not using it, we left it out of the diagram.

There are four frames for \java{countdown}, each with a different value for the parameter \java{n}.
The last frame, with \java{n == 0}, is called the {\bf base case}.
It does not make a recursive call, so there are no more frames below it.

You should always check for a base case in your code, or else the recursion may keep going until the program runs out of memory.
For example, here is a recursive method without a base case:

\begin{code}
    public static void forever(String s) {
        System.out.println(s);
        forever(s);
    }
\end{code}

\index{call stack}
\index{stack overflow}

This \java{forever} method prints the string over 10,000 times, but then the program suddenly terminates with a \java{StackOverflowError}.
In other words, there's no more room on the stack for additional method calls.

Java sets aside a reasonable amount of memory for the call stack, so that it can remember where to return at the end of each method.
But if that memory fills up, it's usually because you have infinite recursion.

%Recall from Section~\ref{debugger} that Java automatically tracks the call and return of each method in memory, much like the stack diagrams we draw on paper.
%Each method call takes a little memory, but that memory can be reused when the method returns.


\section{Binary Numbers}

The \java{countdown} example has three parts: (1) it checks the base case, (2) prints something, and (3) makes a recursive call.
What do you think happens if you reverse steps 2 and 3, making the recursive call {\it before} printing?

\begin{code}
    public static void countup(int n) {
        if (n == 0) {
            System.out.println("Blastoff!");
        } else {
            countup(n - 1);
            System.out.println(n);
        }
    }
\end{code}

The stack diagram is the same as before, and the method is still called $n$ times.
But now the \java{System.out.println} happens just before each recursive call returns.
As a result, it counts up instead of down:

\begin{stdout}
Blastoff!
1
2
3
\end{stdout}

This behavior comes in handy when it is easier to compute results in reverse order.
For example, to convert a decimal integer into its {\bf binary} representation, you repeatedly divide the number by two:

\begin{stdout}
23 / 2 is 11 remainder 1
11 / 2 is  5 remainder 1
 5 / 2 is  2 remainder 1
 2 / 2 is  1 remainder 0
 1 / 2 is  0 remainder 1
\end{stdout}

So 23 in binary is 10111, which is the remainders in the above example from bottom to top.
Here is a recursive method that prints the binary representation of any positive integer:

\begin{code}
    public static void showBinary(int value) {
        if (value > 0) {
            showBinary(value / 2);
            System.out.print(value % 2);
        }
    }
\end{code}

If \java{value} is zero, \java{showBinary} does nothing (that's the base case).
If the argument is positive, the method divides it by two and calls \java{showBinary} recursively.
When the recursive call returns, the method prints one digit of the result and returns (again).
The leftmost digit is at the bottom of the stack, so it gets printed first.  The rightmost digit, at the top of the stack, gets printed last.

\begin{code}
    showBinary(23);
    // output is 10111
\end{code}

Learning to think recursively is an important aspect of learning to think like a computer scientist.
Many algorithms can be written concisely with recursive methods that perform computations on the way down, on the way up, or both.


\section{Vocabulary}

\begin{description}

\term{boolean}
A data type with only two values, \java{true} and \java{false}.

\index{operator!relational}
\term{relational operator}
An operator that compares two values and produces a boolean indicating the relationship between them.

\index{operator!conditional}
\term{conditional operator}
An operator that combines boolean values and produces boolean values.

\term{short circuit}
A way of evaluating conditional operators that only evaluates the second operand if necessary.

\term{De Morgan's laws}
Mathematical rules that show how to negate a conditional expression.

\term{decision statement}
A statement that uses a condition to determine which statements to execute.

\term{branch}
One of the alternative sets of statements inside a decision statement.

\term{chaining}
A way of joining several conditional statements in sequence.

\term{nesting}
Putting a conditional statement inside one or both branches of another conditional statement.

\term{flag}
A variable (usually \java{boolean}) that represents a condition or status.

\term{recursion}
The process of invoking the same method that you are currently executing.

\term{base case}
A condition that causes a recursive method {\it not} to make another recursive call.

\term{binary}
A system that uses only zeros and ones to represent numbers.
Also known as ``base 2.''

\end{description}


\section{Exercises}


\begin{exercise}

Conditional operators can simplify nested decision structures.
For example, how can you rewrite this code using a single \java{if} statement?

\begin{code}
    if (x > 0) {
        if (x < 10) {
            System.out.println("x is a positive single digit.");
        }
    }
\end{code}

\end{exercise}


\begin{exercise}

Fermat's Last Theorem says that there are no integers $a$, $b$, and $c$ such that
\[ a^n + b^n = c^n \]
except in the case when $n \leq 2$ (e.g., the Pythagorean Theorem).

Write a method named \java{checkFermat} that takes four integers as parameters---\java{a}, \java{b}, \java{c} and \java{n}---and that checks to see if Fermat's theorem holds.
If $n$ is greater than 2 and it turns out to be true that $a^n + b^n = c^n$, the program should print ``Holy smokes, Fermat was wrong!''
Otherwise the program should print ``No, that doesn't work.''

HINT: You may want to use \java{Math.pow} in your method.

\end{exercise}


\begin{exercise}

The purpose of this exercise is to take a problem and break it into smaller problems, and to solve the smaller problems by writing simple methods. Consider the first verse of the song ``99 Bottles of Pop'':

\begin{quote}
99 bottles of pop on the wall,\\
99 bottles of pop,\\
If one of those bottles should happen to fall,\\
98 bottles of pop on the wall.
\end{quote}

Subsequent verses are identical except that the number of bottles gets smaller by one in each verse, until the last verse:

\begin{quote}
1 bottle of pop on the wall,\\
1 bottle of pop,\\
If that last bottle should happen to fall,\\
No more bottles of pop on the wall.
\end{quote}

%And then the song (finally) ends.

Write a program that prints the entire lyrics of ``99 Bottles of Pop.''
Your program should include a {\it recursive} method that does the hard part, but you might want to write additional methods to separate the major functions of the program.
As you develop your code, test it with a small number of verses like ``3 Bottles of Pop.''

\end{exercise}


\begin{exercise}

Draw a stack diagram that shows the state of the program in Section~\ref{recursion} after \java{main} invokes \java{nLines} with the parameter \java{n == 4}, just before the last invocation of \java{nLines} returns.

\end{exercise}


\begin{exercise}

This exercise reviews the flow of execution through a program with multiple methods.
Read the following code and answer the questions.

\begin{code}
public class Buzz {

    public static void baffle(String blimp) {
        System.out.println(blimp);
        zippo("ping", -5);
    }

    public static void zippo(String quince, int flag) {
        if (flag < 0) {
            System.out.println(quince + " zoop");
        } else {
            System.out.println("ik");
            baffle(quince);
            System.out.println("boo-wa-ha-ha");
        }
    }

    public static void main(String[] args) {
        zippo("rattle", 13);
    }

}
\end{code}

\begin{enumerate}

\item Write the number {\tt 1} next to the first {\em statement} of this program that will be executed.
Be careful to distinguish things that are statements from things that are not.

\item Write the number {\tt 2} next to the second statement, and so on until the end of the program.
If a statement is executed more than once, it might end up with more than one number next to it.

\item What is the value of the parameter \java{blimp} when \java{baffle} gets invoked?

\item What is the output of this program?

\end{enumerate}

\end{exercise}


\chapter{Value methods}

\index{method!value}
\index{method!void}
\index{value method}
\index{void method}

Some of the methods we have used, like the \java{Math} methods, return values.
Others, like \java{println} and \java{newLine}, perform an action but don't return a value.
In Chapter~\ref{voidmeth}, we called methods that don't return a value {\bf void methods}.
The focus of this chapter is {\bf value methods}, or methods that compute and return a result.


\section{Return values}

\index{void}

The methods we have written so far, like \java{countdown} and \java{countup}, don't return values, which is why the first line has the keyword \java{void}.

\begin{code}
    public static void countup(int n) {
        if (n == 0) {
            System.out.println("Blastoff!");
        } else {
            countup(n - 1);
            System.out.println(n);
        }
    }
\end{code}

When you invoke a \java{void} method, it is typically on a line all by itself:

\begin{code}
    countup(3);
    System.out.println("Have a nice day.");
\end{code}

When you invoke a value method, it returns a value which we usually assign to a variable or use as part of an expression:

\begin{code}
    double error = Math.abs(expected - actual);
    double height = radius * Math.sin(angle);
\end{code}

\index{value method}
\index{method!value}

In this chapter, you will learn to write methods that return values.
Here's an example:  \java{area} takes a \java{double} as a parameter and returns the area of a circle with that radius:

\begin{code}
    public static double area(double radius) {
        double area;
        area = Math.PI * radius * radius;
        return area;
    }
\end{code}

The first thing you should notice is that the beginning of the method definition is different.
Instead of \java{public static void}, which indicates a \java{void} method, we see \java{public static double}, which means that the return value from this method is a \java{double}.
%I still haven't explained what \java{public static} means, but be patient.

\index{return}
\index{statement!return}

The last line is a new form of the \java{return} statement that includes a return value.
This statement means, ``return immediately from this method and use the following expression as the return value.''
The expression you provide can be arbitrarily complex, so we could have written this method more concisely:

\begin{code}
    public static double area(double radius) {
        return Math.PI * radius * radius;
    }
\end{code}

\index{temporary variable}
\index{variable!temporary}

On the other hand, {\bf temporary} variables like \java{area} often make debugging easier, especially when you are stepping through code using a debugger.

The type of the expression in the \java{return} statement must match the return type of the method.
When you declare that the return type is \java{double}, you are making a promise that this method will eventually produce a \java{double} value.
If you try to \java{return} with no expression, or an expression with the wrong type, the compiler will generate an error.

Sometimes it is useful to have multiple return statements, for example, one in each branch of a decision:

\begin{code}
    public static double absoluteValue(double x) {
        if (x < 0) {
            return -x;
        } else {
            return x;
        }
    }
\end{code}

Since these \java{return} statements are in an alternative structure, only one will be executed.
Although it is legal to have more than one \java{return} statement in a method, you should keep in mind that as soon as one is executed, the method terminates without executing any subsequent statements.

\index{dead code}

Code that appears after a \java{return} statement, or any place else where it can never be executed, is called {\bf dead code}.
The compiler will give you an ``unreachable statement'' error if part of your code is dead.

\begin{code}
    public static double absoluteValue(double x) {
        if (x < 0) {
            return -x;
        } else {
            return x;
        }
        System.out.println("This line is dead.");
    }
\end{code}

If you put \java{return} statements inside of a decision, you have to guarantee that {\em every possible path} through the program reaches a \java{return} statement.

\begin{code}
    public static double absoluteValue(double x) {
        if (x < 0) {
            return -x;
        } else if (x > 0) {
            return x;
        }
        // syntax error
    }
\end{code}

This program is not legal because when \java{x} is 0, neither condition is true.
As a result, the method ends without hitting a return statement.
The typical compiler error message is ``missing return statement'', which is confusing since there are already two of them.


\section{Writing methods}
\label{distance}

\index{incremental development}

At this point you should be able to look at Java methods and tell what they do.
But it may not be clear yet how to go about writing them.
In this section, we are going to model a technique called {\bf incremental development}.
As an example, imagine you want to find the distance between two points, given by the coordinates $(x_1, y_1)$ and $(x_2, y_2)$.
By the usual definition:

\[ distance = \sqrt{(x_2 - x_1)^2 +(y_2 - y_1)^2} \]

The first step is to consider what a \java{distance} method should look like in Java.
In other words, what are the inputs (parameters) and what is the output (return value)?
In this case, the two points are the parameters, and it is natural to represent them using four \java{double} values.
%, although we will see later that there is a \java{Point} object in Java that we could use.
The return value is the distance, which should also have type \java{double}.

\index{stub}

Already we can write an outline for the method, which is sometimes called a {\bf stub}.
This code includes the method signature and a \java{return} statement:

\begin{code}
    public static double distance
            (double x1, double y1, double x2, double y2) {
        return 0.0;
    }
\end{code}

The return statement is a placeholder that is necessary for the program to compile.
At this stage the program doesn't do anything useful, but it is worthwhile to compile it so we can identify any syntax errors before we add more code.

It's always a good idea to think about testing {\it before} you develop new methods; it can help you figure out how to implement them.
To test this new method, we can invoke it (in \java{main}) using sample values:

\begin{code}
    double dist = distance(1.0, 2.0, 4.0, 6.0);
\end{code}

These values make the horizontal distance 3.0 and the vertical distance 4.0.
That way, the result should be 5.0, the hypotenuse of a 3-4-5 triangle.
When you are testing a method, it is useful to know the right answer.

Once we have checked the syntax of the method definition, we can start adding lines of code one at a time.
After each incremental change, we recompile and run the program.
If there is an error at any point, we have a good idea where to look: the last line we added.

The next step is to find the differences $x_2 - x_1$ and $y_2 - y_1$.
We store those values in temporary variables named \java{dx} and \java{dy}.

\begin{code}
    public static double distance
            (double x1, double y1, double x2, double y2) {
        double dx = x2 - x1;
        double dy = y2 - y1;
        System.out.println("dx is " + dx);
        System.out.println("dy is " + dy);
        return 0.0;
    }
\end{code}

\index{scaffolding}

The print statements allows us to check the intermediate values before proceeding.
They should be 3.0 and 4.0.
We will remove the print statements when the method is finished.
Code like that is called {\bf scaffolding}, because it is helpful for building the program, but it is not part of the final product.

The next step is to square \java{dx} and \java{dy}.
We could use the \java{Math.pow} method, but it is simpler to multiply each term by itself.

\begin{code}
    public static double distance
            (double x1, double y1, double x2, double y2) {
        double dx = x2 - x1;
        double dy = y2 - y1;
        double dsquared = dx * dx + dy * dy;
        System.out.println("dsquared is " + dsquared);
        return 0.0;
    }
\end{code}

Again, you should compile and run the program at this stage and check the intermediate value, which should be 25.0.
Finally, we can use \java{Math.sqrt} to compute and return the result.

\begin{code}
    public static double distance
            (double x1, double y1, double x2, double y2) {
        double dx = x2 - x1;
        double dy = y2 - y1;
        double dsquared = dx*dx + dy*dy;
        double result = Math.sqrt(dsquared);
        return result;
    }
\end{code}

%In \java{main}, we can print and check the value of the result.

As you gain more experience programming, you might write and debug more than one line at a time.
Nevertheless, incremental development can save you a lot of time.
The key aspects of the process are:

\begin{itemize}

\item Start with a working program and make small, incremental changes.
At any point, if there is an error, you will know where to look.

\item Use temporary variables to hold intermediate values so you can check them, either with print statements or by using a debugger.

\item Once the program is working, you can remove scaffolding and consolidate multiple statements into compound expressions (but only if it does not make the program more difficult to read).

\end{itemize}


\section{Method composition}

\index{composition}

Once you define a new method, you can use it as part of an expression, or build new methods using existing methods.
For example, suppose someone gave you two points, the center of the circle and a point on the perimeter, and asked for the area of the circle.
Let's say the center point is stored in the variables \java{xc} and \java{yc}, and the perimeter point is in \java{xp} and \java{yp}.

The first step is to find the radius of the circle, which is the distance between the two points.
Fortunately, we have a method that does just that (\java{distance}).

% ABD: I am inclined to uncomment these code snippets before showing
% the complete function

\begin{code}
    double radius = distance(xc, yc, xp, yp);
\end{code}

The second step is to find the area of a circle with that radius.
We have a method for that computation too (\java{area}).

\begin{code}
    double area = area(radius);
    return area;
\end{code}

Putting everything together in a new method, we get:

\begin{code}
    public static double circleArea
            (double xc, double yc, double xp, double yp) {
        double radius = distance(xc, yc, xp, yp);
        double area = area(radius);
        return area;
    }
\end{code}

The temporary variables \java{radius} and \java{area} are useful for development and debugging, but once the program is working we can make it more concise by {\it composing} the method calls:

\begin{code}
    public static double circleArea
            (double xc, double yc, double xp, double yp) {
        return area(distance(xc, yc, xp, yp));
    }
\end{code}

Computer scientists deal with the complexity of large programs by breaking down computations into individual methods (which in turn may call other methods).
Data is passed around the program via method parameters and return statements.
By using incremental development, scaffolding, and testing, you can be confident that your code is correct.


\section{Overloading}
\label{overloading}

You might have noticed that \java{circleArea} and \java{area} perform similar functions.
They both find the area of a circle, but they take different parameters.
For \java{area}, we have to provide the radius; for \java{circleArea} we provide two points.

\index{overloading}

If two methods do the same thing, it is natural to give them the same name.
Having more than one method with the same name is called {\bf overloading}, and it is legal in Java as long as each version takes different parameters.
So we could rename \java{circleArea} to \java{area}:

\begin{code}
    public static double area
            (double x1, double y1, double x2, double y2) {
        return area(distance(xc, yc, xp, yp));
    }
\end{code}

Note that this new \java{area} method is {\em not} recursive.
When you invoke an overloaded method, Java knows which version you want by looking at the arguments that you provide.
If you write:

\begin{code}
    double x = area(3.0);
\end{code}

Java goes looking for a method named \java{area} that takes one \java{double} as an argument, and so it uses the first version, which interprets the argument as a radius.
If you write:

\begin{code}
    double x = area(1.0, 2.0, 4.0, 6.0);
\end{code}

Java uses the second version of \java{area}, which
actually invokes the first version.

Many Java methods are overloaded, meaning that there are different versions that accept different numbers or types of parameters.
For example, there are versions of \java{print} and \java{println} that accept a single parameter of any data type.
In the Math class, there is a version of \java{abs} that works on \java{double}s, and there is also a version for \java{int}s.

Although overloading is a useful feature, it should be used with caution.
You might get yourself nicely confused if you are trying to debug one version of a method while accidentally invoking a different one.


\section{Boolean methods}
\label{boolean}

\index{boolean}
\index{method!boolean}

Methods can return \java{boolean} values just like any other type, which is often convenient for hiding tests inside methods.
For example:

\begin{code}
    public static boolean isSingleDigit(int x) {
        if (x >= 0 && x < 10) {
            return true;
        } else {
            return false;
        }
    }
\end{code}

The name of this method is \java{isSingleDigit}.
It is common to give \java{boolean} methods names that sound like yes/no questions.
Since the return type is \java{boolean}, the return statement has to provide a boolean expression.

The code itself is straightforward, although it is longer than it needs to be.
Remember that the expression \java{x >= 0 \&\& x < 10} has type boolean, so there is nothing wrong with returning it directly (without the \java{if} statement):

\begin{code}
    public static boolean isSingleDigit(int x) {
        return x >= 0 && x < 10;
    }
\end{code}

In \java{main}, you can invoke the method in the usual ways:

\begin{code}
    System.out.println(isSingleDigit(2));
    boolean bigFlag = !isSingleDigit(17);
\end{code}

The first line prints \java{true} because 2 is a single-digit number.
The second line sets \java{bigFlag} to \java{true}, because 17 is {\em not} a single-digit number.

Decision statements often invoke \java{boolean} methods for the condition:

\begin{code}
    if (isSingleDigit(x)) {
        System.out.println("x is small");
    } else {
        System.out.println("x is big");
    }
\end{code}


\section{More recursion}
\label{factorial}

\index{recursion}
\index{language!complete}

\index{Turing, Alan}
\index{Church, Alonzo}

Now that we have methods that return values, we have a {\bf Turing complete} programming language.
That means Java can compute anything computable, for any reasonable definition of ``computable''.
This idea was developed by Alonzo Church and Alan Turing, so it is known as the Church-Turing thesis.
%You can read more about it at \url{http://en.wikipedia.org/wiki/Turing_thesis}.

To give you an idea of what you can do with the tools we have learned, let's look at some methods for evaluating recursively-defined mathematical functions.
A recursive definition is similar to a circular definition, in the sense that the definition contains a reference to the thing being defined.
A truly circular definition is not very useful:

\begin{description}
\term{recursive} an adjective used to describe a method that is recursive.
\end{description}

If you saw that definition in the dictionary, you might be annoyed.
In fact, if you search for recursion on Google, it displays ``Did you mean: recursion'' as an inside joke.

\index{factorial}

Many mathematical functions are defined recursively.
For example, if you look up the definition of {\bf factorial}, you get something like:

\vspace{-1ex}
\begin{eqnarray*}
&&  0! = 1 \\
&&  n! = n \cdot(n-1)!
\end{eqnarray*}
\vspace{-1ex}

Factorial is usually denoted with the symbol $!$, which is not to be confused with the Java operator \java{!} that means NOT.

This definition says that the factorial of 0 is 1, and the factorial of any other value $n$ is $n$ multiplied by the factorial of $n-1$.
So $3!$ is 3 times $2!$, which is 2 times $1!$, which is 1 times $0!$, which is 1.
Putting it all together, we get $3!$ equal to 3 times 2 times 1 times 1, which is 6.

If you can formulate a recursive definition of something, you can easily write a Java method to evaluate it.
The first step is to decide what the parameters and return type are.
Since factorial is defined for integers, the method takes an \java{int} as a parameter and returns an \java{int}.
So here's a good starting place:

\begin{code}
    public static int factorial(int n) {
        return 0;
    }
\end{code}

Next, we think about the base case.
If the argument happens to be zero, we simply return 1.

\begin{code}
    public static int factorial(int n) {
        if (n == 0) {
            return 1;
        }
        return 0;
    }
\end{code}

Otherwise, and this is the interesting part, we have to make a recursive call to find the factorial of $n-1$, and then multiply it by $n$.

\begin{code}
    public static int factorial(int n) {
        if (n == 0) {
            return 1;
        }
        int recurse = factorial(n - 1);
        int result = n * recurse;
        return result;
    }
\end{code}

The flow of execution for this program is similar to \java{countdown} from Section~5.8.
If we invoke \java{factorial} with the value 3:

\vspace{-1ex}
\begin{quote}
Since 3 is not zero, we take the second branch and calculate the factorial of $n-1$...
\begin{quote}
Since 2 is not zero, we take the second branch and calculate the factorial of $n-1$...
\begin{quote}
Since 1 is not zero, we take the second branch and calculate the factorial of $n-1$...
\begin{quote}
Since 0 {\em is} zero, we take the first branch and return the value 1 immediately.
% without making any more recursive invocations.
\end{quote}
The return value (1) gets multiplied by \java{n}, which is 1, and the result is returned.
\end{quote}
The return value (1) gets multiplied by \java{n}, which is 2, and the result is returned.
\end{quote}
The return value (2) gets multiplied by \java{n}, which is 3, and the result, 6, is returned to whatever invoked \java{factorial(3)}.
\end{quote}
\vspace{-1ex}

\index{stack}
\index{diagram!stack}

Figure~\ref{fig:stack3} shows what the stack diagram looks like for this sequence of method invocations.
The return values are shown being passed back up the stack.
Notice that \java{recurse} and \java{result} do not exist in the last frame, because when \java{n == 0} the code that creates them does not execute.

\begin{figure}[!h]
\begin{center}
\includegraphics{figs/stack3.pdf}
\caption{Stack diagram for the \java{factorial} method.}
\label{fig:stack3}
\end{center}
\end{figure}


\section{Leap of faith}
\label{leap of faith}

\index{leap of faith}

Following the flow of execution is one way to read programs, but it can quickly become overwhelming.
An alternative is a ``leap of faith'':
when you come to a method invocation, instead of following the flow of execution, you {\em assume} that the method works correctly and returns the appropriate value.

In fact, you are already practicing this leap of faith when you use methods in the Java library.
When you invoke \java{Math.cos} or \java{System.out.println}, you don't examine the implementations of those methods.
You just assume that they work properly.

You should apply the same reasoning to your own methods.
For example, in Section~\ref{boolean} we wrote a method called \java{isSingleDigit} that determines whether a number is between 0 and 9.
Once we convince ourselves that this method is correct---by testing and examination of the code---we can use the method without ever looking at the implementation again.

The same is true of recursive programs.
When you get to the recursive call, instead of following the flow of execution you should {\em assume} that the recursive invocation works.
For example, ``Assuming that I can find the factorial of $n-1$, can I compute the factorial of $n$?''
Yes you can, by multiplying by $n$.

Of course, it is strange to assume that the method works correctly when you have not finished writing it, but that's why it's called a leap of faith!


\section{One more example}
\label{fibonacci}

\index{fibonacci}

Another common recursively-defined mathematical function is the Fibonacci sequence, which has the following definition:

\vspace{-1ex}
\begin{eqnarray*}
&& fibonacci(1) = 1 \\
&& fibonacci(2) = 1 \\
&& fibonacci(n) = fibonacci(n-1) + fibonacci(n-2);
\end{eqnarray*}
\vspace{-1ex}

Translated into Java, this function is simply:

\begin{code}
    public static int fibonacci(int n) {
        if (n == 1 || n == 2) {
            return 1;
        }
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
\end{code}

If you try to follow the flow of execution here, even for small values of \java{n}, your head will explode.
But according to the leap of faith, if we assume that the two recursive invocations work correctly, then it is clear that we get the right result by adding them together.


\section{Testing with JUnit}
\label{JUnit}

To convince yourself that anything works, you should test it.
Since we can compute Fibonacci numbers by hand, we can write a simple \java{main} method to test the \java{fibonacci} method.
The first ten Fibonacci numbers are 1, 1, 2, 3, 5, 8, 13, 21, 34, and 55.

\begin{code}
    public static void main(String[] args) {
        if (fibonacci(1) != 1) {
            System.err.println("fibonacci(1) is incorrect");
        }
        // copy that if statement nine more times
    }
\end{code}

JUnit is a framework that helps automate and standardize this kind of testing (see \url{http://junit.org/}).
The basic pattern is simple:

\begin{itemize}
\item For every class \java{X} there is a corresponding class named \java{XTest} that is responsible for testing the class.
\item For every method \java{m} there is a corresponding method \java{testM} that is responsible for testing the method.
\end{itemize}

For example, the \java{fibonacci} method in the previous section belongs to a class named \java{Series}.
Here are the corresponding test class and test method:

\begin{code}
import junit.framework.TestCase;

public class SeriesTest extends TestCase {

    public void testFibonacci() {
        assertEquals(1, Series.fibonacci(1));
        assertEquals(1, Series.fibonacci(2));
        assertEquals(2, Series.fibonacci(3));
        assertEquals(3, Series.fibonacci(4));
        // six more assertEquals statements
    }
}
\end{code}

JUnit uses some Java language features we have not see yet, like the keyword \java{extends}.
But it's easy to get started by writing simple test methods.
In \mbox{DrJava}, you can select ``File $>$ New JUnit Test Case'' from the menu to generate a test class and methods.

JUnit provides a family of overloaded \java{assert} methods.
In the example above, \java{assertEquals} compares the expected value with the actual value, that is, what \java{fibonacci} returns.
If \java{assertEquals} fails, it displays an error showing the values that did not match.
This code is more concise than writing your own \java{if} statements and \java{System.err} messages.

To run JUnit directly from DrJava, click the {\tt Test} button on the toolbar.
If all your test methods pass, you will see a green bar in the lower right.
Otherwise, DrJava will take you directly to the first assertion that failed.


\section{Vocabulary}

\begin{description}

\term{value method}
A method that returns a value.

\term{void method}
A method that does not return a value.

\term{return type}
The type of value a method returns.

\term{return value}
The value provided as the result of a method invocation.

\term{void}
A special return type indicating the method does not return a value.

\term{temporary variable}
A variable that is short-lived, often used for debugging purposes.

\term{dead code}
Part of a program that can never be executed, often because it appears after a \java{return} statement.

\term{incremental development}
A process for creating programs by writing a few lines at a time,
compiling, and testing.

\term{stub}
A placeholder for an incomplete method so that the class will compile.

\term{scaffolding}
Code that is used during program development but is not part of the final version.

\term{overloading}
Defining more than one method with the same name but different parameters.
%When you invoke an overloaded method, Java knows which version to use by looking at the arguments you provide.

\term{Turing complete}
A programming language that can implement any theoretically possible algorithm.

\term{factorial}
The product of all the integers up to and including a given integer.

\end{description}


\section{Exercises}


\begin{exercise}

Answer the following questions by trying them out.
In fact, any time you have a question about what is legal or illegal in Java, a good way to find out is to ask the compiler.

\begin{enumerate}

\item What happens if you invoke a value method and don't do anything with the result?
(In other words, if you don't assign it to a variable or use it as part of a larger expression?)

\item What happens if you use a \java{print} method as part of an expression?
For example: \java{System.out.println("boo!") + 7;}

%TODO: any more?

\end{enumerate}

\end{exercise}


\begin{exercise}
\label{ex.isdiv}

Write a method named \java{isDivisible} that takes two integers, \java{n} and \java{m}, and that returns \java{true} if \java{n} is divisible by \java{m}, and \java{false} otherwise.

\end{exercise}


\begin{exercise}

If you are given three sticks, you may or may not be able to arrange them in a triangle.
For example, if one of the sticks is 12 inches long and the other two are one inch long, you will not be able to get the short sticks to meet in the middle.
For any three lengths, there is a simple test to see if it is possible to form a triangle:

\begin{quote}
``If any of the three lengths is greater than the sum of the other two, then you cannot form a triangle.''
\end{quote}

Write a method named \java{isTriangle} that takes three integers as arguments and returns either \java{true} or \java{false}, depending on whether you can or cannot form a triangle from sticks with the given lengths.
The point of this exercise is to use conditional statements to write a value method.

\end{exercise}


\begin{exercise}
\label{ex.multadd}

Many computations can be expressed more concisely using the ``multadd'' operation, which takes three operands and computes \java{a * b + c}.
Some processors even provide a hardware implementation of this operation for floating-point numbers.

\begin{enumerate}

\item Create a new program called {\tt Multadd.java}.

\item Write a method called \java{multadd} that takes three \java{doubles} as parameters and that returns \java{a * b + c}.

\item Write a \java{main} method that tests \java{multadd} by invoking it with a few simple parameters, like \java{1.0, 2.0, 3.0}.

\item Also in \java{main}, use \java{multadd} to compute the following values:
%
\begin{eqnarray*}
& \sin \frac{\pi}{4} + \frac{\cos \frac{\pi}{4}}{2} & \\
& \log 10 + \log 20 &
\end{eqnarray*}

\item Write a method called \java{yikes} that takes a double as a parameter and that uses \java{multadd} to calculate:
%
\begin{eqnarray*}
x e^{-x} + \sqrt{1 - e^{-x}}
\end{eqnarray*}
%
HINT: The Math method for raising $e$ to a power is \java{Math.exp}.

\end{enumerate}

In the last part, you get a chance to write a method that invokes a method you wrote.
Whenever you do that, it is a good idea to test the first method carefully before you start working on the second.
Otherwise, you might find yourself debugging two methods at the same time, which can be difficult.

One of the purposes of this exercise is to practice pattern-matching: the ability to recognize a specific problem as an instance of a general category of problems.

\end{exercise}


\begin{exercise}

In this exercise, you will use a stack diagram to understand the execution of the following recursive program.

\begin{code}
public class Prod {

    public static void main(String[] args) {
        System.out.println(prod(1, 4));
    }

    public static int prod(int m, int n) {
        if (m == n) {
            return n;
        } else {
            int recurse = prod(m, n-1);
            int result = n * recurse;
            return result;
        }
    }
}
\end{code}

\begin{enumerate}

\item Draw a stack diagram showing the state of the program just before the last instance of \java{prod} completes.
What is the output of this program?

\item Explain in a few words what \java{prod} does.

\item Rewrite \java{prod} without using temporary variables \java{recurse} and \java{result}.

\end{enumerate}

\end{exercise}


\begin{exercise}

What is the output of the following program?

\begin{code}
    public static void main(String[] args) {
        boolean flag1 = isHoopy(202);
        boolean flag2 = isFrabjuous(202);
        System.out.println(flag1);
        System.out.println(flag2);
        if (flag1 && flag2) {
            System.out.println("ping!");
        }
        if (flag1 || flag2) {
            System.out.println("pong!");
        }
    }

    public static boolean isHoopy(int x) {
        boolean hoopyFlag;
        if (x % 2 == 0) {
            hoopyFlag = true;
        } else {
            hoopyFlag = false;
        }
        return hoopyFlag;
    }

    public static boolean isFrabjuous(int x) {
        boolean frabjuousFlag;
        if (x > 0) {
            frabjuousFlag = true;
        } else {
            frabjuousFlag = false;
        }
        return frabjuousFlag;
    }
\end{code}

The purpose of this exercise is to make sure you understand logical operators and the flow of execution through value methods.

\end{exercise}


\begin{exercise}

The purpose of this exercise is to translate a recursive definition into a Java method.
The Ackermann function is defined for non-negative integers as follows:
\begin{eqnarray*}
A(m, n) = \begin{cases}
              n+1 & \mbox{if } m = 0 \\
        A(m-1, 1) & \mbox{if } m > 0 \mbox{ and } n = 0 \\
A(m-1, A(m, n-1)) & \mbox{if } m > 0 \mbox{ and } n > 0.
\end{cases}
\end{eqnarray*}

Write a method called \java{ack} that takes two \java{int}s as parameters and that computes and returns the value of the Ackermann function.

Test your implementation of Ackermann by invoking it from \java{main} and printing the return value.
Note the return value gets very big very quickly.
You should try it only for small values of $m$ and $n$ (not bigger than 3).

\end{exercise}


\begin{exercise}
\label{ex.power}

Write a recursive method called \java{power} that takes a double \java{x} and an integer \java{n} and that returns $x^n$.

Hint: a recursive definition of this operation is $x^n = x \cdot x^{n-1}$.
Also, remember that anything raised to the zeroeth power is 1.

Optional challenge: you can make this method more efficient, when \java{n} is even, using $x^n = \left( x^{n/2} \right)^2$.

\end{exercise}


\begin{exercise}
\label{gcd}

Write a method called \java{gcd} that takes two integer parameters and that uses Euclid's algorithm to compute and return the greatest common divisor of the two numbers.

The following technique is known as Euclid's Algorithm, because it appears in Euclid's {\em Elements} (Book 7, ca.~300 BC).
It may be the oldest recorded nontrivial algorithm.
The process is based on the observation that, if $r$ is the remainder when $a$ is divided by $b$, then the common divisors of $a$ and $b$ are the same as the common divisors of $b$ and $r$.
\[ gcd(a, b) = gcd(b, r) \]
%
We can use this fact to reduce the problem of computing a GCD to the problem of computing the GCD of smaller and smaller pairs of integers.
For example:
\[ gcd(36, 20) = gcd(20, 16) = gcd(16, 4) = gcd(4, 0) = 4 \]
%implies that the GCD of 36 and 20 is 4.

%It can be shown that for any two starting numbers, this repeated reduction eventually produces a pair where the second number is 0.
%Then the GCD is the other number in the pair.

(This exercise is based on page 44 of Ableson and Sussman's {\em Structure and Interpretation of Computer Programs}.)

\end{exercise}


\chapter{Loops and iteration}

Computers are often used to automate repetitive tasks.
Repeating tasks without making errors is something that computers do well and people do poorly.

\index{iteration}

We have already seen methods like \java{countdown} and \java{factorial} that use recursion to run the same code multiple times.
Although recursion is elegant and powerful, Java provides language features that make it much easier to repeat code.
In this chapter, we present {\bf iteration} using \java{while} and \java{for} statements.


\section{The while statement}

\index{statement!while}
\index{while statement}

Using a \java{while} statement, we can rewrite \java{countdown} this way:

\begin{code}
    public static void countdown(int n) {
        while (n > 0) {
            System.out.println(n);
            n = n - 1;
        }
        System.out.println("Blastoff!");
    }
\end{code}

You can almost read a \java{while} statement like English.
The above code means: ``While \java{n} is greater than zero, print the value of \java{n} and then reduce the value of \java{n} by 1.
When you get to zero, print the word Blastoff!''

More formally, the flow of execution for a \java{while} statement is three steps:

\begin{enumerate}

\item Evaluate the condition in parentheses, yielding \java{true} or \java{false}.

\item If the condition is \java{false}, exit the \java{while} block and continue execution at the next statement.

\item If the condition is \java{true}, execute the statements between the braces, and then go back to step 1.

\end{enumerate}

\index{loop}
\index{loop!body}
\index{body}

This type of flow is called a {\bf loop}, because the last step loops back around to the first.
The statements inside the \java{while} block are called the {\bf body} of the loop.
If the condition is \java{false} the first time, the statements inside the \java{while} block are never executed.

\index{loop!infinite}
\index{infinite loop}

The body of the loop should change the value of one or more variables so that, eventually, the condition becomes \java{false} and the loop terminates.
Otherwise the loop will repeat forever, which is called an {\bf infinite loop}.
An endless source of amusement for computer scientists is the observation that the directions on shampoo, ``Lather, rinse, repeat,'' are an infinite loop.

In the case of \java{countdown}, we can prove that the loop terminates when \java{n} is positive.
But in general, it is not so easy to tell whether a loop terminates.
For example, this loop continues until \java{n} is 1 (which makes the condition \java{false}).

\begin{code}
    public static void sequence(int n) {
        while (n != 1) {
            System.out.println(n);
            if (n % 2 == 0) {         // n is even
                n = n / 2;
            } else {                  // n is odd
                n = n * 3 + 1;
            }
        }
    }
\end{code}

At each iteration, the program prints the value of \java{n} and then checks whether it is even or odd.
If it is even, the value of \java{n} is divided by two.
If it is odd, the value is replaced by $3n+1$.
For example, if the starting value (the argument passed to \java{sequence}) is 3, the resulting sequence is 3, 10, 5, 16, 8, 4, 2, 1.

Since \java{n} sometimes increases and sometimes decreases, there is no obvious proof that \java{n} will ever reach 1 and that the program will ever terminate.
For some particular values of \java{n}, we can prove termination.
For example, if the starting value is a power of two, then the value of \java{n} will be even every time through the loop until we get to 1.
The previous example ends with such a sequence, starting with 16.

Particular values aside, the interesting question is whether we can prove that this program terminates for {\em all} values of n.
So far, no one has been able to prove it {\em or} disprove it!
For more information, see \url{http://en.wikipedia.org/wiki/Collatz_conjecture}.
%The field of computer science is interested in these types of questions, because their answers give insight to the limits of what computers can and cannot do.


\section{Generating tables}

\index{table}
\index{logarithm}

One of the things loops are good for is generating and printing tabular data.
Before computers were readily available, people had to calculate logarithms, sines and cosines, and other common mathematical functions by hand.
To make that easier, there were books containing long tables where you could find the values of various functions.
Creating these tables was slow and boring, and the results were often full of errors.

When computers appeared on the scene, one of the initial reactions was, ``This is great!
We can use the computers to generate the tables, so there will be no errors.''
That turned out to be true (mostly), but shortsighted.
Not much later, computers were so pervasive that printed tables became obsolete.

\index{division!floating-point}

Even so, for some operations, computers use tables of values to get an approximate answer, and then perform computations to improve the approximation.
In some cases, there have been errors in the underlying tables, most famously in the table the original Intel Pentium used to perform floating-point division (see \url{http://en.wikipedia.org/wiki/Pentium_FDIV_bug}).

Although a ``log table'' is not as useful as it once was, it still makes a good example of iteration.
The following program prints a sequence of values in the left column and their logarithms in the right column:

\begin{code}
    double x = 1.0;
    while (x < 10.0) {
        System.out.println(x + "   " + Math.log(x));
        x = x + 1.0;
    }
\end{code}

The output of this program is:

\begin{stdout}
1.0   0.0
2.0   0.6931471805599453
3.0   1.0986122886681098
4.0   1.3862943611198906
5.0   1.6094379124341003
6.0   1.791759469228055
7.0   1.9459101490553132
8.0   2.0794415416798357
9.0   2.1972245773362196
\end{stdout}

Looking at these values, can you tell what base \java{Math.log} uses?
Since powers of two are important in computer science, we often want logarithms with respect to base 2.
To compute them, we can apply this property of logarithms:
%
\[ \log_2 x = \frac{log_e x}{log_e 2} \]
%
Using the right side of the formula, we modify the \java{println} statement.

\begin{code}
    System.out.println(x + "   " + Math.log(x) / Math.log(2));
\end{code}

We can see that 1, 2, 4 and 8 are powers of two, because their logarithms base 2 are round numbers.

\begin{stdout}
1.0   0.0
2.0   1.0
3.0   1.5849625007211563
4.0   2.0
5.0   2.321928094887362
6.0   2.584962500721156
7.0   2.807354922057604
8.0   3.0
9.0   3.1699250014423126
\end{stdout}

If we wanted to find the logarithms of other powers of two, we could modify the program like this:

\begin{code}
    final double log2 = Math.log(2);
    double x = 1.0;
    while (x < 100.0) {
        System.out.println(x + "   " + Math.log(x) / log2);
        x = x * 2.0;
    }
\end{code}

First, we store \java{Math.log(2)} in a \java{final} variable to avoid computing that value over and over again.
Second, instead of adding something to \java{x} each time through the loop, which yields an {\em arithmetic sequence}, we multiply \java{x} by something, yielding a {\em geometric sequence}.
The result is:

\begin{stdout}
1.0   0.0
2.0   1.0
4.0   2.0
8.0   3.0
16.0   4.0
32.0   5.0
64.0   6.0
\end{stdout}

Log tables may not be useful any more, but for computer scientists, knowing the powers of two helps a lot!
%When you have an idle moment, you should memorize the powers of two up to 65536 (that's $2^{16}$).


\section{Program development}
\label{encapsulation}

\index{table!two-dimensional}

Two-dimensional tables consist of rows and columns that list values at the intersections.
A multiplication table is a good example.
Let's say you want to print a multiplication table for the values from 1 to 6.
A good way to start is a simple loop that prints the multiples of 2, all on one line.

\begin{code}
    int i = 1;
    while (i <= 6) {
        System.out.printf("%4d", 2 * i);
        i = i + 1;
    }
    System.out.println();
\end{code}

\index{loop variable}
\index{variable!loop}

The first line initializes a variable named \java{i}, which is going to act as a counter, or {\bf loop variable}.
As the loop executes, the value of \java{i} increases from 1 to 6; when \java{i} is 7, the loop terminates.
Each time through the loop, we print the value \java{2 * i}, padded with spaces so it's four characters wide.
Since we use \java{System.out.printf}, the output appears on a single line.

We need to call \java{println} after the loop to complete the line of output.
In some environments, the output from \java{printf} gets stored without being displayed until \java{println} is invoked.
If the program terminates, and you forget to invoke \java{println}, you may never see the stored output.

The output of the code so far is:

\begin{stdout}
    2    4    6    8   10   12
\end{stdout}

\index{encapsulation}
\index{generalization}

Now that we've solved part of the problem, we can encapsulate and generalize the code to do the rest.
{\bf Encapsulation} means taking a piece of code and wrapping it up in a method, allowing you to take advantage of all the things methods are good for.
%We have seen two examples of encapsulation, when we wrote \java{printParity} in Section~\ref{alternative} and \java{isSingleDigit} in Section~\ref{boolean}.
{\bf Generalization} means taking something specific, like printing multiples of 2, and making it more general, like printing the multiples of any integer.
%Here's a method that encapsulates the loop and then generalizes it to print multiples of \java{n}.

\begin{code}
    public static void printMultiples(int n) {
        int i = 1;
        while (i <= 6) {
            System.out.printf("%4d", n * i);
            i = i + 1;
        }
        System.out.println();
    }
\end{code}

To encapsulate, we added the first line, which declares the method name, parameter, and return type.
To generalize, we replaced the value 2 with the parameter \java{n}.
The whole point of parameters is to allow you to write general purpose methods.

Note that invoking this method with the argument 2 yields the same output as before.
With the argument 3, the output becomes:

\begin{stdout}
    3    6    9   12   15   18
\end{stdout}

And with argument 4, the output is:

\begin{stdout}
    4    8   12   16   20   24
\end{stdout}

By now you can probably guess how we are going to print a multiplication table: we'll invoke \java{printMultiples} repeatedly with different arguments.
In fact, we are going to use another loop to iterate through the rows.

\begin{code}
    int i = 1;
    while (i <= 6) {
        printMultiples(i);
        i = i + 1;
    }
\end{code}

First, notice how similar this loop is to the one inside \java{printMultiples}.
All we did was replace the \java{printf} statement with a method invocation.
Also, notice how the format specifier \java{"\%4d"} in \java{printMultiples} causes the output to align vertically, regardless of whether the numbers are one or two digits.

\begin{stdout}
    1    2    3    4    5    6
    2    4    6    8   10   12
    3    6    9   12   15   18
    4    8   12   16   20   24
    5   10   15   20   25   30
    6   12   18   24   30   36
\end{stdout}

%\section{Generalization}
%\label{methods}
%\index{method}
%\index{encapsulation}
%
%In Section~\ref{adding_methods} I listed some of the reasons methods are useful.
%Here are several more:
%
%\begin{itemize}
%\item By giving a name to a sequence of statements, you make your program easier to read and debug.
%\item Dividing a long program into methods allows you to separate parts of the program, debug them in isolation, and then compose them into a whole.
%\item Methods facilitate both recursion and iteration.
%\item Well-designed methods are often useful for many programs. Once you write and debug one, you can reuse it.
%\end{itemize}

One of the challenges of programming, especially for beginners, is figuring out how to divide up a program into methods.
The process of encapsulation and generalization allows you design as you go along.
You start by adding code to \java{main} or some another method.
When you get the code working, you wrap it up in a new method and generalize it by adding parameters.
Then you repeat, alternately developing new code and creating new methods.

As a final example, we can take the code above and wrap it up in a method:

\begin{code}
    public static void printMultTable() {
        int i = 1;
        while (i <= 6) {
            printMultiples(i);
            i = i + 1;
        }
    }
\end{code}

\index{program development}

Encapsulation and generalization, as demonstrated in this section, is a useful and common process for {\bf program development}.
In later chapters we will present some alternatives.


\section{Local variables}

You might wonder how we can use the same variable \java{i} in both \java{printMultiples} and \java{printMultTable}.
Isn't it true that you can only declare a variable once?
And doesn't it cause problems when one of the methods changes the value of the variable?

The answer to both questions is ``no,'' because the \java{i} in \java{printMultiples} and the \java{i} in \java{printMultTable} are {\em not the same variable}.
They have the same name, but they do not refer to the same storage location.
Changing the value of one variable has no effect on the other.
Consider the stack diagram at the moment the program begins printing the second row of the table:

\begin{center}
\vspace{1em}
\includegraphics{figs/stack4.pdf}
\vspace{1em}
\end{center}

%\begin{tabular}{rl}
%          main & \framebox[3cm][r]{\strut args ~\framebox[1cm]{\strut  }~} \\[1em]
%printMultTable & \framebox[3cm][r]{\strut    i ~\framebox[1cm]{\strut 2}~} \\[1em]
%printMultiples & \framebox[3cm][r]{\strut    i ~\framebox[1cm]{\strut 2}~} \\[1em]
%\end{tabular}

\index{local variable}
\index{variable!local}

Variables and parameters declared inside a method definition are called {\bf local variables} because they only exist inside the method.
You cannot access a local variable from outside its method, and you are free to have multiple variables with the same name as long as they are not in the same method.

\index{loop variable}
\index{variable!loop}

Although it can be confusing, there are good reasons to reuse names.
For example, it is common to use the names \java{i}, \java{j} and \java{k} as loop variables.
If you avoid using them in one method just because you used them somewhere else, you make the program harder to read.
Another reason is when two or more methods are based on the same parameter.
It's awkward to come up with many different names for the same data.


\section{More generalization}
\index{generalization}

Imagine a program that prints multiplication tables of any size, not just the 6x6 table.
All we need is to add a parameter to \java{printMultTable}:

\begin{code}
    public static void printMultTable(int size) {
        int i = 1;
        while (i <= size) {
            printMultiples(i);
            i = i + 1;
        }
    }
\end{code}

Rather than use the literal value 6 in the while statement, we generalize by using the parameter \java{size}.
Here is the output when you invoke \java{printMultTable} with the argument 7:

\begin{stdout}
   1   2   3   4   5   6
   2   4   6   8  10  12
   3   6   9  12  15  18
   4   8  12  16  20  24
   5  10  15  20  25  30
   6  12  18  24  30  36
   7  14  21  28  35  42
\end{stdout}

This result is fine, but it would be even better if it were square (i.e., the same number of rows and columns).
We can pass the \java{size} parameter to \java{printMultiples} to specify how many columns the table should have.

\begin{code}
    public static void printMultiples(int n, int size) {
        int i = 1;
        while (i <= size) {
            System.out.printf("%4d", n * i);
            i = i + 1;
        }
        System.out.println();
    }
\end{code}

%\begin{code}
%    public static void printMultTable(int size) {
%        int i = 1;
%        while (i <= size) {
%            printMultiples(i, size);
%            i = i + 1;
%        }
%    }
%\end{code}

Since we added a new parameter to \java{printMultiples}, we also have to change the line \java{printMultiples(i, size);} where it is invoked in \java{printMultTable}.
As expected, this program generates a square 7x7 table:

\begin{stdout}
   1   2   3   4   5   6   7
   2   4   6   8  10  12  14
   3   6   9  12  15  18  21
   4   8  12  16  20  24  28
   5  10  15  20  25  30  35
   6  12  18  24  30  36  42
   7  14  21  28  35  42  49
\end{stdout}

When you generalize a method appropriately, you often find that it has capabilities you did not plan.
For example, you might notice that the multiplication table is symmetric, because $ab = ba$, so all the entries in the table appear twice.
You could save ink by printing half the table, and you would only have to change one line of \java{printMultTable}:

\begin{code}
      printMultiples(i, i);
\end{code}

In other words, the \java{size} of each row is the same as the row number itself.

\begin{stdout}
   1
   2   4
   3   6   9
   4   8  12  16
   5  10  15  20  25
   6  12  18  24  30  36
   7  14  21  28  35  42  49
\end{stdout}

Even though the second parameter in \java{printMultiples} is named \java{size} and we have a variable with the same name, we can still use any value or expression we want for the argument.
Remember you do not pass {\em variables} to methods; you pass their current {\em values}.


\section{The for statement}
\label{for}

\index{for}
\index{loop!for}
\index{statement!for}

The loops we have written so far have a number of elements in common.
All of them start by initializing a variable; they have a test, or condition, that depends on that variable; and inside the loop they do something to update that variable.
This type of loop is so common that there is another statement, called \java{for}, that expresses it more concisely.

\begin{code}
    for (INITIALIZER; CONDITION; INCREMENTOR) {
        BODY
    }
\end{code}

This structure is equivalent to the following \java{while} loop:

\begin{code}
    INITIALIZER
    while (CONDITION) {
        BODY
        INCREMENTOR
    }
\end{code}

The \java{for} loop is more concise and easier to read, since it puts all the loop-related statements in one place.

\begin{code}
    for (int i = 0; i < 4; i++) {
        System.out.println(i);
    }
\end{code}

We easily rewrite any \java{for} statement as a \java{while} statement by separating the loop components:

\begin{code}
    int i = 0;
    while (i < 4) {
        System.out.println(i);
        i++;
    }
\end{code}

The statement \java{i++;} is shorthand for \java{i = i + 1;} and is commonly used in loop structures.
The \java{++} operator increments a variable by one, and the \java{--} operator decrements a variable by one.

There is one difference between the \java{for} and \java{while} loops above: where the variable \java{i} is declared.
After the \java{for} loop, the variable \java{i} ceases to exist because it was declared in the loop header.
In contrast, the variable \java{i} continues to exist after the \java{while} statment, because it was declared outside the loop.

Because \java{for} loops are so concise, they are particularly useful when iterating over two or more dimensions.
We can rewrite the final example of \java{printMultTable} in the previous section with just a few lines of code:

\begin{code}
    for (int row = 1; row <= size; row++) {
        for (int col = 1; col <= row; col++) {
            System.out.printf("%4d", row * col);
        }
        System.out.println();
    }
\end{code}

In contrast to \java{printMultTable} and \java{printMultiples}, this version of the code cannot use the variable \java{i} for both loops.
Instead, it uses the variables \java{row} and \java{col} to represent the positions in the table.


%TODO(csm) tracing code by hand?


\section{Vocabulary}

\begin{description}

\term{loop}
A statement that executes repeatedly while some condition is satisfied.

\term{iteration}
One pass through (execution of) the body of the loop, including the evaluation of the condition.

\term{loop body}
The statements inside the loop.

\term{infinite loop}
A loop whose condition is always true.

\term{loop variable}
A variable that is initialized, tested, and updated in order to control a loop.

\term{encapsulate}
To divide a large complex program into components (like methods) and isolate the components from each other (for example, by using local variables).

\term{generalize}
To replace something unnecessarily specific (like a constant value) with something appropriately general (like a variable or parameter).
Generalization makes code more versatile, more likely to be reused, and sometimes even easier to write.

\term{local variable}
A variable that is declared inside a method and that exists only within that method.
Local variables cannot be accessed from outside their method and do not interfere with any other methods.

\term{program development}
A process for writing programs.
So far we have seen ``incremental development'' and ``encapsulation and generalization.''

\end{description}


\section{Exercises}


\begin{exercise}
\label{infloop}

Consider the following code:

\begin{code}
public static void main(String[] args) {
    loop(10);
}

public static void loop(int n) {
    int i = n;
    while (i > 0) {
        System.out.println(i);
        if (i % 2 == 0) {
            i = i / 2;
        } else {
            i = i + 1;
        }
    }
}
\end{code}

\begin{enumerate}

\item Draw a table that shows the value of the variables \java{i} and \java{n} during the execution of \java{loop}.
The table should contain one column for each variable and one line for each iteration.

\item What is the output of this program?

\item Can you prove that this loop terminates for any positive value of \java{n}?

\end{enumerate}

\end{exercise}


\begin{exercise}

Let's say you are given a number, $a$, and you want to find its square root.
One way to do that is to start with a rough guess about the answer, $x_0$, and then improve the guess using the following average:
%
\[ x_1 =(x_0 + a/x_0) / 2 \]
%
For example, if we want to find the square root of 9, and we start with $x_0 = 6$, then $x_1 = (6 + 9/6) / 2 = 3.75$, which is closer.
We can repeat the procedure, using $x_1$ to calculate $x_2$, and so on.
In this case, $x_2 = 3.075$ and $x_3 = 3.00091$.
So it converges quickly on the correct answer.

Write a method called \java{squareRoot} that takes a \java{double} and returns an approximation of the square root of the parameter, using this technique.
You may not use \java{Math.sqrt}.

As your initial guess, you should use $a/2$.
Your method should iterate until it gets two consecutive estimates that differ by less than 0.0001.
In other words, return when the absolute value of $x_n - x_{n-1}$ is less than 0.0001.
You can use \java{Math.abs} to calculate the absolute value.

\end{exercise}


\begin{exercise}

In Exercise~\ref{ex.power} we wrote a recursive version of \java{power}, which takes a double \java{x} and an integer \java{n} and returns $x^n$.
Now write an iterative method to perform the same calculation.

\end{exercise}


\begin{exercise}

Section~\ref{factorial} presents a recursive method that computes the factorial function.
Write an iterative version of \java{factorial}.

\end{exercise}


\begin{exercise}

One way to calculate $e^x$ is to use the infinite series expansion:
%
\[ e^x = 1 + x + x^2 / 2! + x^3 / 3! + x^4 / 4! + ... \]
%
If the loop variable is named \java{i}, then the $i$th term is $x^i / i!$.

\begin{enumerate}

\item Write a method called \java{myexp} that adds up the first \java{n} terms of this series.
You can use the \java{factorial} method from Section~\ref{factorial} or your iterative version from the previous exercise.

\item You can make this method more efficient if you realize that, in each iteration, the numerator of the term is the same as its predecessor multiplied by \java{x}, and the denominator is the same as its predecessor multiplied by \java{i}.
Use this observation to eliminate the use of \java{Math.pow} and \java{factorial}, and check that you still get the same result.

\item Write a method called \java{check} that takes a parameter, \java{x}, and prints the values of \java{x}, \java{Math.exp(x)} and \java{myexp(x)} for various values of \java{x}.
The output should look something like:

\begin{stdout}
1.0     2.708333333333333     2.718281828459045
\end{stdout}

Recall that you can use the string \java{"\\t"} to print a tab character between columns of a table.

\item Vary the number of terms in the series (the second argument that \java{check} sends to \java{myexp}) and see the effect on
the accuracy of the result.
Adjust this value until the estimated value agrees with the ``correct'' answer when \java{x} is 1.

\item Write a loop in \java{main} that invokes \java{check} with the values 0.1, 1.0, 10.0, and 100.0.
How does the accuracy of the result vary as \java{x} varies?
Compare the number of digits of agreement rather than the difference between the actual and estimated values.

\item Add a loop in \java{main} that checks \java{myexp} with the values -0.1, -1.0, -10.0, and -100.0.
Comment on the accuracy.

\end{enumerate}

\end{exercise}


\begin{exercise}

One way to evaluate $\exp(-x^2)$ is to use the infinite series expansion:
%
\[ \exp(-x^2) = 1 - x^2 + x^4/2 - x^6/6 + \ldots \]
%
In other words, we need to add up a series of terms where the $i$th term is equal to $(-1)^i x^{2i} / i!$.
Write a method named \java{gauss} that takes \java{x} and \java{n} as arguments and returns the sum of the first \java{n} terms of the series.
You should not use \java{factorial} or \java{pow}.

\end{exercise}


\chapter{Strings and things}
\label{strings}

\index{object}
\index{class!String}
\index{method!string}

In Java and other object-oriented languages, an {\bf object} is a collection of data that provides a set of methods.
These methods operate on the object, performing computations and sometimes modifying the data.
Strings are objects, and their data is a sequence of characters; that is,
letters, numbers, spaces, and symbols.
The \java{String} class provides many methods for manipulating character data, and we will explore some of them in this chapter.


\section{Characters}

\index{charAt}
\index{char}
\index{type!char}

The first method we will look at is \java{charAt}, which extracts a character from a \java{String}.
It returns a \java{char}, a primitive type that can store individual characters (as opposed to strings of them).

\begin{code}
    String fruit = "banana";
    char letter = fruit.charAt(1);
    System.out.println(letter);
\end{code}

The expression \java{fruit.charAt(1)} means that we invoke the \java{charAt} method on the object referenced by \java{fruit}.
The argument \java{1} means that we want to know the letter at position 1.
The result is a character, which is stored in a \java{char} variable named \java{letter}.
When you print the value of \java{letter}, you might be surprised:

\begin{stdout}
a
\end{stdout}

Unless you already think like a computer scientist, the letter \java{a} is not the first letter of \java{"banana"}.
For technical reasons, computer scientists start counting from zero.
The 0th (``zeroeth'') letter of \java{"banana"} is the \java{b}.
The 1th letter (``oneth'') is \java{a} and the 2th (``twooth'') letter is \java{n}.
So if you want the {\em first} letter of a string, you have to pass 0 as the argument:

\begin{code}
    char letter = fruit.charAt(0);
\end{code}

\index{quote}
\index{double-quote}
\index{value!char}

Character literals appear in single quotes like \java{'c'}.
Unlike string literals, which appear in double quotes, characters may only contain a single letter or symbol.

\begin{code}
    char letter = 'c';
    if (letter == 'd') {
        System.out.println('?');
    }
\end{code}

Characters work much like the other primitive types we have seen.
You can use them in arithmetic, decisions, loops, and so forth.

\begin{code}
    System.out.print("Roman alphabet: ");
    for (char c = 'A'; c <= 'Z'; c++) {
        System.out.print(c);
    }
    System.out.println();
\end{code}

\index{Unicode}

Java uses {\bf Unicode} for its character set (see \url{http://unicode.org/}) so that strings may store text in any language.
Unicode supports alphabets like Cyrillic and Greek, and left-to-right scripts like Arabic and Hebrew.
%Regardless, both the data type \java{char} and the method \java{charAt} work the same.

\begin{code}
    System.out.print("Greek alphabet: ");
    for (int i = 913; i <= 937; i++) {
        System.out.print((char) i);
    }
    System.out.println();
\end{code}

This example demonstrates how you can convert a Unicode ``code unit,'' represented as an integer, to a \java{char} using a cast operator.


\section{String traversal}
\label{traverse}

\index{traverse}

A common task with strings is to start at the beginning, select each character in turn, do some computation with it, and continue until the end.
This pattern is called a {\bf traversal}.
A natural way to traverse a string is with a \java{for} statement:

\begin{code}
    for (int i = 0; i < fruit.length(); i++) {
        char letter = fruit.charAt(i);
        System.out.println(letter);
    }
\end{code}

\index{loop variable}
\index{variable!loop}
\index{index}

This loop prints each character of the string \java{fruit} on a line by itself.
The name of the loop variable is \java{i}, which stands for {\bf index}; an
index is an integer that indicates the position of a character.
Notice that the condition is \java{i < fruit.length()}, which means that when \java{i} is equal to the length of the string, the condition is \java{false} and the loop terminates.
%The last character we access is the one with the index \java{fruit.length() - 1}.

\index{String!length}
\index{length!String}

The \java{length} method returns the number of characters in the string.
It takes no arguments and returns an integer; the length of \java{"banana"} is 6.
%Notice that it is legal to have a variable with the same name as a method (although it can be confusing for human readers).
To find the last letter of a string, you might be tempted to try something like:

\begin{code}
    int length = fruit.length();
    char last = fruit.charAt(length);      // WRONG!
\end{code}

This code compiles and runs, but it causes a runtime error.
The reason is that there is no sixth letter in \java{"banana"}.
Since we started counting at 0, the 6 letters are indexed from 0 to 5.
To get the last character, you have to subtract 1 from \java{length}.

\begin{code}
    char last = fruit.charAt(length - 1);  // CORRECT
\end{code}

Many string traversals involve reading one string and creating another.
For example, to reverse a string we simply add one character at a time:

\begin{code}
    public static String reverse(String s) {
        String r = "";
        for (int i = s.length() - 1; i >= 0; i--) {
            r = r + s.charAt(i);
        }
        return r;
    }
\end{code}

\index{empty string}

The initial value of \java{r} is \java{""}, which is the {\bf empty string}.
The loop traverses the letters of \java{s} in reverse order.
Each time through the loop, it creates a new string and assigns it to \java{r}.
When the loop exits, \java{r} contains the letters from \java{s} in reverse order.
So the result of \java{reverse("banana")} is \java{"ananab"}.

%\section{Looping and counting}
\label{loopcount}

\index{loop!counting}
\index{traverse!counting}

Other string traversals involve looping and counting.
The following method counts the number of times a given character appears in a string.
For example, \java{numberOf("banana", 'a')} returns 3.

\begin{code}
    public static int numberOf(String s, char c) {
        int count = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == c) {
                count++;
            }
        }
        return count;
    }
\end{code}

\index{counter}

This method demonstrates a common idiom, called a {\bf counter}.
The variable \java{count} is initialized to zero and then incremented each time we find an \java{'a'}.
When we exit the loop, \java{count} contains the result: the total number of a's.


\section{Substrings}

The \java{substring} method returns new string that copies letters from an existing string, beginning at the given index.

\begin{itemize}
\item \java{fruit.substring(0)} returns \java{"banana"}
\item \java{fruit.substring(2)} returns \java{"nana"}
\item \java{fruit.substring(6)} returns \java{""}
\end{itemize}

The first example returns a copy of the entire string.
The second example returns all but the first two characters.
As the last example shows, \java{substring} returns the empty string if the argument is the length of the string.
To visualize how this method works, it helps to draw a picture:

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
b & a & n & a & n & a \\
\hline
0 & 1 & 2 & 3 & 4 & 5 \\
\hline
\end{tabular}
\end{center}

Like many string methods, \java{substring} is overloaded.
That is, there are other versions of \java{substring} that have different parameters.
If it's invoked with two argments, they are treated as a start and end index:

\begin{itemize}
\item \java{fruit.substring(0, 3)} returns \java{"ban"}
\item \java{fruit.substring(2, 5)} returns \java{"nan"}
\item \java{fruit.substring(6, 6)} returns \java{""}
\end{itemize}

Notice that the character indicated by the end index is not included.
%In other words, substrings are for the interval $[beg, end)$.
One way to remember this detail is to think about how loops work.
Here is a simplified version of \java{substring(2, 5)}:

\begin{code}
    String str = "banana";
    int beg = 2;
    int end = 5;
    String sub = "";
    for (int i = beg; i < end; i++) {
        sub = sub + str.charAt(i);
    }
    System.out.println(sub);  // prints "nan"
\end{code}

Because of the \java{<} operator, the loop terminates when \java{i == end}.
Designing substring this way simplifies many common operations.
For example, to select a substring with length \java{len}, starting at index \java{i}, you could write \java{fruit.substring(i, i + len)}.


\section{Bounds checking}
\label{StringIndexOutOfBounds}

\index{runtime error}
\index{error!runtime}
\index{exception}

If you call the \java{charAt} method with an index that is either negative or greater than \java{length - 1}, you will get an {\bf exception}.
%The same is true when calling \java{substring} with invalid start or end indexes.
When that happens, Java prints an error message and terminates the program.

For example, notice the error in the \java{getLastLetter} method below.
It should be looking at \java{index - 1} instead of \java{index}.

\begin{code}
public class BadString {
    public static void main(String[] args) {
        processWord("banana");
    }
    public static void processWord(String s) {
        char c = getLastLetter(s);
        System.out.println(c);
    }
    public static char getLastLetter(String s) {
        int index = s.length();
        char c = s.charAt(index);  // WRONG!
        return c;
    }
}
\end{code}

When you run the \java{BadString} program, Java prints the following message.

\begin{small}
\begin{stdout}
Exception in thread "main" java.lang.StringIndexOutOfBoundsException:
String index out of range: 6
    at java.lang.String.charAt(String.java:658)
    at BadString.getLastLetter(BadString.java:14)
    at BadString.processWord(BadString.java:8)
    at BadString.main(BadString.java:4)
\end{stdout}
\end{small}

\index{stack trace}

This information is called a {\bf stack trace}, which shows the methods that were running when the error occurred.
The stack trace can be difficult to read, but it contains a lot of useful information.
For one, it tells you that the index 6 was out of range.

More importantly, it shows the line of code where the error occurred.
It may be helpful to read the stack trace bottom-up.
On line~4, \java{main} called \java{processWord}, which on line~8 called \java{getLastLetter}, which on line~14 called \java{charAt}.
The actual error occurred on line 658 of String.java, which is in the source code for the \java{String} class itself.

Although possible, it's unlikely that the Java library code has mistakes that cause programs to crash.
When reading stack diagrams, look for the top line that refers to a file you wrote.
In this example, \java{BadString.java:14} is the most useful debugging information.


\section{The indexOf method}
\index{indexOf}

At first glance, \java{indexOf} is the inverse of \java{charAt}.
The \java{charAt} method takes an index and returns the character at that index.
In contrast, the \java{indexOf} method takes a character and finds an index where that character appears.

\begin{code}
    String fruit = "banana";
    int index = fruit.indexOf('a');
\end{code}

This example finds the index of the letter \java{'a'} in the string.
But the letter appears three times, so it's not obvious what \java{indexOf} should do.
According to the documentation, it returns the index of the {\em first} appearance.

To find subsequent appearances, you can use another version of \java{indexOf}, which takes a second argument that indicates where in the string to start looking.
%For an explanation of this kind of overloading, see Section~\ref{overloading}.

\begin{code}
    int index = fruit.indexOf('a', 2);
\end{code}

This code starts at the third letter (the first \java{'n'}) and finds the next \java{'a'}, which is at index 3.
If the letter happens to appear at the starting index, the starting index is the answer.
So \java{fruit.indexOf('a', 5)} returns 5.

There are subtle differences between \java{charAt} and \java{indexOf}:
\java{charAt} throws an exception if the index is out of range;
\java{indexOf} returns the value \java{-1} if the character does not appear in the string.

You can also use \java{indexOf} to search for an entire string.
For example, the expression \java{fruit.indexOf("nan")} returns 2, whereas \java{fruit.indexOf("zzz")} returns -1 (not found).


\section{String comparison}
\label{immutable}
\label{incomparable}

\index{toUpperCase}
\index{toLowerCase}
\index{immutable}

As you read the documentation of the \java{String} methods, you might notice \java{toUpperCase} and \java{toLowerCase}.
These methods are often a source of confusion, because it sounds like they have the effect of changing (or mutating) an existing string.
It turns out that neither these methods nor any others can change a string, because strings are {\bf immutable}.

When you invoke \java{toUpperCase} on a string object, you get a new string object as a return value.
For example:

\begin{code}
    String name = "Alan Turing";
    String upperName = name.toUpperCase();
\end{code}

\index{Turing, Alan}

After the second line runs, \java{upperName} contains the value \java{"ALAN TURING"}.
But \java{name} still contains \java{"Alan Turing"} as before.

\index{equals}
\index{compareTo}

It is often useful to compare strings to see if they are the same, or to see which comes first in alphabetical order.
It would be nice if we could use the comparison operators, like \java{==} and \java{>}, but we can't.
To compare \java{String}s, we have to use the \java{equals} and \java{compareTo} methods.

\begin{code}
    String name1 = "Alan Turing";
    String name2 = "Ada Lovelace";
    if (name1.equals(name2)) {
        System.out.println("The names are the same.");
    }
\end{code}

The syntax here may seem awkward.
To compare two strings, you have to invoke a method on one of them and pass the other as an argument.
The return value from \java{equals} is straightforward: \java{true} if the strings contain the same characters, and \java{false} otherwise.

\begin{code}
    int diff = name1.compareTo(name2);
    if (diff == 0) {
        System.out.println("The names are the same.");
    } else if (diff < 0) {
        System.out.println("name1 comes before name2.");
    } else if (diff > 0) {
        System.out.println("name2 comes before name1.");
    }
\end{code}

The return value from \java{compareTo} is the {\em difference} between the first characters in the strings that differ.
If the strings are equal, their difference is 0.
If the first string (the one on which the method is invoked) comes first in the alphabet, the difference is negative.
Otherwise, the difference is positive.

In the example above, \java{compareTo} returns positive 8, because the second letter of \java{"Ada"} comes before the second letter of \java{"Alan"} by 8 letters.


\section{Character arithmetic}

% ABD: I propose that we kill this section.  The first example is
% a bad solution, and the second example is string concatentation,
% not character arithmetic. (CSM: the ++ is the arithmetic part.)

% Instead, let's have a section that introduces the Character class
% and some of the methods it provides.

\index{arithmetic!char}

Like the \java{compareTo} method, you too can do arithmetic with characters.
For example, if \java{letter} refers to a lowercase letter, \java{letter - 'a'} yields its position in the alphabet (keeping in mind that 'a' is the zeroeth letter of the alphabet and 'z' is the 25th).

Performing arithmetic on characters is rarely necessary in programs, but it helps demonstrate how text is represented in Java.
For example, we often need to convert between characters that contain numbers (e.g., \java{'0'}, \java{'1'}, \java{'2'}) and their corresponding integers.
A common mistake beginning programmers make is simply to cast a \java{char} to an \java{int}:

\begin{code}
    char letter = '3';
    int x = (int) letter;
    System.out.println(x);
\end{code}

You might expect the value to be 3, but instead you get 51, which is the Unicode value for the character \java{'3'}.
%Remember, not all languages in the world use Arabic numerals like English does.
To convert \java{'3'} to the corresponding integer value, you effectively need to subtract \java{'0'}:

\begin{code}
    int x = (int) (letter - '0');
\end{code}

In both of these examples, the typecast \java{(int)} is not strictly necessary since Java will do the conversion automatically.
Since this conversion can be a bit ugly, it is preferable to use the \java{digit} method in the \java{Character} class instead.
For example, this code converts \java{letter} to the corresponding digit, interpreting it as a base 10 number.

\begin{code}
    int x = Character.digit(letter, 10);
\end{code}

Another use for character arithmetic is to loop through the letters of the alphabet in order.
For example, in Robert McCloskey's book {\em Make Way for Ducklings}, the names of the ducklings form an Abecedarian series: Jack, Kack, Lack, Mack, Nack, Ouack, Pack and Quack.
Here is a loop that prints these names in order:

\begin{code}
    char letter = 'J';
    while (letter <= 'Q') {
        System.out.println(letter + "ack");
        letter++;
    }
\end{code}

Notice that in addition to the arithmetic operators, we can also use the conditional operators on characters.
The output of this program is:

\begin{stdout}
Jack
Kack
Lack
Mack
Nack
Oack
Pack
Qack
\end{stdout}

Of course, that's not quite right because it misspelled ``Ouack'' and ``Quack.''
As an exercise, you can modify the program to correct this error.


\section{Wrapper classes}

In the previous section, we introduced the \java{Character} class.
There are similar classes for the other primitive data types such as \java{Boolean}, \java{Integer}, \java{Long}, and \java{Double}.
These classes are in the \java{java.lang} package, so can use them without explicitly importing them.

Each of these classes defines constants \java{MIN_VALUE} and \java{MAX_VALUE}.
For example, \java{Integer.MIN_VALUE} is the \java{int} $-2147483648$, and \java{Integer.MAX_VALUE} is the \java{int} $2147483647$.
Rather than remember these unusual numbers, you can simply refer to the built-in constants.

Another purpose of wrapper classes is converting values to and from strings.
For example, we can convert a string to an integer using the \java{parseInt} method:

\begin{code}
String str = "12345";
int num = Integer.parseInt(str);
\end{code}

You will find similar methods in the other wrapper classes, for example, \java{Double.parseDouble} and \java{Boolean.parseBoolean}.

These wrapper classes also provide \java{toString}, which returns a string
representation of a number:

\begin{code}
int num = 12345;
String str = Integer.toString(num);
\end{code}

% ABD: There is a jump here from talking about wrapper classes to talking
% about instances of those classes.  I think we don't want to do the
% second part yet.

%As a convenience, Java will automatically convert primitive values to/from their wrapper types.
%We will see later why this code is inefficient.

%\begin{code}
%Integer i = 12345;
%Double d = 123.45;
%\end{code}

%For now, it's important to note that \java{i} and \java{d} are references to %objects.
%In other words, the values {\tt 12345} and {\tt 123.45} have been wrapped %inside objects.
%Like strings, these objects have a variety of methods that can be applied.
%Refer to the documentation for \java{Integer} and \java{Double} for more details.


\section{Vocabulary}

\begin{description}

\term{object}
A collection of related data that comes with a set of methods that operate on it.

\term{Unicode}
A standard for representing characters in most of the world's languages.

\term{traverse}
To iterate through the elements of a set performing a similar operation on each.

\term{index}
A variable or value used to indicate one of the members of a collection, like a character from a string.

\term{empty string}
The string \java{""}, what contains no characters and has a length of zero.

\term{counter}
A variable used to count something, usually initialized to zero and then incremented.

\term{exception}
A runtime error like ArithmeticException or IndexOutOfBoundsException.

\term{stack trace}
An error message that shows the state of a program when an exception occurs.

\term{immutable}
An object that, once created, cannot be modified.
Strings are immutable.

\end{description}


\section{Exercises}

\index{encapsulation}
\index{generalization}


\begin{exercise}

Encapsulate the code in Section~\ref{loopcount} into a method named \java{countLetters}, and generalize it so that it accepts the string and the letter as arguments.
Then rewrite the method so that it uses \java{indexOf} to locate the a's, rather than checking the characters one by one.

\end{exercise}


\begin{exercise}

The purpose of this exercise is to review encapsulation and generalization (see Section~\ref{encapsulation}).

\begin{enumerate}

\item Encapsulate the following code fragment, transforming it into a method that takes a string argument and returns the final value of \java{count}.

\item In a sentence or two, describe what the resulting method does (without getting into the details of how).

\item Now that you have generalized the code so that it works on any string, what could you do to generalize it more?

\item Write several test cases to verify that your generalized code works as expected (see Section~\ref{JUnit}).

\end{enumerate}

\begin{code}
    String s = "((3 + 7) * 2)";
    int len = s.length();

    int i = 0;
    int count = 0;

    while (i < len) {
        char c = s.charAt(i);

        if (c == '(') {
            count = count + 1;
        } else if (c == ')') {
            count = count - 1;
        }
        i = i + 1;
    }

    System.out.println(count);
\end{code}

\end{exercise}


\begin{exercise}

The point of this exercise is to explore Java types and fill in some of the details that aren't covered in the chapter.

\begin{enumerate}

\index{concatenate}

\item Create a new program named {\tt Test.java} and write a \java{main} method that contains expressions that combine various types using the \java{+} operator.
For example, what happens when you ``add'' a \java{String} and a \java{char}?
Does it perform character addition or string concatenation?
What is the type of the result?
(How can you determine the type of the result?)

\item Make a bigger copy of the following table and fill it in.
At the intersection of each pair of types, you should indicate whether it is legal to use the \java{+} operator with these types, what operation is performed (addition or concatenation), and what the type of the result is.

\begin{center}
\begin{tabular}{|l|l|l|l|l|l|} \hline
        &  boolean  &  ~char~  &  ~~int~~  &  double  &  String \\ \hline
boolean &           &          &           &          &         \\ \hline
char    &           &          &           &          &         \\ \hline
int     &           &          &           &          &         \\ \hline
double  &           &          &           &          &         \\ \hline
String  &           &          &           &          &         \\ \hline
\end{tabular}
\end{center}

\item Think about some of the choices the designers of Java made when they filled in this table.
How many of the entries seem unavoidable, as if there was no other choice?
How many seem like arbitrary choices from several equally reasonable possibilities?
Which entries seem most problematic?

\item Here's a puzzler: normally, the statement \java{x++} is exactly equivalent to \java{x = x + 1}.
But if \java{x} is a \java{char}, it's not exactly the same!
In that case, \java{x++} is legal, but \java{x = x + 1} causes an error.
Try it out and see what the error message is, then see if you can figure out what is going on.

\item What happens when you add \java{""} (the empty string) to the other types (e.g., \java{"" + 5})?
How does this technique compare with methods provided by the wrapper classes?

\item For each data type, what types of values can you assign to it? For example, you can assign an \java{int} to a \java{double} but not vice versa.

\end{enumerate}

\end{exercise}


\begin{exercise}

Create a program called {\tt Recurse.java} and type in the following methods:

\begin{code}
    // first: returns the first character of the given String
    public static char first(String s) {
        return s.charAt(0);
    }

    // last: returns a new String that contains all but the
    // first letter of the given String
    public static String rest(String s) {
        return s.substring(1, s.length());
    }

    // length: returns the length of the given String
    public static int length(String s) {
        return s.length();
    }
\end{code}

\begin{enumerate}

\item Write some code in \java{main} that tests each of these methods.
Make sure they work, and you understand what they do.

\item Write a method called \java{printString} that takes a String as a parameter and that prints the letters of the String, one on each line.  It should be a \java{void} method.

\item Write a method called \java{printBackward} that does the same thing as \java{printString} but that prints the String backward (again, one character per line).

\item Write a method called \java{reverseString} that takes a String as a parameter and that returns a new String as a return value.
The new String should contain the same letters as the parameter, but in reverse order.

\begin{code}
    String backwards = reverseString("coffee");
    System.out.println(backwards);
\end{code}

For example, the output of the above code should be:

\begin{stdout}
eeffoc
\end{stdout}

\end{enumerate}

\end{exercise}


\begin{exercise}

What is the output of this program?
Describe in a sentence what \java{mystery} does (not how it works).

\begin{code}
public class Mystery {

    public static String mystery(String s) {
        String total = "";
        int i = s.length() - 1;

        while (i >= 0) {
            char ch = s.charAt(i);
            System.out.println(i + "     " + ch);

            total = total + ch;
            i--;
        }
        return total;
    }

    public static void main(String[] args) {
        System.out.println(mystery("Think Java"));
    }

}
\end{code}

\end{exercise}


\begin{exercise}

A friend shows you the following method and claims that if \java{number} is any two-digit number, the program will output the number backwards.
For example if \java{number} is 17, the code should output {\tt 71}.

\begin{code}
    Scanner in = new Scanner(System.in);
    int number = in.nextInt();

    int lastDigit = number % 10;
    int firstDigit = number / 10;

    System.out.println(lastDigit + firstDigit);
\end{code}

Explain what the program actually does, and modify it so that it does the right thing.
You can assume the input will be a two-digit positive integer.

\end{exercise}


\begin{exercise}
\label{palindrome}

A palindrome is a word that reads the same both forward and backward, like ``otto'' and ``palindromeemordnilap.''

\begin{enumerate}

\item Create a new program named {\tt Palindrome.java}.

\item Write a method named \java{first} that takes a string and returns the first letter.
Write another method named \java{last} that returns the last letter.

\item Write a method named \java{middle} that takes a string and returns a substring that contains everything {\em except} the
first and last characters.

%Hint: read the documentation of the \java{substring} method in the \java{String} class.
% Run a few tests to make sure you understand how \java{substring} works before you try to write \java{middle}.

Hint: Think about what happens if you invoke \java{middle} on strings that have only two letters, one letter, and no letters.

\item Here's one way to test whether a string is a palindrome:
``A single letter is a palindrome, and a two-letter word is a palindrome if the letters are the same, and any other word is a palindrome if the first letter is the same as the last and the middle is a palindrome.''

Write a recursive method named \java{isPalindrome} that takes a \java{String} and returns a \java{boolean} indicating whether the word is a palindrome or not.

\item Once you have a working palindrome checker, look for ways to simplify it by reducing the number of conditions you check.

Hint: It might be useful to adopt the definition that the empty string is a palindrome.

\item On a piece of paper, figure out a strategy for checking palindromes iteratively (i.e., using loops).
There are several possible approaches, so make sure you have a solid plan before you start writing code.

\item Implement your strategy in a method called \java{isPalindromeIter}.
Make sure it returns the same results as your recursive method.

%\item Optional: Appendix~\ref{javaio} provides code for reading a list
%of words from a file.  Read a list of words and print the palindromes.

\end{enumerate}

\end{exercise}


\begin{exercise}
\label{abecedarian}

A word is said to be ``abecedarian'' if the letters in the word appear in alphabetical order.
For example, the following are all 6-letter English abecedarian words.

\begin{quote}
abdest, acknow, acorsy, adempt, adipsy, agnosy, befist, behint,
beknow, bijoux, biopsy, cestuy, chintz, deflux, dehors, dehort,
deinos, diluvy, dimpsy
\end{quote}

\begin{enumerate}

\item Describe a process for checking whether a given word is abecedarian, assuming that the word contains only lower-case
letters.
Your process can be iterative or recursive.

\item Implement your process in a method called \java{isAbecedarian}.

\end{enumerate}

\end{exercise}


\begin{exercise}
\label{dupledrome}

A dupledrome is a word that contains only double letters, like ``llaammaa'' or ``ssaabb''.
There are most likely no dupledromes in common English use.

\begin{enumerate}

\item Write a method named \java{isDupledrome} that takes a \java{String} and returns a \java{boolean} indicating whether the word is a dupledrome.

\item Write a \java{main} program that reads words from \java{System.in} and checks them for dupledromity.
Continue reading input until the user enters the word \java{"Done"} (ignoring case).

\end{enumerate}

\end{exercise}


\begin{exercise}

A {\em shift cipher} works by taking each letter in a string and adding 13 to it.
For example, \java{'a'} becomes \java{'n'} and \java{'b'} becomes \java{'o'}.
The letters wrap around at the end, so \java{'z'} becomes \java{'m'}.

\begin{enumerate}

\item Write a method that takes a string and returns a new string containing the encoded version.
You should assume that the string contains upper and lower case letters and spaces, but no other characters.
Lower case letters should be transformed into other lowercase letters, and uppercase into uppercase.
You should not encode the spaces.

\item Generalize the method so that instead of adding 13 to each letter, it adds any given amount.
Now you should be able to encode things by adding 13 and decode them by adding -13.

\item Use your method to decrypt the string \java{"Jnl gb Tb"}.

\item Figure out how to decrypt \java{"Tjp adbpmzy do jpo"}.
It wasn't created by adding 13 to each letter.
Write a loop to try other possible values.

\end{enumerate}

\end{exercise}


\chapter{Classes and objects}
\label{objects}

\index{String}
\index{type!String}

As we learned in the previous chapter, \java{String}s are objects.
But they are atypical in Java because:

\begin{itemize}

\item You don't have to use the \java{new} operator to create a \java{String} object.
For convenience, Java allows you to define \java{String} literals.

\item They are immutable.
You cannot edit an existing \java{String} object directly; you can only create new ones.

\end{itemize}

In this chapter, we will learn about more classes from the Java library such as \java{Point} and \java{Rectangle}.
These classes are defined in the \java{java.awt} package, so you will need to \java{import} them before running the examples.
To be clear, these points and rectangles are not graphical objects that appear on the screen.
Like strings, they contain data and provide methods for manipulating that data.
But unlike strings, you can make changes to that data directly.


\section{Point objects}

A point is two numbers (coordinates) that we treat collectively as a single object.
In mathematical notation, points are often written in parentheses with a comma separating the coordinates.
For example, $(0,0)$ indicates the origin, and $(x,y)$ indicates the point $x$ units to the right and $y$ units up from the origin.

\index{Point}
\index{class!Point}
\index{new}
\index{statement!new}

In Java, a point is represented by a \java{java.awt.Point} object.
To create a new point, you have to use the \java{new} operator:

\begin{code}
    Point blank;
    blank = new Point(3, 4);
\end{code}

\index{declaration}
\index{statement!declaration}

The first line is a conventional variable declaration: \java{blank} has type \java{Point}.
The second line invokes \java{new}, specifies the type of the new object, and provides arguments.
The arguments are the coordinates of the new point: $(3, 4)$.

\index{reference}

The result of the \java{new} operator is a {\bf reference} to the new \java{Point}.
So \java{blank} contains a reference to the newly-created object.
Here is a standard way to diagram this assignment:

\begin{center}
\includegraphics{figs/reference.pdf}
\end{center}

\index{attribute}

As usual, the name of the variable \java{blank} appears outside the box and its value appears inside the box.
In this case, that value is a reference, which is shown graphically with an arrow.
The arrow points to the object we're referring to, which shows the newly-created object and the two values in it.
The variables \java{x} and \java{y} are the object's {\bf attributes}.

% CSM: We already introduced memory diagrams (Ch1) and stack diagrams (Ch4).
% State diagrams are the next aspect of this general diagraming convention.

\index{state}
\index{state diagram}

Taken together, all the variables, values, and objects in a program are called the {\bf state}.
Diagrams like this that show the state of the program's objects are called {\bf state diagrams}.
As the program runs, the state changes, so you should think of a state diagram as a snapshot of a particular point in the execution.


\section{The Point class}

When you define a class in Java, you are also defining a new data type.
It is helpful to think of classes as the blueprints (or a template) for objects.
To illustrate this point (pun intended), here is a simplified version of the source code for the \java{java.awt.Point} class:

\begin{code}
public class Point {

    public int x;
    public int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public String toString() {
        return "Point[x=" + x + ",y=" + y + "]";
    }

}
\end{code}

There are several details to note in this example.

\begin{itemize}

\item The class defines two variables (attributes) named \java{x} and \java{y} that are shared across all methods.
Because they are declared at the class level, their scope is the entire class.

\item The method \java{public Point(int x, int y)} is called a {\bf constructor}.
Its purpose is to initialize new objects, and it is called by the \java{new} operator.
Notice that it has no return type (not even \java{void}).

\item The parameters \java{x} and \java{y} in the constructor happen to have the same name as the attributes.
In order to distinguish one variable from the other, the keyword \java{this} refers to the current object.

%\item None of the variables or methods are \java{static}.
%In other words, they apply to each object of the class as opposed to the class itself.
%We will discuss this issue more deeply in the next chapter.

\end{itemize}

In practice, it's more convenient to look at high-level pictures than source code.
{\bf Unified Modeling Language} (UML) defines a standard way to visualize class designs.
Here is a {\bf class diagram} for the simplified \java{Point} class above:

\begin{center}
\vspace{1ex}
\includegraphics{figs/point.pdf}
\vspace{1ex}
\end{center}

The diagram is divided into two sections: the attributes (or variables) of the class, and the methods of the class.


\section{Instance variables}

\index{instance variable}
\index{variable!instance}

The attributes that make up an object are also called instance variables, because each object has its own copy of the variables.
Classes define new data types, and each object is an {\bf instance} of that type.

It's like the glove compartment of a car.
Each car is an instance of the type ``Car,'' and each car has its own glove compartment.
If you ask me to get something from the glove compartment of your car, you have to tell me which car is yours.

\index{dot notation}

Similarly if you want to read a value from an object, you have to specify the object you want to get it from.
Java uses dot notation for this purpose.

\begin{code}
    int x = blank.x;
\end{code}

The expression \java{blank.x} means ``go to the object \java{blank} refers to, and get the value of \java{x}.''
In this case, we assign that value to a local variable named \java{x}.
There is no conflict between the local variable named \java{x} and the instance variable named \java{x}.
The purpose of dot notation is to identify {\em which} variable you are referring to unambiguously.

You can use dot notation to build other Java expressions.
Here are several common examples:

\begin{code}
    System.out.println(blank.x + ", " + blank.y);
    int sum = blank.x * blank.x + blank.y * blank.y;
\end{code}

The first line prints {\tt 3, 4}; the second line calculates the value 25.


\section{Objects as parameters}

\index{parameter}
\index{object!as parameter}

You can pass objects as parameters in the usual way.
For example:

\begin{code}
    public static void printPoint(Point p) {
        System.out.println("(" + p.x + ", " + p.y + ")");
    }
\end{code}

This method takes a point as an argument and prints it in parentheses.
If you invoke \java{printPoint(blank)}, it prints \java{(3, 4)}.

It turns out that Java already has a way of printing \java{Point}s and other objects.
All you have to do is define a \java{toString} method, and \java{println} will call it.
For example, if you invoke \java{System.out.println(blank)} you get:

\begin{stdout}
java.awt.Point[x=3,y=4]
\end{stdout}

This format is what \java{java.awt} uses for printing objects.
It prints the name of the type, followed by the names and values of the instance variables.

As a second example, we can rewrite the \java{distance} method from Section~\ref{distance} so that it takes two \java{Point}s as parameters instead of four \java{double}s.

\begin{code}
    public static double distance(Point p1, Point p2) {
        double dx = (double) (p2.x - p1.x);
        double dy = (double) (p2.y - p1.y);
        return Math.sqrt(dx * dx + dy * dy);
    }
\end{code}

The typecasts are not really necessary; they are simply a reminder that the instance variables for \java{Point} are integers.


\section{Objects as return types}

\index{Rectangle}
\index{class!Rectangle}

\java{Rectangle}s are similar to points, except that they have four instance variables: \java{x}, \java{y}, \java{width}, and \java{height}.
This example creates a \java{Rectangle} object and makes the variable \java{box} refer to it.

\begin{code}
    Rectangle box = new Rectangle(0, 0, 100, 200);
\end{code}

This figure shows the effect of this assignment.

\begin{center}
\includegraphics{figs/rectangle.pdf}
\end{center}

If you print \java{box}, you get:

\begin{stdout}
java.awt.Rectangle[x=0,y=0,width=100,height=200]
\end{stdout}

Again, this output is the result of a \java{toString} method that knows how to display \java{Rectangle} objects.

\index{return}
\index{statement!return}

You can write methods that return objects.
For example, \java{findCenter} takes a \java{Rectangle} as an argument and returns a \java{Point} that contains the coordinates of the center of the \java{Rectangle}:

\begin{code}
    public static Point findCenter(Rectangle box) {
        int x = box.x + box.width / 2;
        int y = box.y + box.height / 2;
        return new Point(x, y);
    }
\end{code}

Notice that you can use \java{new} to create a new object, and then immediately use the result as the return value.


\section{Mutable objects}

\index{mutable}
\index{object!mutable}

You can change the contents of an object by making an assignment to one of its instance variables.
For example, to ``move'' a rectangle without changing its size, you can modify the \java{x} and \java{y} values:

\begin{code}
    box.x = box.x + 50;
    box.y = box.y + 100;
\end{code}

The result is shown in the figure:

\begin{center}
\includegraphics{figs/rectangle2.pdf}
\end{center}

\index{encapsulation}
\index{generalization}

We can encapsulate this code in a method and generalize it to move the rectangle by any amount:

\begin{code}
    public static void moveRect(Rectangle box, int dx, int dy) {
        box.x = box.x + dx;
        box.y = box.y + dy;
    }
\end{code}

The variables \java{dx} and \java{dy} indicate how far to move the rectangle in each direction.
Invoking this method has the effect of modifying the \java{Rectangle} that is passed as an argument.

\begin{code}
    Rectangle box = new Rectangle(0, 0, 100, 200);
    moveRect(box, 50, 100);
    System.out.println(box);
\end{code}

This code prints \java{java.awt.Rectangle[x=50,y=100,width=100,height=200]}.

Modifying objects by passing them as arguments to methods can be useful, but it can also make debugging more difficult because it is not always clear which method invocations do or do not modify their arguments.
%Later, I discuss some pros and cons of this programming style.

Java provides a number of methods that operate on \java{Point}s and \java{Rectangle}s.
Now would be a good time to examine the documentation for these classes.
%You can read the documentation at
%\url{http://docs.oracle.com/javase/7/docs/api/java/awt/Point.html}
%and
%\url{http://docs.oracle.com/javase/7/docs/api/java/awt/Rectangle.html}.
For example, \java{translate} has the same effect as \java{moveRect}, but instead of passing the Rectangle as an argument, you use dot notation:

\begin{code}
    box.translate(50, 100);
\end{code}

To foreshadow what's to come in future chapters, this example illustrates {\bf object-oriented programming}.
Rather than write \java{static} methods that manipulate external data (like \java{moveRect}), we make the methods non-static and bundle them with the objects themselves using dot notation.


\section{Aliasing}
\label{aliasing}

\index{reference}

Remember that when you assign an object to a variable, you are assigning a {\em reference} to an object.
It is possible to have multiple variables that refer to the same object.

\begin{code}
    Rectangle box1 = new Rectangle(0, 0, 100, 200);
    Rectangle box2 = box1;
\end{code}

This code generates a state diagram that looks like:

\begin{center}
\includegraphics{figs/aliasing.pdf}
\end{center}

\index{aliasing}

The \java{box1} and \java{box2} variables refer to the same object.
In other words, this object has two names, \java{box1} and \java{box2}.
When a person in real life uses two names, it's called {\bf aliasing}.
Same thing with objects.

When two variables are aliased, any changes that affect one variable also affect the other.
For example:

\begin{code}
    System.out.println(box2.width);
    box1.grow(50, 50);
    System.out.println(box2.width);
\end{code}

The first line prints {\tt 100}, which is the width of the \java{Rectangle} referred to by \java{box2}.
The second line invokes the \java{grow} method on \java{box1}, which expands the \java{Rectangle} by 50 pixels in every direction (see the documentation for more details).
The effect is shown in the figure:

\begin{center}
\includegraphics{figs/aliasing2.pdf}
\end{center}

Whatever changes are made to \java{box1} also apply to \java{box2}.
Thus, the value printed by the third line is {\tt 200}, the width of the expanded rectangle.
(As an aside, it is perfectly legal for the coordinates of a \java{Rectangle} to be negative.)

As you can tell even from this simple example, code that involves aliasing can get confusing fast and can be difficult to debug.
In general, aliasing should be avoided or used with care.


\section{The null keyword}

\index{null}

When you create an object variable, remember that you are storing a {\em reference} to an object.
%Until you make the variable point to an object, the value of the variable will be \java{null}.
In Java, the keyword \java{null} is a special value that means ``no object.''
You can declare and initialize object variables this way:

\begin{code}
    Point blank = null;
\end{code}

The value \java{null} is represented in state diagrams by a small box with no arrow.

\begin{center}
\includegraphics{figs/reference2.pdf}
\end{center}

\index{exception!NullPointer}
\index{run-time error}

If you try to use a \java{null} object, either by accessing an instance variable or invoking a method, Java throws a \java{NullPointerException}, prints an error message, and terminates the program.

\begin{code}
    Point blank = null;
    int x = blank.x;              // NullPointerException
    blank.translate(50, 50);      // NullPointerException
\end{code}

On the other hand, it is legal to pass a null object as an argument or receive one as a return value.
In fact, it is common to do so, for example to represent an empty set or indicate an error condition.


\section{Garbage collection}

In Section~\ref{aliasing} we talked about what happens when more than one variable refers to the same object.
What happens when {\em no} variable refers to an object?

\begin{code}
    Point blank = new Point(3, 4);
    blank = null;
\end{code}

The first line creates a new \java{Point} object and makes \java{blank} refer to it.
The second line changes \java{blank} so that instead of referring to the object, it refers to nothing (the null object).
In terms of the state diagram, we have removed the arrow between them.

\begin{center}
\includegraphics{figs/reference3.pdf}
\end{center}

\index{garbage collection}

If no one refers to an object, then no one can read or write any of its values, or invoke a method on it.
In effect, it ceases to exist.
We could keep the object in memory, but it would only waste space.
So periodically as your program runs, the system looks for stranded objects and reclaims them in a process called {\bf garbage collection}.
Later, the memory space occupied by the object will be available to be used as part of a new object.

You don't have to do anything to make garbage collection happen, and in general you will not be aware of it.
But you should know that it periodically runs in the background.


\section{Vocabulary}

\begin{description}

%\term{AWT}
%The Abstract Window Toolkit, one of the biggest and commonly-used Java packages.

\term{reference}
A value that indicates an object.
In a state diagram, a reference appears as an arrow.

\term{attribute}
One of the named data items (instance variables) that make up an object.
Each object (instance) has its own copy of the attributes for its class.

\term{state}
A complete description of all the variables and objects and their values, at a given point during the execution of a program.

\term{state diagram}
A snapshot of the state of a program, shown graphically.

\term{constructor}
A special method called by \java{new} to initialize an object.

\term{UML}
Unified Modeling Language, a standard way to draw diagrams for software engineering.

\term{class diagram}
An illustration of attributes and methods for a class.

\term{instance}
An example from a category.
My cat is an instance of the category ``feline things.''
Every object is an instance of some class.

\term{object-oriented programming}
A programming technique that focuses on objects rather than independent methods.

\term{aliasing}
The condition when two or more variables refer to the same object.

\term{garbage collection}
The process of finding objects that have no references and reclaiming their storage space.

\end{description}


\section{Exercises}


\begin{exercise}
For the following program:

\begin{enumerate}

\item Draw a stack diagram showing the local variables and parameters of \java{main} and \java{riddle}, and show any objects those variables refer to.

\item What is the output of this program?

\end{enumerate}

\begin{code}
    public static void main(String[] args) {
        int x = 5;
        Point blank = new Point(1, 2);

        System.out.println(riddle(x, blank));
        System.out.println(x);
        System.out.println(blank.x);
        System.out.println(blank.y);
    }

    public static int riddle(int x, Point p) {
        x = x + 7;
        return x + p.x + p.y;
    }
\end{code}

The point of this exercise is to make sure you understand the mechanism for passing objects as parameters.
\end{exercise}

\newpage

\begin{exercise}
For the following program:

\begin{enumerate}

\item Draw a stack diagram showing the state of the program just before \java{distance} returns.
Include all variables and parameters and the objects those variables refer to.

\item What is the output of this program?

\end{enumerate}

\begin{code}
    public static double distance(Point p1, Point p2) {
        int dx = p1.x - p2.x;
        int dy = p1.y - p2.y;
        return Math.sqrt(dx * dx + dy * dy);
    }

    public static Point findCenter(Rectangle box) {
        int x = box.x + box.width / 2;
        int y = box.y + box.height / 2;
        return new Point(x, y);
    }

    public static void main(String[] args) {
        Point blank = new Point(5, 8);

        Rectangle rect = new Rectangle(0, 2, 4, 4);
        Point center = findCenter(rect);

        double dist = distance(center, blank);
        System.out.println(dist);
    }
\end{code}

\end{exercise}


\begin{exercise}
The method \java{grow} is part of the \java{Rectangle} class.

\begin{enumerate}

\item What is the output of the following program?

\item Draw a state diagram that shows the state of the program just before the end of \java{main}.
Include all local variables and the objects they refer to.

\item At the end of \java{main}, are \java{p1} and \java{p2} aliased?
Why or why not?

\end{enumerate}

\begin{code}
    public static void printPoint(Point p) {
        System.out.println("(" + p.x + ", " + p.y + ")");
    }

    public static Point findCenter(Rectangle box) {
        int x = box.x + box.width / 2;
        int y = box.y + box.height / 2;
        return new Point(x, y);
    }

    public static void main(String[] args) {
        Rectangle box1 = new Rectangle(2, 4, 7, 9);
        Point p1 = findCenter(box1);
        printPoint(p1);

        box1.grow(1, 1);
        Point p2 = findCenter(box1);
        printPoint(p2);
    }
\end{code}

\end{exercise}


\begin{exercise}
\label{ex.biginteger}

You might be sick of the factorial method by now, but we're going to do one more version.

\begin{enumerate}

\item Create a new program called \java{Big.java} and write an iterative version of \java{factorial}.

\item Print a table of the integers from 0 to 30 along with their factorials.
At some point around 15, you will probably see that the answers are not right any more.
Why not?

\item \java{BigInteger} is a Java class that can represent arbitrarily big integers.
There is no upper bound except the limitations of memory size and processing speed.
Read the documentation at \url{http://docs.oracle.com/javase/7/docs/api/java/math/BigInteger.html}.

\item To use BigIntegers, you have to add \java{import java.math.BigInteger} to the beginning of your program.

\item There are several ways to create a BigInteger, but the one I recommend uses \java{valueOf}.
The following code converts an integer to a \java{BigInteger}:

\begin{code}
    int x = 17;
    BigInteger big = BigInteger.valueOf(x);
\end{code}

Type in this code and try it out.
Try printing a BigInteger.

\item Because BigIntegers are not primitive types, the usual math operators don't work.
Instead we have to use methods like \java{add}.
To add two BigIntegers, invoke \java{add} on one and pass the other as an argument.
For example:

\begin{code}
    BigInteger small = BigInteger.valueOf(17);
    BigInteger big = BigInteger.valueOf(1700000000);
    BigInteger total = small.add(big);
\end{code}

Try out some of the other methods, like \java{multiply} and \java{pow}.

\item Convert \java{factorial} so that it performs its calculation using BigIntegers and returns a BigInteger as a result.
You can leave the parameter alone---it will still be an integer.

\item Try printing the table again with your modified factorial method.
Is it correct up to 30?
How high can you make it go?
I calculated the factorial of all the numbers from 0 to 999, but my machine is pretty slow, so it took a while.
The last number, 999!, has 2565 digits.

\end{enumerate}
\end{exercise}


\begin{exercise}
Many encryption techniques depend on the ability to raise large integers to an integer power.
Here is a method that implements a (reasonably) fast technique for integer exponentiation:

\begin{code}
    public static int pow(int x, int n) {
        if (n == 0) return 1;

        // find x to the n/2 recursively
        int t = pow(x, n / 2);

        // if n is even, the result is t squared
        // if n is odd, the result is t squared times x
        if (n % 2 == 0) {
            return t*t;
        } else {
            return t*t*x;
        }
    }
\end{code}

The problem with this method is that it only works if the result is smaller than 2 billion.
Rewrite it so that the result is a \java{BigInteger}.
The parameters should still be integers, though.

You can use the BigInteger methods \java{add} and \java{multiply}, but don't use \java{pow}, which would spoil the fun.
\end{exercise}


\chapter{User-defined types}

\index{object type}
\index{type!object}

Way back in Section~\ref{sec:hello} when we defined the class \java{Hello}, we created a data type named \java{Hello}.
We didn't declare any variables with type \java{Hello}, and we didn't use \java{new} to create any \java{Hello} objects---but we could have!
There was no reason to create a \java{Hello} object, and it wouldn't have done much if we did.

\index{class definition}

In this chapter, we will look at defining class that create {\em useful} object types.
Here are the most important ideas:

\begin{itemize}

\item Defining a new class also creates a new object type with the same name.

\index{instance}

\item Every object belongs to some object type; that is, it is an {\bf instance} of some class.

\item A class definition is like a template for objects: it determines what attributes the objects have and what methods can operate on them.

\item The methods that operate on a type are defined in the class definition for that type.

\index{constructor}

\item When you use \java{new} to create an object, Java invokes a special method called a {\bf constructor} to initialize the instance variables.
You may provide one or more constructors as part of the class definition.

\item If you don't provide a constructor for a class, then Java will generate one for you.
The default constructor takes no arguments and initializes all attributes to zero (or an equivalent value like \java{false} or \java{null}).

\end{itemize}


\section{Time class}

\index{class!Time}
\index{Time}

Let's take a look at an example of a user-defined class.
A common motivation for designing a new class is to encapsulate related data in an object that can be treated as a single unit.
That way, we can use objects as parameters and return values, rather than passing and returning multiple things.
We have already seen two such types, \java{Point} and \java{Rectangle}.

\index{instance variable}
\index{variable!instance}

Another example, which we will implement ourselves, is \java{Time}, which represents the time of day.
The data encapsulated in a \java{Time} object are an hour, a minute, and a number of seconds.
Because every \java{Time} object contains these data, we need {\bf instance variables} to hold them.

The first step is to decide what type each variable should be.
It seems clear that \java{hour} and \java{minute} should be integers.
Just to keep things interesting, let's make \java{second} a \java{double}.
Instance variables are declared at the beginning of the class definition, outside of any method definition:

\begin{code}
public class Time {
    private int hour;
    private int minute;
    private double second;
}
\end{code}

By itself, this code fragment is a legal class definition.
The state diagram for a \java{Time} object looks like this:

\begin{center}
\includegraphics{figs/time.pdf}
\end{center}

%\subsection{Public vs private}

The keyword \java{public} means that a variable (or method or class) can be accessed from other classes.
The alternative is \java{private}, which means it can only be accessed inside the class where it is defined.
To prevent yourself and others from making mistakes, it's good practice to make instance variables \java{private}.

\index{data encapsulation}

If you attempt to read or write a \java{private} variable from another class, you will get a compiler error.
Private methods and instance variables are language features that help programmers ensure {\bf data encapsulation}, which means that objects in one class are isolated from other classes.
%Limiting interactions between classes is a standard technique for managing complexity.

%We can create {\bf accessor methods} like \java{getHour}, \java{getMinute}, and \java{getSecond}.
%, but it provides no methods that modify the instance variables.
%In effect, \java{Location} objects are immutable, which means that they can be shared without worrying about unexpected behavior due to aliasing.

%Making methods private helps keep the API simple.
%Classes often include helper methods that are used to implement other methods, but making those methods part of the public API might be unnecessary and error-prone.


\section{Constructors}

\index{constructor}
\index{method!constructor}
\index{static}

After declaring the instance variables, the next step is to define a constructor for the new class.
Constructors initialize the instance variables.
The syntax for constructors is similar to that of other methods, with a few exceptions:

\begin{itemize}
\item The name of the constructor is the same as the name of the class.
\item Constructors have no return type (and no return value).
\item The keyword \java{static} is omitted.
\end{itemize}

Here is an example for the \java{Time} class:

\begin{code}
    public Time() {
        this.hour = 0;
        this.minute = 0;
        this.second = 0.0;
    }
\end{code}

Where you would expect to see a return type, between \java{public} and \java{Time}, there is nothing.
That's how we (and the compiler) can tell it's a constructor as opposed to a \java{void} method.
This constructor does not take any arguments.
Each line of the constructor initializes an instance variable to zero (which in this example means midnight).

\index{this}

The variable \java{this} is a special keyword that refers to the object that we are creating.
You can use \java{this} the same way you use the name of any other object.
For example, you can read and write the instance variables of \java{this}, and you can pass \java{this} as an argument to other methods.
But you do not declare \java{this}, and you can't make an assignment to it.

A common error when writing constructors is to put a \java{return} statement at the end.
Like \java{void} methods, constructors do not return values.
Another mistake that beginning programmers make is to invoke the \java{new} operation inside the constructor.
For example, writing the code \java{new Time(0, 0, 0.0)} in the constructor results in infinite recursion.

%\subsection{More constructors}

\index{overloading}

Constructors can be overloaded, just like other methods, which means that you can provide multiple constructors with different parameters.
Java knows which constructor to invoke by matching the arguments after \java{new} with the parameters of the constructors.

For example, it is common to have one constructor that takes no arguments (the ``default constructor'') and another one that takes a parameter list identical to the list of instance variables (the ``explicit value constructor'').

\begin{code}
    public Time(int hour, int minute, double second) {
        this.hour = hour;
        this.minute = minute;
        this.second = second;
    }
\end{code}

Notice how the names and types of the parameters are the same as the names and types of the instance variables.
All the constructor does is copy the information from the parameters into the instance variables.

If you look at the documentation for \java{Point} and \java{Rectangle}, you will see that both classes provide similar constructors.
Overloading constructors provides the flexibility to create an object first and then fill in the blanks, or to collect all the information before creating the object.

This detail might not seem very interesting, and in fact it is not.
Writing constructors is a boring, mechanical process, and some IDEs will automatically generate them for you.
You will find that you can write them quickly just by looking at the list of instance variables.


\section{Creating a new object}

\index{new}
\index{statement!new}

Although constructors look like methods, you never invoke them directly.
When you apply the \java{new} operator, the system allocates space for the object and then invokes the constructor for you.

The following program (in the \java{main} method) demonstrates two common ways to create and initialize \java{Time} objects:

\begin{code}
public class Time {
    private int hour;
    private int minute;
    private double second;

    public Time() {
        this.hour = 0;
        this.minute = 0;
        this.second = 0.0;
    }

    public Time(int hour, int minute, double second) {
        this.hour = hour;
        this.minute = minute;
        this.second = second;
    }

    public static void main(String[] args) {
        // one way to create a time object
        Time t1 = new Time();
        t1.hour = 11;
        t1.minute = 8;
        t1.second = 3.14159;
        System.out.println(t1);

        // another way to do the same thing
        Time t2 = new Time(11, 8, 3.14159);
        System.out.println(t2);
    }
}
\end{code}

The first time we apply \java{new} we provide no arguments, so Java invokes the default constructor.
The next few lines assign values to the instance variables.
The second time we invoke \java{new}, we provide arguments that match the parameters of the second constructor.
This way of initializing the instance variables is more concise and slightly more efficient.

%\section{Printing objects}
\label{printobject}

\index{print}
\index{statement!print}
\index{object!printing}

The output of this program is something like:

\begin{stdout}
Time@80cc7c0
Time@80cc807
\end{stdout}

When Java prints the value of a user-defined object type, it prints the name of the type and a hexadecimal (base 16) code that is unique for each object.
As we saw in Section~\ref{sec:system}, this code is the address of the object in memory, and it usually varies from machine to machine.
It is useful for debugging, in case you want to keep track of individual objects.

To print \java{Time} objects in a way that is more meaningful to users (as opposed to programmers), you could write a method to print the hour, minute, and second.
Using \java{printTime} in Section~\ref{time} as a starting point, we could write:

\begin{code}
    public static void printTime(Time t) {
        System.out.print(t.hour);
        System.out.print(":");
        System.out.println(t.minute);
        System.out.print(":");
        System.out.println(t.second);
    }
\end{code}

The output of this method, if we pass either \java{t1} or \java{t2} as an argument, is {\tt 11:8:3.14159}.
Although it's recognizable as a time, it's not quite in the standard format.
For example, if the number of minutes or seconds is less than 10, we expect a leading {\tt 0}.
Also, we might want to drop the decimal part of the seconds.
In other words, we want something like {\tt 11:08:03}.

Fortunately, we can use \java{printf} to format the output:

\begin{code}
    public static void printTime(Time t) {
        System.out.printf("%02d:%02d:%02.0f\n",
            t.hour, t.minute, t.second);
    }
\end{code}

As a reminder, you need to use \java{\%d} with integers and \java{\%f} with floating-point numbers.
The \java{02} option means ``two digits with leading zeros,'' and the \java{.0} option means ``zero decimal places.''
Note that \java{\%f} automatically rounds the floating-point value.


\section{The toString method}

\index{toString}
\index{method!toString}

Every object type has a method called \java{toString} that returns a string representation of the object.
When you print an object using \java{print} or \java{println}, Java invokes the object's \java{toString} method.

\index{override}

The default version of \java{toString} returns a string that contains the type of the object and its current address (see Section~\ref{printobject}).
When you define a new object type, you can {\bf override} the default behavior by providing a new method with the behavior you want.

For example, here is a \java{toString} method for \java{Time}:

\begin{code}
public String toString() {
    return String.format("%02d:%02d:%02.0f\n",
            t.hour, t.minute, t.second);
}
\end{code}

This code is essentially the same as printTime in the previous section, except that we are returning a string instead of printing it to the screen.
The \java{String.format} method works the same way as \java{printf}; in fact, the \java{printf} method invokes \java{String.format}.

You can call \java{toString} in the usual way:

\begin{code}
    Time time = new Time(11, 8, 3.14159);
    String s = time.toString();
\end{code}

Or you can invoke it indirectly through \java{println}:

\begin{code}
    System.out.println(time);
\end{code}


\section{The equals method}

\index{equals}
\index{method!equals}

When comparing objects, there are two notions of equality: objects that are {\em identical}, and objects that are {\em equivalent}.
Identical means that two variables refer to the same object.
Equivalent means that two objects have the same values.
Consider for example the following three \java{Time} variables:

\begin{code}
    Time time1 = new Time(9, 30, 0.0);
    Time time2 = time1;
    Time time3 = new Time(9, 30, 0.0);
\end{code}

Since \java{Time} is a reference type, \java{time1}, \java{time2}, and \java{time3} are references to objects.
Here is a memory diagram:

\begin{center}
\includegraphics{figs/time2.pdf}
\end{center}

Recall that the assignment operator simply copies a reference, so \java{time1} and \java{time2} refer to the same object.
In contrast, \java{time3} points to a different object.
Whenever you apply the \java{new} operator, you create a new object in memory.

In this example, \java{time1} and \java{time2} are identical: they refer to the same object.
The \java{==} operator compares references, so \java{time1 == time2} is \java{true}.
All three variables are equivalent, since the objects they reference have the same values.
However \java{time1 == time3} is \java{false}, because their references are not the same.

There is no operator that tests equivalence, since the notion of equality is different for each type of object.
In the case of \java{Time}, we could write a method that compares hours, minutes, and seconds:

\begin{code}
    public static boolean sameTime(Time t1, Time t2) {
        return t1.hour == t2.hour
            && t1.minute == t2.minute
            && t1.second == t2.second;
    }
\end{code}

\index{instance method}

This method works just fine, but it's not the way most Java classes are designed.
Instead, objects may provide a non-\java{static} named \java{equals} that defines equality.
All we have to do is rewrite \java{sameTime} as an {\bf instance method}:

\begin{code}
    public boolean equals(Time t2) {
        return this.hour == t2.hour
            && this.minute == t2.minute
            && this.second == t2.second;
    }
\end{code}

By way of comparison, here is how each of the methods are invoked:

\begin{code}
    System.out.println(Time.sameTime(time1, time3));
    System.out.println(time1.equals(time3));
\end{code}

The latter method is certainly easier to read and understand.
Inside the \java{equals} method, the reference to \java{time1} is the current object \java{this}, and \java{time3} is the parameter \java{t2}.

Like the \java{toString} method, Java provides a default implementation of the \java{equals} method.
If you don't define your own, then \java{equals} behaves the same way as the \java{==} operator, which is often incorrect.
Unlike the \java{toString} method, \java{equals} requires a parameter: the other object you need to compare.
So in order to override the default \java{equals} method, you need to write it this way:

\begin{code}
    public boolean equals(Object obj) {
        if (!(obj instanceof Time)) {
            return false;
        }
        Time t2 = (Time) obj;
        return this.hour == t2.hour
            && this.minute == t2.minute
            && this.second == t2.second;
    }
\end{code}

Because the parameter is declared as an \java{Object}, one could in theory pass any type of data (like a \java{String} or \java{Scanner}) to this method.
The \java{instanceof} operator tests whether \java{obj} references an actual \java{Time} object.
If it passes the test, we can safely cast \java{obj} to a \java{Time} reference and perform the equality test as before.

Of course, the \java{equals} method may be arbitrarily complex.
You could design it, for example, to allow \java{Time} and \java{String} objects to be equal if they represent the same time.
However that design would likely confuse other programmers, since normally objects are only considered equal if they are of the same type.


\section{The compareTo method}

%\index{pure function}
%\index{method!pure function}
%, and it has no side effects like modifying an argument or printing something.
%The only result of invoking a pure function is the return value.

In contrast to instance methods, \java{static} methods do not refer to a specific object.
The result of a \java{static} method depends only on the arguments.
For example, \java{isAfter} compares two \java{Time}s and returns a \java{boolean} that indicates whether the first operand comes after the second:

\begin{code}
    public static boolean isAfter(Time time1, Time time2) {
        if (time1.hour < time2.hour) return false;
        if (time1.hour > time2.hour) return true;

        if (time1.minute < time2.minute) return false;
        if (time1.minute > time2.minute) return true;

        if (time1.second < time2.second) return false;
        return true;
    }
\end{code}

What is the result of this method if the two times are equal?
Does that seem like the appropriate result for this method?
If you were writing the documentation for this method, would you mention that case specifically?

A better solution would be to define a \java{compareTo} method.
We have already seen how to compare two strings in this way: \java{time1.compareTo(time2)}.

\begin{code}
    public int compareTo(Time t2) {
        if (this.hour < t2.hour) return -1;
        if (this.hour > t2.hour) return +1;

        if (this.minute < t2.minute) return -1;
        if (this.minute > t2.minute) return +1;

        if (this.second < t2.second) return -1;
        if (this.second > t2.second) return +1;

        return 0;
    }
\end{code}

If \java{this} time comes before the other time, then compareTo returns \java{-1}.
It returns \java{+1} when \java{this} time comes after the other time.
If both times are the same (in the \java{equals} sense), \java{compareTo} returns \java{0}.


\section{Adding times}

Throughout the chapter, we have demonstrated how \java{static} methods can and should be implemented as instance methods.
As a further example, \java{addTime} calculates the sum of two times.
Here is a rough draft of a method that is not quite right.

\begin{code}
    public static Time addTime(Time t1, Time t2) {
        Time sum = new Time();
        sum.hour = t1.hour + t2.hour;
        sum.minute = t1.minute + t2.minute;
        sum.second = t1.second + t2.second;
        return sum;
    }
\end{code}

%Note that although this method returns a \java{Time} object, it is not a constructor.
%You should go back and compare the syntax of a method like this with the syntax of a constructor, because it is easy to get confused.

%Here is an example of how to use this method.
If it is {\tt 9:14:30}, and your bread maker takes 3 hours and 35 minutes, you could use \java{addTime} to figure out when the bread will be done.
%Since \java{currentTime} contains the current time and \java{breadTime} contains the amount of time it takes for your bread maker to make bread, we can use \java{addTime} to figure out when the bread will be done.

\begin{code}
    Time currentTime = new Time(9, 14, 30.0);
    Time breadTime = new Time(3, 35, 0.0);
    Time doneTime = addTime(currentTime, breadTime);
\end{code}

We can rewrite \java{addTime} as an instance method by deleting the word \java{static} and removing the first parameter.

\begin{code}
    public Time addTime(Time t2) {
        Time sum = new Time();
        sum.hour = this.hour + t2.hour;
        sum.minute = this.minute + t2.minute;
        sum.second = this.second + t2.second;
        return sum;
    }
\end{code}

When calling this version of \java{addTime}, we still need to specify the \java{currentTime} object.
Because of the dot operator, it becomes \java{this} in the method.

\begin{code}
    Time doneTime = currentTime.addTime(breadTime);
\end{code}

The result of this method is {\tt 12:49:30.0}, which is correct.
On the other hand, there are cases where the result is not correct.
The problem is that this method does not deal with cases where the number of seconds or minutes adds up to more than 60.
In that case, we have to ``carry'' the extra seconds into the minutes column, or extra minutes into the hours column.

\begin{code}
    public Time addTime(Time t2) {
        Time sum = new Time();
        sum.hour = this.hour + t2.hour;
        sum.minute = this.minute + t2.minute;
        sum.second = this.second + t2.second;

        if (sum.second >= 60.0) {
            sum.second -= 60.0;
            sum.minute += 1;
        }
        if (sum.minute >= 60) {
            sum.minute -= 60;
            sum.hour += 1;
        }
        return sum;
    }
\end{code}

\index{increment}
\index{decrement}
\index{operator!increment}
\index{operator!decrement}

This code demonstrates two operators we have not seen before, \java{+=} and \java{-=}.
These operators provide a concise way to increment and decrement variables.
They are similar to \java{++} and \java{--}, except (1) they work on \java{double}s as well as \java{int}s, and (2) the amount of the increment does not have to be 1.
The statement \java{sum.second -= 60.0;} is equivalent to \java{sum.second = sum.second - 60;}


\section{Accessors and mutators}

\index{immutable}

Notice how the \java{addTime} method does not change \java{this} object.
Instead, it creates a \java{new} object to store the results.
All of the \java{String} methods work the same way.
Up to this point, we have designed \java{Time} to be immutable.

\index{accessor}
\index{method!accessor}

Because \java{hour}, \java{minute}, and \java{second} are \java{private}, there is no way for outside classes to access them directly.
The only method we have provided for other to look at the time is \java{toString}.
As a convenience, we can also write \java{public} {\bf accessor} methods that return a copy of the \java{private} values.

\begin{code}
    public int getHour() {
        return hour;
    }

    public int getMinute() {
        return minute;
    }

    public int getSecond() {
        return second;
    }
\end{code}

\index{mutator}
\index{method!mutator}

If we want the class to be immutable, we would stop here and have a complete implementation.
But if we want other programmers (including ourselves) to be able to change the time from other classes, we should also provide the corresponding {\bf mutator} methods.

\begin{code}
    public void setHour(int hour) {
        this.hour = hour;
    }

    public void setMinute(int minute) {
        this.minute = minute;
    }

    public void setSecond(int second) {
        this.second = second;
    }
\end{code}

Accessors and mutators are the formal terms for referring to these types of methods, but many programmers simply call them getters and setters.
These methods are intentionally simple, and many IDEs will generate them for you automatically with a press of a button.
The absence or presence of these methods allows the class designer to control how the object's data is used from the outside.

Mutator methods are often one line of code, but they don't have to be.
As another example of a mutator, consider \java{increment}, which adds a given number of seconds to a \java{Time} object.
Again, a rough draft of this method looks like:

\begin{code}
    public void increment(double secs) {
        this.second += secs;
        if (this.second >= 60.0) {
            this.second -= 60.0;
            this.minute += 1;
        }
        if (this.minute >= 60) {
            this.minute -= 60;
            this.hour += 1;
        }
    }
\end{code}

The first line performs the basic operation; the remainder deals with the same cases we saw before.

What happens if the argument \java{secs} is much greater than 60?
In that case, it may not be enough to subtract 60 once; we have to keep doing it until \java{second} is below 60.
We can do that by replacing the \java{if} statements with \java{while} statements:

\begin{code}
    public void increment(double secs) {
        this.second += secs;
        while (this.second >= 60.0) {
            this.second -= 60.0;
            this.minute += 1;
        }
        while (this.minute >= 60) {
            this.minute -= 60;
            this.hour += 1;
        }
    }
\end{code}

This solution is correct, but it's not very efficient.
Can you think of a solution that does not require iteration?


\section{Vocabulary}

\begin{description}

\term{class}
Previously, we defined a class as a collection of related methods.
Now you know that a class is also a template for a new type of object.

\term{instance}
A member of a class.
Every object is an instance of some class.

\term{constructor}
A special method that initializes the instance variables of a newly-constructed object.

\term{instance variables}
The attributes of an object; non-\java{static} variables defined at the class level.

\term{data encapsulation}
A technique for bundling multiple named variables into a single object.

\term{override}
Replacing a default implementation of a method, such as \java{equals} or \java{toString}.

\term{instance methods}
Non-\java{static} methods that have access to \java{this} and the instance variables.

\term{accessor}
A method that returns a copy of a \java{private} variable.

\term{mutator}
A method that changes one or more of the objects it receives as parameters.
It is usually \java{void} and modifies \java{this}.

\end{description}


\section{Exercises}


\begin{exercise}
In the board game Scrabble\footnote{Scrabble is a registered trademark owned in the U.S.A and Canada by Hasbro Inc., and in the rest of the world by J.W. Spear \& Sons Limited of Maidenhead, Berkshire, England, a subsidiary of Mattel Inc.}, each tile contains a letter, which is used to spell words in rows and columns, and a score, which is used to determine the value of words.

\begin{enumerate}

\item Write a definition for a class named \java{Tile} that represents Scrabble tiles.
The instance variables should be a character named \java{letter} and an integer named \java{value}.

\item Write a constructor that takes parameters named \java{letter} and \java{value} and initializes the instance variables.

\item Write a method named \java{printTile} that takes a \java{Tile} object as a parameter and prints the instance variables in a reader-friendly format.

\item Write a method named \java{testTile} that creates a Tile object with the letter \java{Z} and the value 10, and then uses \java{printTile} to print the state of the object.

\item Implement the \java{toString} and \java{equals} methods for a \java{Tile}.

\item Create accessors and mutators for each of the attributes.

\end{enumerate}

The point of this exercise is to practice the mechanical part of creating a new class definition and code that tests it.
\end{exercise}


\begin{exercise}
Write a class definition for \java{Date}, an object type that contains three integers: \java{year}, \java{month}, and \java{day}.
This class should provide two constructors.
The first should take no parameters and initialize a default date.
The second should take parameters named \java{year}, \java{month} and \java{day} and use them to initialize the instance variables.

Write a \java{main} method that creates a new \java{Date} object named \java{birthday}.
The new object should contain your birth date.
You can use either constructor.
Compare your implementation to \java{java.util.Date}.
\end{exercise}


\begin{exercise}
\label{ex.rational}

A rational number is a number that can be represented as the ratio of two integers.
For example, $2/3$ is a rational number, and you can think of 7 as a rational number with an implicit 1 in the denominator.
For this assignment, you are going to write a class definition for rational numbers.

\begin{enumerate}

\item Create a new program called \java{Rational.java} that defines a class named \java{Rational}.
A \java{Rational} object should have two integer instance variables to store the numerator and denominator.

\item Write a constructor that takes no arguments and that sets the numerator to 0 and denominator to 1.

\item Write a method called \java{printRational} that takes a Rational object as an argument and prints it in some reasonable format.

\item Write a \java{main} method that creates a new object with type Rational, sets its instance variables to some values, and prints the object.

\item At this stage, you have a minimal testable program.
Test it and, if necessary, debug it.

\item Write a second constructor for your class that takes two arguments and that uses them to initialize the instance variables.

\item Write a method called \java{negate} that reverses the sign of a rational number.
This method should be a modifier, so it should be \java{void}.
Add lines to \java{main} to test the new method.

\item Write a method called \java{invert} that inverts the number by swapping the numerator and denominator.
Add lines to \java{main} to test the new method.

\item Write a method called \java{toDouble} that converts the rational number to a double (floating-point number) and returns the result.
This method is a pure function; it does not modify the object.
As always, test the new method.

\item Write a modifier named \java{reduce} that reduces a rational number to its lowest terms by finding the greatest common divisor (GCD) of the numerator and denominator and dividing through.
This method should be a pure function; it should not modify the instance variables of the object on which it is invoked.
To find the GCD, see Exercise~\ref{gcd}).

\item Write a method called \java{add} that takes two Rational numbers as arguments and returns a new Rational object.
The return object should contain the sum of the arguments.

\item There are several ways to add fractions.
You can use any one you want, but you should make sure that the result of the operation is reduced so that the numerator and denominator have no common divisor (other than 1).
\end{enumerate}

The purpose of this exercise is to write a class definition that includes a variety of methods, including constructors, accessors, mutators, \java{static} methods, and instance methods.
\end{exercise}


\chapter{Arrays of integers}
\label{arrays}

\index{array}
\index{type!array}

An {\bf array} is a set of values where each value is identified by an index.
You can make an array of \java{int}s, \java{double}s, or any other type, but all the values in an array must have the same type.

Syntactically, array types look like other Java types except they are followed by square brackets \java{[]}.
For example, \java{int[]} is the type ``integer array'' and \java{double[]} is the type ``double array.''

You can declare variables with these types in the usual way:

\begin{code}
    int[] counts;
    double[] values;
\end{code}

Arrays are objects and must be created.
An array variable simply stores a reference to an array object.
To create the array itself, use the \java{new} operator.

\begin{code}
    counts = new int[4];
    values = new double[size];
\end{code}

The first assignment makes \java{count} refer to an array of 4 integers.
The second makes \java{values} refer to an array of \java{double}s, but the number of elements in \java{values} depends on the variable \java{size}.
You can use any integer expression for the size of an array.

\section{Accessing elements}

\index{memory diagram}

When you allocate an array of \java{int}s, the elements are automatically initialized to zero.
Here is a memory diagram of the \java{counts} array so far:

\begin{center}
\includegraphics{figs/array.pdf}
\end{center}

\index{element}
\index{index}
\index{array!element}
\index{array!index}

The large numbers inside the boxes are the {\bf elements} of the array.
The small numbers outside the boxes are the {\bf indexes} (or indices) used to identify each memory location.

To store values in the array, use the \java{[]} operator.
For example \java{counts[0]} refers to the ``zeroeth'' element of the array, and \java{counts[1]} refers to the ``oneth'' element.  You can use the \java{[]} operator anywhere in an expression:

\begin{code}
    counts[0] = 7;
    counts[1] = counts[0] * 2;
    counts[2]++;
    counts[3] -= 60;
\end{code}

These assignment statements are all legal in Java.
Here is the result of the above code fragment:

\begin{center}
\includegraphics{figs/array2.pdf}
\end{center}

\index{exception!ArrayOutOfBounds}
\index{run-time error}

The elements of the array are numbered from 0 to 3, which means that there is no element with the index 4.
This should sound familiar, since we saw the same thing with \java{String} indexes.
Nevertheless a common programming mistake is going beyond the bounds of an array, which throws an \java{ArrayIndexOutOfBoundsException}.

You can use any expression as an index, as long as it has type \java{int}.
One of the most common ways to index an array is with a loop variable.
For example:

\begin{code}
    int i = 0;
    while (i < 4) {
        System.out.println(counts[i]);
        i++;
    }
\end{code}

\index{loop}
\index{loop variable}
\index{variable!loop}

This is a standard \java{while} loop that counts from 0 up to 4.
When the loop variable \java{i} is 4, the condition fails and the loop terminates.
Thus, the body of the loop is only executed when \java{i} is 0, 1, 2 and 3.

Each time through the loop we use \java{i} as an {\it index} into the array, printing the \java{i}th element.
For convenience, this type of array traversal is commonly written using a \java{for} loop.

\begin{code}
    for (int i = 0; i < 4; i++) {
        System.out.println(counts[i]);
    }
\end{code}

%\section{Arrays vs objects}

\index{object!compared to array}
\index{array!compared to object}

Some of the objects we looked at, like \java{Rectangle}s, are similar to arrays in the sense that they are a set of values.
Because arrays are also objects, they have many of the same behaviors:

\begin{itemize}

\item When you declare an array variable, you get a reference to an array.

\item You have to use \java{new} to create the array itself.

\item When you pass an array as an argument, you pass a reference, which means that the invoked method can change the contents of the array.

\end{itemize}

You might ask, ``How is an array of 4 integers different from a Rectangle object of 4 integers?''
The main difference is that array elements are accessed by index, whereas object elements have names.
Another difference is that the elements of an array have to be the same type; objects can have instance variables with different types.


\section{Copying arrays}
\index{array!copying}

When you copy an array variable, remember that you are copying a reference to the array.
For example:

\begin{code}
    double[] a = new double[3];
    double[] b = a;
\end{code}

This code creates one array of three \java{double}s and sets two different variables to reference it.
As with objects, this situation is a form of aliasing.

\begin{center}
\includegraphics{figs/array3.pdf}
\end{center}

Any changes made through either array variable will be reflected in the other.
This behavior is usually not what you want; more often you want to allocate a \java{new} array and copy elements from one to the other.

\begin{code}
    double[] b = new double[3];
    for (int i = 0; i < 3; i++) {
        b[i] = a[i];
    }

\end{code}

\index{java.util.Arrays}

The Java library provides a utility class named \java{java.util.Arrays} with methods for copying arrays and other common array operations.
We can rewrite the above \java{for} loop with just one line of code.

\begin{code}
    double[] b = Arrays.copyOf(a, 3);
\end{code}

%\section{Array length}

\index{length!array}
\index{array!length}

All arrays have one named instance variable: \java{length}.
Not surprisingly, it contains the length of the array (number of elements).
It is a good idea to use this value as the upper bound of a loop, rather than a constant value.
That way, if you need to change the size of the array, you won't have to go through the program changing all the loops.

\begin{code}
    for (int i = 0; i < a.length; i++) {
        b[i] = a[i];
    }
\end{code}

The last time the body of the loop gets executed, \java{i} is \java{a.length - 1}, which is the index of the last element.
When \java{i} is equal to \java{a.length}, the condition fails and the body is not executed (which is a good thing, since it would throw an exception).

The above \java{for} loop assumes that the array \java{b} contains at least as many elements as \java{a}.
Of course, you could simply use the \java{Arrays} class and \java{a.length}:

\begin{code}
    b = Arrays.copyOf(a, a.length);
\end{code}


\section{Random numbers}
\label{random}
\label{pseudorandom}

\index{deterministic}

Most computer programs do the same thing every time they are executed, so they are said to be {\bf deterministic}.
Usually determinism is a good thing, since we expect the same calculation to yield the same result.
But for some applications we want the computer to be unpredictable.
Games are an obvious example, but there are many others.

\index{nondeterministic}

Making a program truly {\bf nondeterministic} turns out to be not so easy, but there are ways to make it at least seem nondeterministic.
One of them is to generate random numbers and use them to determine the outcome of the program.
Java provides a method that generates {\bf pseudorandom} numbers, which are not truly random since they are determined by an algorithm.
But for our purposes, they will do.

\index{random}

Check out the documentation of the \java{random} method in the \java{Math} class.
The return value is a \java{double} between 0.0 and 1.0.
To be precise, it is greater than or equal to 0.0 and strictly less than 1.0.
Each time you invoke \java{Math.random()} you get the next number in a pseudorandom sequence.
To see a sample, run this loop:

\begin{code}
    for (int i = 0; i < 10; i++) {
        double x = Math.random();
        System.out.println(x);
    }
\end{code}

Let's say we need to generate a number between 5 and 15 inclusive.
Notice how there are 11 possible results: 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, and 15.
We can use \java{Math.random()} to get a number in the range [0, 1).
If we multiply that number by 11, we now have a number in the range [0, 11).
Now we just have to add 5 to that number to shift the range to [5, 16).
Finally, we cast the value to an \java{int}, which throws away any decimal places.

We can encapsulate this technique in a method and generalize for any numbers \java{x} and \java{y}.

\begin{code}
    public static int randomInt(int x, int y) {
        int range = y - x + 1;
        return (int) (Math.random() * range + x);
    }
\end{code}

%A similar method is provided by \java{java.util.Random}, but for simplicity we will use our own version in this chapter.


\section{Array of random numbers}
\label{randarray}

If you generate a long series of random numbers, then every value should appear, at least approximately, the same number of times.
One way to test the \java{randomInt} method is to generate a large number of values, store them in an array, and count the number of times each value occurs.

The following method takes a single argument: the size of an array.
It allocates a new array of integers, fills it with random values, and returns a reference to the new array.

\begin{code}
    public static int[] randomArray(int size) {
      int[] a = new int[size];
      for (int i = 0; i < a.length; i++) {
          a[i] = randomInt(0, 99);
      }
      return a;
  }
\end{code}

The return type is \java{int[]}, which means that this method returns (a reference to) an array of integers.
To test this method, it is convenient to have another method that prints the contents of an array.

\begin{code}
    public static void printArray(int[] a) {
        System.out.print("{" + a[0]);
        for (int i = 1; i < a.length; i++) {
            System.out.print(", " + a[i]);
        }
        System.out.println("}");
    }
\end{code}

The following code generates an array and prints it:

\begin{code}
    int numValues = 8;
    int[] array = randomArray(numValues);
    printArray(array);
\end{code}

Here is what the output will look like (your results may differ):

\begin{stdout}
{15, 62, 46, 74, 67, 52, 51, 10}
\end{stdout}


\section{Traverse and count}

\index{histogram}
\index{counter}

If these values were exam scores (and they would be pretty bad exam scores), the teacher might present them to the class in the form of a {\bf histogram}, which is a set of counters that keeps track of the number of times each value appears.
For exam scores, we might have ten counters to keep track of how many students scored in the 90s, the 80s, etc.

\index{program development}
\index{bottom-up}

The next few sections develop the code to generate a histogram.
A good approach to solving problems like this one is to think of simple methods that are easy to write and then combine them into a solution.
This process is called {\bf bottom-up} development.
It is not always obvious where to start, but a good approach is to look for subproblems that fit a pattern you have seen before.

\index{traverse!array}
\index{array!traverse}
\index{looping and counting}

In Section~\ref{loopcount}, we saw a loop that traversed a string and counted the number of times a given letter appeared.
You can think of this program as an example of a pattern called ``traverse and count.''
The elements of this pattern are:

\begin{itemize}
\item A container that can be traversed, like an array or a string.
\item A test that you can apply to each element in the container.
\item A counter that keeps track of how many elements pass the test.
\end{itemize}

In the case of building a histogram, the container is an array of integers.
The test is whether or not a given score falls in a given range of values.
And the counter is the histogram itself.

Here is a method called \java{inRange} that counts the number of elements in an array that fall in a given range.
The parameters are the array and two integers that specify the lower and upper bounds of the range.

\begin{code}
public static int inRange(int[] a, int low, int high) {
    int count = 0;
    for (int i = 0; i < a.length; i++) {
        if (a[i] >= low && a[i] < high) {
            count++;
        }
    }
    return count;
}
\end{code}

Note that \java{low} is included in the range (\java{>=}), but \java{high} is excluded (\java{<}).
This important detail keeps us from counting any elements twice.

Now we can count the number of scores in the ranges we are interested in:

\begin{code}
    int[] scores = randomArray(30);
    int a = inRange(scores, 90, 100);
    int b = inRange(scores, 80, 90);
    int c = inRange(scores, 70, 80);
    int d = inRange(scores, 60, 70);
    int f = inRange(scores, 0, 60);
\end{code}


\section{Building a histogram}

This code is repetitious, but it is acceptable as long as the number of ranges is small.
Imagine that we want to keep track of the number of times each score appears, i.e., all 100 possible values.
Should you just write the following 100 lines of code?

\begin{code}
    int count0 = inRange(scores, 0, 1);
    int count1 = inRange(scores, 1, 2);
    int count2 = inRange(scores, 2, 3);
    ...
    int count99 = inRange(scores, 99, 100);
\end{code}

What we really want is a way to store 100 integers, preferably so we can use an index to access each one.
In other words, we need an array!

The counting pattern is the same whether we use a single counter or an array of counters.
In this case, we initialize the array outside the loop; then, inside the loop, we invoke \java{inRange} and store the result:

\begin{code}
    int[] counts = new int[100];
    for (int i = 0; i < counts.length; i++) {
        counts[i] = inRange(scores, i, i + 1);
    }
\end{code}

The only tricky thing here is that we are using the loop variable in two roles: as in index into the array, and as the parameter to \java{inRange}.

%\section{A single-pass solution}
\label{singlepass}

The code works, but it is not as efficient as it could be.
Every time it invokes \java{inRange}, it traverses the entire array.
As the number of ranges increases, that gets to be a lot of traversals.

It would be better to make a single pass through the array, and for each value, compute which range it falls in.
Then we could increment the appropriate counter.
Here is code that traverses an array of scores once and generates a histogram.

\begin{code}
    int[] counts = new int[100];
    for (int i = 0; i < scores.length; i++) {
        int index = scores[i];
        counts[index]++;
    }
\end{code}

In this example the computation is trivial, because we can use the value itself as an index into the array of counters.


\section{The enhanced for loop}

Since looping through arrays is so common, Java provides an alternative \java{for} loop syntax that makes the code more compact.
The basic idea is to iterate each element of the array, as opposed to each index.

\begin{code}
    // standard for loop
    for (int i = 0; i < values.length; i++) {
        System.out.println("The value is " + values[i]);
    }

    // enhanced for loop
    for (int value : values) {
        System.out.println("The value is " + value);
    }
\end{code}

You can read the enhanced \java{for} loop above as, ``for each \java{value} in \java{values}.''
It's common to use a plural nouns for array variables and singular nouns for element variables.

Using the enhanced \java{for} loop, we can create the histogram from the previous section using even less code:

\begin{code}
    int[] counts = new int[100];
    for (int score : scores) {
        counts[score]++;
    }
\end{code}

Because they make the code more readable, you should use enhanced \java{for} loops whenever possible.
For example, to find the maximum value in an array of integers, we simply look at each one:

\begin{code}
    int max = Integer.MIN_VALUE;
    for (int value : numbers) {
        if (value > max) {
            max = value;
        }
    }
\end{code}

Note however that the enhanced \java{for} loop does not give you the index of each value.
If you need to find the index of the maximum value, then you need to use a standard \java{for} loop.

\begin{code}
    int index = -1;
    int max = Integer.MIN_VALUE;
    for (int i = 0; i < numbers.length; i++) {
        if (numbers[i] > max) {
            index = i;
            max = numbers[i];
        }
    }
\end{code}


\section{Command-line arguments}

Now that you have learned about arrays, the time has finally come to explain the \java{args} parameter for \java{main} that we have been ignoring since Chapter 1.
Continuing the example from the previous section, let's write a program to find the maximum number.
Rather than read the numbers from \java{System.in}, we'll pass them as command-line arguments.
Here is a starting point:

\begin{code}
public class Max {
    public static void main(String[] args) {
        System.out.println(args);
    }
}
\end{code}

If you compile and run this program as-is, the output looks something like:

\begin{stdout}
[Ljava.lang.String;@5da1fbed
\end{stdout}

The variable \java{args} is an array of strings, and since arrays are objects, the \java{println} method calls its \java{toString} method.
Unfortunately arrays don't come with a useful version of \java{toString}, which is why we wrote our own \java{printArray} method in Section~\ref{randarray}.
The \java{java.util.Arrays} class provides a number of \java{toString} methods, if you're not in the mood to write your own.

Rather than print the address of the array, let's look at its actual contents:

\begin{code}
    System.out.println(Arrays.toString(args));
\end{code}

The output indicates that we have an empty array:

\begin{stdout}
[]
\end{stdout}

If you run Java from the command-line, you can pass optional arguments separated by spaces.
Everything after the class name is considered part of the command-line arguments.
For example, we can enter the command:

\begin{stdout}
java Max 10 -3 55 0 14
\end{stdout}

Now the output of the program is:

\begin{stdout}
[10, -3, 55, 0, 14]
\end{stdout}

At this point, we have a program that can read and write strings.
To find the maximum number, we need to convert the String arguments into integers.
Here is a complete example that uses an enhanced \java{for} loop to parse each command-line argument and search for the maximum value in a single pass.

\begin{code}
    int max = Integer.MIN_VALUE;
    for (String arg : args) {
        int value = Integer.parseInt(arg);
        if (value > max) {
            max = value;
        }
    }
    System.out.println("The max is " + max);
\end{code}

In general, command-line arguments allow you to customize your programs based on user input before the program begins.
For example, the \java{javac} and \java{java} programs use command-line arguments for a variety of configuration settings.
You can run \java{javac -help} and \java{java -help} from the command-line to see what they are.


\section{java.util.Arrays}

TODO


\section{Two dimensional arrays}

TODO


\section{Vocabulary}

\begin{description}

\term{array}
A collection of values, where all the values have the same type, and each value is identified by an index.

\term{element}
One of the values in an array.
The \java{[]} operator selects elements.

\term{index}
An integer variable or value used to indicate an element of an array.

\term{deterministic}
A program that does the same thing every time it is invoked.
Technically speaking, all computer programs are deterministic: they simply execute the source code.

\term{nondeterministic}
A program that behaves differently, even when run multiple times with the same input.
Nondeterminism is a theoretical concept for analyzing the complexity of algorithms.

\term{pseudorandom}
A sequence of numbers that appear to be random, but which are actually the product of a deterministic computation.

\term{histogram}
An array of integers where each integer counts the number of values that fall into a certain range.

\term{bottom-up}
A program development process that starts with simple methods and then assembles them into a working solution.

\end{description}


\section{Exercises}


\begin{exercise}
Write a method called \java{cloneArray} that takes an array of integers as a parameter, creates a new array that is the same size, copies the elements from the first array into the new one, and then returns a reference to the new array.
\end{exercise}


\begin{exercise}
Write a method called \java{randomDouble} that takes two doubles, \java{low} and {high}, and that returns a random double $x$ such that $low \le x < high$.
\end{exercise}


\begin{exercise}
Encapsulate the code in Section~\ref{singlepass} in a method called \java{makeHist} that takes an array of scores and returns a histogram of the values in the array.
\end{exercise}


\begin{exercise}
Write a method named \java{areFactors} that takes an integer \java{n} and an array of integers, and that returns \java{true} if the numbers in the array are all factors of \java{n} (which is to say that \java{n} is divisible by all of them).
%HINT: See Exercise~\ref{ex.isdiv}.
\end{exercise}


\begin{exercise}
Write a method that takes an array of integers and an integer named \java{target} as arguments, and that returns the first index where \java{target} appears in the array, if it does, and -1 otherwise.
\end{exercise}

\begin{exercise}
Some programmers disagree with the general rule that variables and methods should be given meaningful names.
Instead, they think variables and methods should be named after fruit.

For each of the following methods, write one sentence that describes abstractly what the method does.
For each variable, identify the role it plays.
(The purpose of this exercise is to practice reading code and recognizing the computation patterns we have seen.)

\begin{code}
    public static int banana(int[] a) {
        int grape = 0;
        int i = 0;
        while (i < a.length) {
            grape = grape + a[i];
            i++;
        }
        return grape;
    }
\end{code}

\begin{code}
    public static int apple(int[] a, int p) {
        int i = 0;
        int pear = 0;
        while (i < a.length) {
            if (a[i] == p) {
                pear++;
            }
            i++;
        }
        return pear;
    }
\end{code}

\begin{code}
    public static int grapefruit(int[] a, int p) {
        for (int i = 0; i < a.length; i++) {
            if (a[i] == p) {
                return i;
            }
        }
        return -1;
    }
\end{code}
\end{exercise}


\begin{exercise}
What is the output of the following program?
Draw a stack diagram that shows the state of the program just before \java{mus} returns.
Describe in a few words what \java{mus} does.

\begin{code}
    public static int[] make(int n) {
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = i + 1;
        }
        return a;
    }
\end{code}

\begin{code}
    public static void dub(int[] jub) {
        for (int i = 0; i < jub.length; i++) {
            jub[i] *= 2;
        }
    }
\end{code}

\begin{code}
    public static int mus(int[] zoo) {
        int fus = 0;
        for (int i = 0; i < zoo.length; i++) {
            fus = fus + zoo[i];
        }
        return fus;
    }
\end{code}

\begin{code}
    public static void main(String[] args) {
        int[] bob = make(5);
        dub(bob);
        System.out.println(mus(bob));
    }
\end{code}
\end{exercise}


\begin{exercise}
Many of the patterns we have seen for traversing arrays can also be written recursively.
It is uncommon, but it is a useful exercise.

\begin{enumerate}

\item Write a method called \java{maxInRange} that takes an array of integers and a range of indexes (\java{lowIndex} and \java{highIndex}), and that finds the maximum value in the array, considering only the elements between \java{lowIndex} and \java{highIndex}, including both ends.

This method should be recursive.
If the length of the range is 1, that is, \java{if lowIndex == highIndex}, we know immediately that the sole element in the range must be the maximum.
So that's the base case.

If there is more than one element in the range, we can break the array into two pieces, find the maximum in each of the pieces, and then find the maximum of the maxima.

\item Methods like \java{maxInRange} can be awkward to use.
To find the largest element in an array, we have to provide a range for the entire array.

\begin{code}
    double max = maxInRange(array, 0, a.length - 1);
\end{code}

Write a method called \java{max} that takes an array as a parameter and that uses \java{maxInRange} to find and return the largest value.

Methods like \java{max} are sometimes called ``wrapper methods'' because they provide a layer of abstraction around an awkward method and make it easier to use.
The method that actually performs the computation is called the ``helper method.''

\item Write a recursive method named \java{find} using the wrapper-helper pattern.
The \java{find} method should take an array of integers and a target integer.
It should return the index of the first location where the target integer appears in the array, or -1 if it does not appear.

\end{enumerate}
\end{exercise}


\begin{exercise}
One not-very-efficient way to sort the elements of an array is to find the largest element and swap it with the first element, then find the second-largest element and swap it with the second, and so on.
This algorithm is called selection sort (see \url{http://en.wikipedia.org/wiki/Selection_sort}).

\begin{enumerate}

\item Write a method called \java{indexOfMaxInRange} that takes an array of integers, finds the largest element in the given range, and returns its {\em index}.
You can modify your recursive version of \java{maxInRange} or you can write an iterative version from scratch.

\item Write a method called \java{swapElement} that takes an array of integers and two indices, and that swaps the elements at the given indices.

\item Write a method called \java{selectionSort} that takes an array of integers and that uses \java{indexOfMaxInRange} and \java{swapElement} to sort the array from largest to smallest.

\end{enumerate}
\end{exercise}


\begin{exercise}
Write a method called \java{letterHist} that takes a String as a parameter and that returns a histogram of the letters in the String.
The zeroeth element of the histogram should contain the number of a's in the String (upper and lower case); the 25th element should contain the number of z's.
Your solution should only traverse the String once.
\end{exercise}


\begin{exercise}
A word is said to be a ``doubloon'' if every letter that appears in the word appears exactly twice.
Here are some example doubloons found in the dictionary.

\begin{quote}
Abba, Anna, appall, appearer, appeases, arraigning, beriberi, bilabial, boob, Caucasus, coco, Dada, deed, Emmett, Hannah, horseshoer, intestines, Isis, mama, Mimi, murmur, noon, Otto, papa, peep, reappear, redder, sees, Shanghaiings, Toto
\end{quote}

Write a method called \java{isDoubloon} that returns \java{true} if the given word is a doubloon and \java{false} otherwise.
\end{exercise}


\begin{exercise}
Two words are anagrams if they contain the same letters (and the same number of each letter).
For example, ``stop'' is an anagram of ``pots'' and ``allen downey'' is an anagram of ``well annoyed.''

Write a method that takes two Strings and returns \java{true} if the Strings are anagrams of each other.

Optional challenge: read the letters of the Strings only once.
\end{exercise}


\begin{exercise}
In Scrabble each player has a set of tiles with letters on them, and the object of the game is to use those letters to spell words.
The scoring system is complicated, but longer words are usually worth more than shorter words.

Imagine you are given your set of tiles as a String, like \java{"quijibo"} and you are given another String to test, like \java{"jib"}.
Write a method called \java{canSpell} that takes two Strings and returns \java{true} if the set of tiles can be used to spell the word.
You might have more than one tile with the same letter, but you can only use each tile once.

Optional challenge: read the letters of the Strings only once.
\end{exercise}


\begin{exercise}
In real Scrabble, there are some blank tiles that can be used as wild cards; that is, a blank tile can be used to represent any letter.

Think of an algorithm for \java{canSpell} that deals with wild cards.
Don't get bogged down in details of implementation like how to represent wild cards.
Just describe the algorithm, using English, pseudocode, or Java.
\end{exercise}


\chapter{Arrays of objects}

In the remaining chapters, we will develop programs that work with playing cards and decks of cards.
Here is an outline of the road ahead:

\begin{enumerate}

\item In this chapter, we will define a \java{Card} class and write methods that work directly with \java{Card}s and arrays of \java{Card}s.

%TODO add \ref for each chapter

\item In Chapter 13, we will create a \java{Deck} class that encapsulates an array of Cards and write methods that operate on \java{Deck}s.

\item In Chapter 14, we will introduce object-oriented programming (OOP) and redesign the \java{Card} and \java{Deck} classes accordingly.

\end{enumerate}

Although we will see several versions of the same code, the main advantage of proceeding this way is that the explanations will be smoother.
It may help you to create a {\tt Card.java} file and paste in the examples as we go.

%If it helps, you can download the code for each chapter as you go along.
%The code for this chapter is here: \url{http://thinkapjava.com/code/Card1.java}.


\section{Card objects}
\label{card}

\index{Card}
\index{class!Card}

If you are unfamiliar with traditional playing cards, now would be a good time to get a deck; otherwise this chapter might not make much sense.
Or just read \url{https://en.wikipedia.org/wiki/Standard_52-card_deck}.

\index{rank}
\index{suit}

There are 52 cards in a standard deck.
Each card belongs to one of four suits and one of 13 ranks.
The suits are Spades, Hearts, Diamonds, and Clubs (in descending order in Bridge).
The ranks are Ace, 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, and King.
Depending on what game you are playing, the Ace may be considered higher than King or lower than 2.

If we want to define a new object to represent a playing card, it is pretty obvious what the instance variables should be: \java{rank} and \java{suit}.
It is not as obvious what types the instance variables should be.
One possibility is \java{String}s, containing things like \java{"Spade"} for suits and \java{"Queen"} for ranks.
A problem with this implementation is that it would not be easy to compare cards to see which had higher rank or suit.

\index{encode}
\index{encrypt}
\index{map to}

An alternative is to use integers to {\bf encode} the ranks and suits.
By ``encode'' we do not mean to encrypt or translate into a secret code.
What a computer scientist means by encode is something like ``define a mapping between a sequence of numbers and the things we want to represent.''

\begin{tabular}{l c l}
Clubs & $\mapsto$ & 0 \\
Diamonds & $\mapsto$ & 1 \\
Hearts & $\mapsto$ & 2 \\
Spades & $\mapsto$ & 3
\end{tabular}

The nice feature of this mapping is that the suits map to integers in order, so we can compare suits simply by comparing integers.
The mapping for ranks is fairly obvious: each of the numerical ranks maps to the corresponding integer, and for face cards:

\begin{tabular}{l c l}
Ace & $\mapsto$ & 1 \\
Jack & $\mapsto$ & 11 \\
Queen & $\mapsto$ & 12 \\
King & $\mapsto$ & 13 \\
\end{tabular}

The reason we are using mathematical notation for these mappings is that they are not part of the program.
They are part of the program design, but they never appear explicitly in the code.
The class definition for the \java{Card} type simply looks like this:

\begin{code}
public class Card {
    private int suit;
    private int rank;

    public Card() {
        this.suit = 0;
        this.rank = 0;
    }

    public Card(int suit, int rank) {
        this.suit = suit;
        this.rank = rank;
    }
}
\end{code}

\index{constructor}

As usual, we define two constructors: a default constructor that takes no parameters, and an explicit value constructor that takes a parameter for each instance variable.
To create a \java{Card} object that represents the 3 of Clubs, we can invoke the \java{new} operator:

\begin{code}
    Card threeOfClubs = new Card(0, 3);
\end{code}

%The first argument, \java{0} represents the suit Clubs.


\section{The printCard method}
\label{printcard}

\index{print!Card}

When you create a new class, the first step is to declare the instance variables and write constructors.
The second step is to write the standard methods that every object should have, including one that prints the object, and one or two that compare objects.
Let's start with \java{printCard}.

\index{String!array of}
\index{array!of String}

To print \java{Card} objects in a way that humans can read easily, we need to map the integer codes onto words.
A natural way to do that is with an array of \java{String}s.
You can create an array of \java{String}s the same way you create an array of primitive types:

\begin{code}
    String[] suits = new String[4];
\end{code}

Then we can set the values of the elements of the array.

\begin{code}
    suits[0] = "Clubs";
    suits[1] = "Diamonds";
    suits[2] = "Hearts";
    suits[3] = "Spades";
\end{code}

Creating an array and initializing the elements is such a common operation that Java provides a special syntax for it:

\begin{code}
    String[] suits = {"Clubs", "Diamonds", "Hearts", "Spades"};
\end{code}

\index{memory diagram}

This statement is equivalent to the separate declaration, allocation, and assignment.
The memory diagram of this array looks like:

\begin{center}
\includegraphics{figs/stringarray.pdf}
\end{center}

\index{reference}
\index{String!reference to}

Notice how the elements of the array are {\em references} to the \java{String}s, rather than \java{String}s themselves.

Now we need another array of \java{String}s to decode the ranks:

\begin{code}
    String[] ranks = {"narf", "Ace", "2", "3", "4", "5", "6",
               "7", "8", "9", "10", "Jack", "Queen", "King"};
\end{code}

The reason for the \java{"narf"} is to act as a placeholder for the zeroeth element of the array, which is never used (or shouldn't be).
The only valid ranks are 1--13.
To avoid this wasted element, we could have started at 0, but the mapping is more natural if we encode 2 as 2, 3 as 3, and so forth.

Using these arrays, we can select the appropriate \java{String}s by using the \java{suit} and \java{rank} as indexes.
In the method \java{printCard}:

\begin{code}
public static void printCard(Card c) {
    String[] suits = {"Clubs", "Diamonds", "Hearts", "Spades"};
    String[] ranks = {"narf", "Ace", "2", "3", "4", "5", "6",
               "7", "8", "9", "10", "Jack", "Queen", "King"};
    System.out.println(ranks[c.rank] + " of " + suits[c.suit]);
}
\end{code}

The expression \java{suits[c.suit]} means ``use the instance variable \java{suit} from the object \java{c} as an index into the array named \java{suits}.''

\begin{code}
    Card card = new Card(1, 11);
    printCard(card);
\end{code}

The output for this code is {\tt Jack of Diamonds}.


\section{The sameCard method}
\label{equivalence}

The word ``same'' is one of those things that occur in natural language that seem perfectly clear until you give it some thought, and then you realize there is more to it than you expected.

\index{natural language}
\index{language!natural}

For example, if I say ``Jared and I have the same car,'' I mean that his car and mine are the same make and model, but they are
two different cars.
If I say ``Jared and I have the same mother,'' I mean that his mother and mine are one person.
So the idea of ``sameness'' is different, depending on the context.

\index{ambiguity}

When you talk about objects, there is a similar ambiguity.
For example, if two \java{Card}s are the same, does that mean they contain the same data (rank and suit), or they are actually
the same \java{Card} object?

\index{identical}

To see if two references refer to the same object, we use the \java{==} operator.
References to the same object are {\bf identical}.
For example:

\begin{code}
    Card card1 = new Card(1, 11);
    Card card2 = card1;

    if (card1 == card2) {
        System.out.println("card1 and card2 are identical");
    }
\end{code}

\index{equivalent}

In contrast, references to objects with same data are {\bf equivalent}.
To check equivalence, it is common to write a method with a name like \java{sameCard}.

\begin{code}
    public static boolean sameCard(Card c1, Card c2) {
        return c1.suit == c2.suit && c1.rank == c2.rank;
    }
\end{code}

Here is an example that creates two objects with the same data, and uses \java{sameCard} to see if they are equivalent:

\begin{code}
    Card card1 = new Card(1, 11);
    Card card2 = new Card(1, 11);

    if (sameCard(card1, card2)) {
        System.out.println("card1 and card2 are equivalent");
    }
\end{code}

Note that if references are identical, they are also equivalent.
However if they are equivalent, they are not necessarily identical.
In the above example, \java{card1} and \java{card2} are equivalent but not identical.
Here is a memory diagram:

\begin{center}
\includegraphics{figs/card.pdf}
\end{center}

%\index{aliasing}
%What does it look like when \java{card1} and \java{card2} are identical?

%In Section~\ref{incomparable} I said that you should not use the \java{==} operator on \java{String}s because it does not do what you expect.
%Instead of comparing the contents of the \java{String} (equivalence), it checks whether the two \java{String}s are the same object (identity).


\section{The compareCard method}
\label{compare}

\index{compareCard}
\index{operator!conditional}
\index{conditional operator}

For primitive types, the conditional operators compare values and determine when one is greater or less than another.
These operators (\java{<}, \java{>}, and others) don't work for object types.
For \java{String}s, Java provides a \java{compareTo} method.
We have to write our own version for \java{Card}s, which we will call \java{compareCard}.
Later we will use this method to sort a deck of cards.

\index{ordering}
\index{complete ordering}
\index{partial ordering}

Some types are completely ordered, which means that you can compare any two values and tell which is bigger.
Integers and floating-point numbers are totally ordered.
Some sets are unordered, which means that there is no meaningful way to say that one element is bigger than another.
Fruits are unordered, which is why we cannot compare apples and oranges.
In Java, the \java{boolean} type is unordered; we cannot say that \java{true} is greater than \java{false}.

The set of playing cards is partially ordered, which means that sometimes we can compare cards and sometimes not.
For example, I know that the 3 of Clubs is higher than the 2 of Clubs, and the 3 of Diamonds is higher than the 3 of Clubs.
But which is better, the 3 of Clubs or the 2 of Diamonds?
One has a higher rank, but the other has a higher suit.

\index{comparable}

To make cards comparable, we have to decide which is more important: rank or suit.
The choice is arbitrary, but when you buy a new deck of cards, it comes sorted with all the Clubs together, followed by all the Diamonds, and so on.
So for now, let's say that suit is more important.

With that decided, we can write \java{compareCard}.
It takes two \java{Card}s as parameters and returns 1 if the first card wins, -1 if the second card wins, and 0 if they are equivalent.
First we compare suits:

\begin{code}
    if (c1.suit > c2.suit) {
        return 1;
    }
    if (c1.suit < c2.suit) {
        return -1;
    }
\end{code}

If neither statement is true, then the suits must be equal and we have to compare ranks:

\begin{code}
    if (c1.rank > c2.rank) {
        return 1;
    }
    if (c1.rank < c2.rank) {
        return -1;
    }
\end{code}

If neither of these is true, then the ranks must also be equal.
So we simply return 0 at the end of the method.


\section{Class variables}

So far we have seen local variables, which are declared inside a method, and instance variables, which are declared in a class
definition, usually before the method definitions.
Local variables are created when a method is invoked and destroyed when the method ends.
Instance variables are created when you create an object and destroyed when the object is garbage collected.

\index{class variables}

Now it's time to learn about {\bf class variables}.
Like instance variables, class variables are defined in a class definition before the method definitions.
But they are identified by the keyword \java{static}.
They are created when the program starts (or when the class is used for the first time) and survive until the program ends.
Class variables are {\em shared} across all instances of the class.

You can refer to a class variable from anywhere inside the class definition.
Class variables are often used to store constant values that are needed in several places.
In that case, they should also be defined as \java{final}.
Note that whether a variable is \java{static} or \java{final} involves two separate considerations:
\java{static} means the variable is shared, and \java{final} means the variable is constant.

As an example, here is a version of \java{Card} where \java{suits} and \java{ranks} are defined as class constants:

\begin{code}
public class Card {

    public static final String[] SUITS = {
        "Clubs", "Diamonds", "Hearts", "Spades"};

    public static final String[] RANKS = {
        "narf", "Ace", "2", "3", "4", "5", "6", "7", "8", "9",
        "10", "Jack", "Queen", "King"};

    // instance variables and constructors go here

    public static void printCard(Card c) {
        String name = RANKS[c.rank] + " of " + SUITS[c.suit];
        System.out.println(name);
    }
}
\end{code}

Inside \java{printCard} we can refer to \java{SUITS} and \java{RANKS} as if they were local variables.
Writing \java{static final} variables in ALL CAPS is a common convention that makes it easier to recognize their purpose in the class.

One advantage of defining \java{SUITS} and \java{RANKS} as class variables is that they don't need to be created (and garbage collected) every time the printCard method is called.
They may also be useful in other methods and classes, so it's nice to maintain them in one place.


\section{Arrays of cards}
\label{cardarray}

\index{array!of object}
\index{object!array of}
\index{deck}

\index{composition}

By now we have seen several examples of composition (the ability to combine language features in a variety of arrangements).
One of the first examples we saw was using a method invocation as part of an expression.
Another example is the nested structure of statements: you can put an \java{if} statement within a \java{while} loop, or within
another \java{if} statement, etc.

Having seen this pattern, and having learned about arrays and objects, you should not be surprised to learn that you can make arrays of objects.
And you can define objects with arrays as instance variables; you can make arrays that contain arrays; you can define objects that contain objects, and so on.
%In the next two chapters we will see examples of these combinations using \java{Card} objects.
This example creates an array of 52 cards:

\begin{code}
    Card[] cards = new Card[52];
\end{code}

\index{state diagram}

Here is the memory diagram for this object:

\begin{center}
\includegraphics{figs/cardarray.pdf}
\end{center}

\index{null}

The array contains {\em references} to objects; it does not contain the \java{Card} objects themselves.
The elements are initialized to \java{null}.
You can access the elements of the array in the usual way:

\begin{code}
    if (cards[0] == null) {
        System.out.println("No card yet!");
    }
\end{code}

\index{exception!NullPointer}
\index{run-time error}

But if you try to access the instance variables of the non-existent \java{Card}s, you will get a \java{NullPointerException}.

\begin{code}
    System.out.println(cards[0].rank);  // NullPointerException
\end{code}

\index{composition}

That {\em is} the correct syntax for accessing the \java{rank} of the ``zeroeth'' card in the deck.
It's also another example of composition, or combining the syntax for accessing an element of an array and an instance variable of an object.

\index{loop!nested}

The easiest way to populate the deck with \java{Card} objects is to write nested for loops (i.e., one loop inside the body of another):

\begin{code}
    int index = 0;
    for (int suit = 0; suit <= 3; suit++) {
        for (int rank = 1; rank <= 13; rank++) {
            cards[index] = new Card(suit, rank);
            index++;
        }
    }
\end{code}

The outer loop enumerates the suits from 0 to 3.
For each suit, the inner loop enumerates the ranks from 1 to 13.
Since the outer loop runs 4 times, and the inner loop runs 13 times, the body is executed is 52 times.

\index{index}

We use a separate variable \java{index} to keep track of where in the deck the next card should go.
The following memory diagram shows what the deck looks like after the first two cards have been allocated:

\begin{center}
\includegraphics{figs/cardarray2.pdf}
\end{center}


%\section{The printDeck method}
%\label{printdeck}

\index{printDeck}
\index{print!array of Cards}

When you work with arrays, it is convenient to have a method that prints the contents.
We have seen the pattern for traversing an array several times, so the following method should be familiar:

\begin{code}
    public static void printDeck(Card[] cards) {
        for (int i = 0; i < cards.length; i++) {
            printCard(cards[i]);
        }
    }
\end{code}

Since \java{cards} has type \java{Card[]}, an element of \java{cards} has type \java{Card}.
So \java{cards[i]} is a legal argument for \java{printCard}.


\section{Sequential search}
\label{findcard}

\index{findCard}
\index{sequential search}
\index{binary search}

The next method we'll write is \java{findCard}, which searches an array of \java{Card}s to see whether it contains a certain card.
This method gives us a chance to demonstrate two algorithms: {\bf sequential search} and {\bf binary search}.

\index{traverse}
\index{loop!search}

Sequential search is pretty obvious: we traverse the deck and compare each card to the one we are looking for.
If we find it, we return the index where the card appears.
If it is not in the deck, we return -1.

\begin{code}
public static int findCard(Card[] cards, Card card) {
    for (int i = 0; i < cards.length; i++) {
        if (sameCard(cards[i], card)) {
            return i;
        }
    }
    return -1;
}
\end{code}

The parameters of \java{findCard} are \java{cards} and \java{card}.
It might seem odd to have a variable with the same name as a type (the \java{card} variable has type \java{Card}).
We can tell the difference because the variable begins with a lower-case letter.

\index{statement!return}
\index{return!inside loop}

The method returns as soon as it discovers the card, which means that we do not have to traverse the entire deck if we find the card we are looking for.
If we get to the end of the loop, however, we know the card is not in the deck.

If the cards in the deck are not in order, there is no way to search faster than sequential search.
We have to look at every card, because otherwise we can't be certain the card we want is not there.

However for large arrays, sequential search is rather inefficient.
If you pay the price to keep them sorted, finding elements becomes much easier.


\section{Binary search}

When you look for a word in a dictionary, you don't just search page by page from front to back.
Since the words are in alphabetical order, you probably use an algorithm similar to binary search:

\begin{enumerate}
\item Start in the middle of the dictionary (or array).
\item Compare a word on that page to the word you are looking for.
If you find the word you are looking for, stop.
\item If the word you are looking for comes after the word on the page, flip to somewhere later in the dictionary and go back to step 2.
\item If the word you are looking for comes before the word on the page, flip to somewhere earlier in the dictionary and go back to step 2.
\end {enumerate}

If you ever get to the point where there are two adjacent words on the page and your word comes between them, you can conclude that your word is not in the dictionary.

Getting back to the deck of cards, we can write a faster version of \java{findCard} if we know the cards are in order.
It takes a little more code, but the idea is the same four steps listed above.

\begin{code}
public static int findCard(Card[] cards, Card card) {
    int low = 0;
    int high = cards.length - 1;
    while (low <= high) {
        int mid = (low + high) / 2;                   // step 1
        int comp = compareCard(cards[mid], card);

        if (comp == 0) {                              // step 2
            return mid;
        } else if (comp < 0) {                        // step 3
            low = mid + 1;
        } else {                                      // step 4
            high = mid - 1;
        }
    }
    return -1;
}
\end{code}

First, we declare \java{low} and \java{high} variables to represent the range we are searching.
Initially we search the entire array, from index \java{0} to \java{length - 1}.
We will terminate our search if these indexes ever cross, yielding an invalid range.

Inside the \java{while} loop, we repeat the four steps of binary search:

\begin{enumerate}

\item To search the array, choose an index between \java{low} and \java{high} (call it \java{mid}) and compare it to the card you are looking for.

\item If you found it, return the index.

\item If the card at \java{mid} is higher than your card, search the range from \java{low} to \java{mid - 1}.

\item If the card at \java{mid} is lower than your card, search the range from \java{mid + 1} to \java{high}.

\end{enumerate}

%\section{Recursive version}

\index{recursion}

Another way to write a binary search is with a recursive method.
The trick is to write a method that takes \java{low} and \java{high} as parameters, and turn steps 3 and 4 into recursive invocations.
%They indicate the segment of the array that should be searched (including both \java{low} and \java{high}).
Here's what this algorithm looks like translated into Java code:

\begin{code}
public static int findCard(Card[] cards, Card card,
                           int low, int high) {
    if (high < low) {
        return -1;
    }
    int mid = (low + high) / 2;                       // step 1
    int comp = compareCard(cards[mid], card);

    if (comp == 0) {                                  // step 2
        return mid;
    } else if (comp < 0) {                            // step 3
        return findCard(cards, card, mid + 1, high);
    } else {                                          // step 4
        return findCard(cards, card, low, mid - 1);
    }
}
\end{code}

%This code contains the main idea of a binary search, but it is still missing an important part.
%As written, the method recurses forever if the card is not in the deck!
%We need a base case to handle this condition and end the recursion.

Instead of a \java{while} loop, we simply have an \java{if} statement to terminate the recursion.
If \java{high} is less than \java{low}, there are no cards between them, and we conclude that the card is not in the deck.
%We can handle that case by adding a single \java{if} statement to the top:

\index{recursion!infinite}
\index{infinite recursion}
\index{exception!StackOverflow}

Two common errors in recursive programs are (1) forgetting to include a base case, and (2) writing the recursive call so that the base case is never reached.
Either error causes infinite recursion and a \java{StackOverflowException}.
%(Think of a stack diagram for a recursive method that never ends.)

\section{Tracing the code}

To see how binary search works, it's useful to add the following print statement at the beginning of each iteration (or recursive call).

\begin{code}
    System.out.println(low + ", " + high);
\end{code}

%The print statement is unnecessary, but it's useful to trace the sequence of recursive invocations.

Then in the \java{main} method, execute the following code (after creating the cards array with nested loops):

\begin{code}
    Card card = new Card(1, 11);
    System.out.println(findCard(cards, card));
\end{code}

The result is \java{23} as expected, since there are 13 cards in the zeroth suit followed by 11 in the first suit (and indexes start at zero).
Here is the complete output, thanks to the print statement in \java{findCard}:

\begin{stdout}
0, 51
0, 24
13, 24
19, 24
22, 24
23
\end{stdout}

Let's make up a card that is not in the deck, say \java{new Card(1, 15)} or the ``15 of Diamonds''.
If we try to find it using binary search, we get the following:

\begin{stdout}
0, 51
26, 51
26, 37
26, 30
26, 27
26, 25
-1
\end{stdout}

%\index{testing}
%\index{correctness}
%
%These tests don't prove that this program is correct.
%In fact, no amount of testing can {\em prove} that a program is correct.
%But looking at a few cases and examining the code, you might be able to convince yourself.

Binary search over an array of length $n$ requires $\log_2 n$ comparisons.
So we only have to look at 5 or 6 cards in the deck, as opposed to all 52 if we did a sequential search.
In general, binary search is much faster than sequential search (which requires $n$ comparisons), and even more so for large arrays.


\section{Vocabulary}

\begin{description}

\term{encode}
To represent one set of values using another set of values, by constructing a mapping between them.

\term{identical}
Equality of references.
Two references that point to the same object in memory.

\term{equivalent}
Equality of values.
Two references that point to objects that contain the same data.

\term{class variable}
A variable declared within a class as \java{static}.
There is always exactly one copy of this variable, no matter how many objects exist.

\term{sequential search}
An algorithm that searches array elements in order, one by one, until an item is found.

\term{binary search}
An algorithm that searches an ordered array by starting in the middle and discarding half of the remaining elements each time a comparison is made.

\end{description}


\section{Exercises}


\begin{exercise}
Encapsulate the code in Section~\ref{compare} in a method.
Then modify it so that aces are ranked higher than Kings.
\end{exercise}


\begin{exercise}
Encapsulate the deck-building code from Section~\ref{cardarray} in a method called \java{makeDeck} that takes no parameters and returns a fully-populated array of \java{Card}s.
\end{exercise}


\begin{exercise}
In Blackjack the object of the game is to get a collection of cards with a score of 21.
The score for a hand is the sum of scores for all cards.
The score for an aces is 1, for all face cards is ten, and for all other cards the score is the same as the rank.
For example, the hand (Ace, 10, Jack, 3) has a total score of 1 + 10 + 10 + 3 = 24.

Write a method called \java{handScore} that takes an array of cards as an argument and that returns the total score.
\end{exercise}


\begin{exercise}
In Poker a ``flush'' is a hand that contains five or more cards of the same suit.
A hand can contain any number of cards.

\begin{enumerate}

\item Write a method called \java{suitHist} that takes an array of Cards as a parameter and that returns a histogram of the suits in the hand.
Your solution should only traverse the array once.

\item Write a method called \java{hasFlush} that takes an array of Cards as a parameter and returns \java{true} if the hand contains a flush (\java{false} otherwise).

\end{enumerate}

\end{exercise}


\chapter{Objects of Arrays}

\index{array!of Cards}

Previously we looked at algorithms for searching for a particular \java{Card} in an array of \java{Card} objects.
It turns out that an array of \java{Card}s is not only useful for representing an entire deck, but also for representing a subdeck (i.e., part of the deck).
For example, we can use a separate array for each player to remember which \java{Card}s they have been dealt.

In this chapter, we will take another step toward object-oriented programming.
We will also develop algorithms for shuffling and sorting decks of cards.
While reading the following sections, we recommend that you create a {\tt Deck.java} file and paste in all the examples.
You will need {\tt Card.java} from the previous chapter for it to compile.

%So many of the examples are non-idiomatic; that is, they are not good Java.
%This transitional form should help you learn, but don't write code like this.

%You can download the code in this chapter from \url{http://thinkapjava.com/code/Card2.java}.


\section{The Deck class}
\label{deck}

The main idea of this chapter is to create a \java{Deck} class that contains (encapsulates) an array of \java{Card}s.
The initial class definition looks like this:

\begin{code}
public class Deck {
    private Card[] cards;

    public Deck(int n) {
        this.cards = new Card[n];
    }
}
\end{code}

\index{constructor}
\index{state diagram}

The constructor initializes the instance variable with an array of cards, but it doesn't create any cards.
Here is a state diagram showing what a \java{Deck} looks like with no cards:

\begin{center}
\includegraphics{figs/deckobject.pdf}
\end{center}

We will also provide a default constructor that makes a standard 52-card deck and populates it with \java{Card} objects:

\begin{code}
    public Deck() {
        this.cards = new Card[52];
        int index = 0;
        for (int suit = 0; suit <= 3; suit++) {
            for (int rank = 1; rank <= 13; rank++) {
                cards[index] = new Card(suit, rank);
                index++;
            }
        }
    }
\end{code}

\index{new}
\index{statement!new}

This method is similar to \java{makeDeck} from the previous chapter; we just changed the syntax to make it a constructor.
To invoke it, we apply the \java{new} operator:

\begin{code}
    Deck deck = new Deck();
\end{code}

\index{printDeck}

Now it makes sense to put the methods that pertain to \java{Deck}s in the \java{Deck} class definition.
Looking at the methods we have written so far, one obvious candidate is \java{printDeck} (Section~\ref{printdeck}).
Here's how it looks, rewritten to work with a \java{Deck}:

\begin{code}
    public static void printDeck(Deck deck) {
        for (int i = 0; i < deck.cards.length; i++) {
            Card.printCard(deck.cards[i]);
        }
    }
\end{code}

The main change is the type of the parameter: from \java{Card[]} to \java{Deck}.
As a result, we can no longer use \java{deck.length} to get the length of the array.
The Deck object contains an array, but it is not an array by itself.
So we have to write \java{deck.cards.length} to extract the array from the \java{Deck} object and get the length of the array.
For the same reason, we have to use \java{deck.cards[i]} to access an element of the array, rather than just \java{deck[i]}.
%The last change is that the invocation of \java{printCard} has to say explicitly that \java{printCard} is defined in the \java{Card} class.


\section{Subdecks of cards}
\index{subdeck}

How should we represent a subset of a full deck?
One possibility is to create a new class, but it would be very similar to \java{Deck}.
A better option is to reuse the \java{Deck} class, but have fewer than 52 cards.

We might want a method, \java{subdeck}, that takes a Deck and a range of indexes.
It will return a new Deck with the specified subset of the cards:

\begin{code}
public static Deck subdeck(Deck deck, int low, int high) {
    Deck sub = new Deck(high - low + 1);

    for (int i = 0; i < sub.cards.length; i++) {
        sub.cards[i] = deck.cards[low + i];
    }
    return sub;
}
\end{code}

Note that the length of the subdeck is \java{high - low + 1}, because both the low card and the high card are included.
This sort of computation can be confusing, and forgetting the \java{+ 1} often leads to ``off-by-one'' errors.
Drawing a picture is usually the best way to avoid them.

\index{constructor}
\index{overloading}

Because the first line provides an argument with \java{new}, the non-default constructor gets invoked.
It simply allocates the array without allocating any cards.
Inside the \java{for} loop, the subdeck gets populated with copies of the references from the deck.

The following is a state diagram of a subdeck being created with the parameters \java{low = 3} and \java{high = 7}.
The result is a hand with 5 cards that are {\em shared} with the original deck, i.e., they are aliased.

\begin{center}
\includegraphics{figs/subdeck.pdf}
\end{center}

\index{aliasing}
\index{reference}

Aliasing is not always a good idea, because changes to shared objects are reflected in multiple decks.
However, since we designed \java{Card} objects to be immutable, they will never change.
So for \java{Card}s, \java{String}s, and other immutable objects, aliasing is an efficient choice.


\section{Shuffling and dealing}
\label{shuffle}

\index{shuffle}

For most card games you need to be able to shuffle the deck, i.e., put the cards in a random order.
In Section~\ref{random} we saw how to generate random numbers, but it is not obvious how to use them to shuffle a deck.

One possibility is to model the way humans shuffle, which is usually dividing the deck in two and then choosing alternately from each deck.
Since humans usually don't shuffle perfectly, after about seven iterations the order of the deck is pretty well randomized.

But a computer program would have the annoying property of doing a perfect shuffle every time, which is not really very random.
In fact, after eight perfect shuffles, you would find the deck back in the order you started in!
(For more information, see \url{http://en.wikipedia.org/wiki/Faro_shuffle}.)

\index{pseudocode}

A better shuffling algorithm is to traverse the deck one card at a time, and at each iteration choose two cards and swap them.
Here is an outline of how this algorithm works.
To sketch the program, we will use a combination of Java statements and English.
This technique is sometimes called {\bf pseudocode}.

\begin{code}
    for each card index {
        // choose a number between i and deck length - 1
        // swap the ith card and the randomly-chosen card
    }
\end{code}

\index{randomInt}
\index{swapCards}

The nice thing about pseudocode is that it often makes clear what methods you are going to need.
In this case, we need something like \java{randomInt}, which chooses a random integer between \java{low} and \java{high}, and \java{swapCards}, which takes two indexes and switches the cards at those positions.

\index{program development}

This process---writing pseudocode first and then writing methods to make it work---is called {\bf top-down development} (see \url{http://en.wikipedia.org/wiki/Top-down_and_bottom-up_design}).

\index{shuffling}
\index{dealing}

Assuming that we have a method called \java{shuffleDeck} that takes a deck as an argument and shuffles it, we can use it to deal two players:

\begin{code}
    Deck deck = new Deck();
    shuffleDeck(deck);

    Deck hand1 = subdeck(deck, 0, 4);
    Deck hand2 = subdeck(deck, 5, 9);
    Deck pack = subdeck(deck, 10, 51);
\end{code}

This code puts the first five cards in one hand, the next five cards in the other, and the rest into the pack.

When you thought about dealing, did you think we should give one card to each player in the round-robin style that is common in real card games?
The round-robin convention is intended to mitigate imperfect shuffling and make it more difficult for the dealer to cheat.

This example is a useful reminder of one of the dangers of engineering metaphors.
Sometimes we impose restrictions on computers that are unnecessary, or expect capabilities that are lacking, because we unthinkingly extend a metaphor past its breaking point.


\section{Selection sort algorithm}
\label{sorting}

\index{selection sort}
\index{sort!selection}

Now that we have messed up the deck, we need a way to put it back in order.
There is an algorithm for sorting that is ironically similar to the algorithm for shuffling.
It's called {\bf selection sort} because it works by traversing the array repeatedly and selecting the lowest (or highest) remaining card each time.

During the first iteration, we find the lowest card and swap it with the card in the 0th position.
During the \java{i}th, we find the lowest card to the right of $i$ and swap it with the $i$th card.
Here is pseudocode for selection sort:

\begin{code}
    for each card index {
        // find the lowest card at or to the right of i
        // swap the ith card and the lowest card found
    }
\end{code}

\index{helper method}
\index{method!helper}

Again, the pseudocode helps with the design of the {\bf helper methods}.
In this case we can use \java{swapCards} again, so we only need one new method that takes an array of cards and an index where it should start looking.
We'll call that method \java{indexLowestCard}.

Rather than show you the actual source code, we will leave the implementation as an exercise.


\section{Merging sorted decks}
\label{mergesort}

\index{efficiency}
\index{sorting}
\index{mergesort}

Selection sort is a simple algorithm that turns out not to be very efficient.
To sort $n$ items, it has to traverse the array $n$ times.
Each traversal takes an amount of time that is proportional to $n$.
The total time, therefore, is proportional to $n^2$.

In the next two sections, we'll consider a more efficient algorithm called {\bf mergesort}.
To sort $n$ items, mergesort takes time proportional to $n \log_2 n$.
That may not seem impressive, but as $n$ gets big, the difference between $n^2$ and $n \log_2 n$ can be enormous.
For example, $\log_2$ of one million is around 20.
So if you had to sort a million numbers, selection sort would require one trillion steps versus only 20 million for mergesort.

The basic idea behind mergesort is this: if you have two subdecks, each of which has already been sorted, it is easy (and fast) to merge them into a single, sorted deck.
Try this out with a deck of cards:

\begin{enumerate}

\item Form two subdecks with about 10 cards each, and sort them so that when they are face up the lowest cards are on top.
Place both decks face up in front of you.

\item Compare the top card from each deck and choose the lower one.
Flip it over and add it to the merged deck.

\item Repeat step two until one of the decks is empty.
Then take the remaining cards and add them to the merged deck.

\end{enumerate}

The result should be a single sorted deck.
Here's what this algorithm looks like in pseudocode:

\begin{code}
public static Deck merge(Deck d1, Deck d2) {
    // create a new deck big enough for all the cards
    Deck result = new Deck(d1.cards.length + d2.cards.length);

    // use the index i to keep track of where we are at in
    // the first deck, and the index j for the second deck
    int i = 0;
    int j = 0;

    // the index k traverses the result deck
    for (int k = 0; k < result.cards.length; k++) {

        // if d1 is empty, d2 wins; if d2 is empty, d1 wins;
        // otherwise, compare the two cards

        // add the winner to the new deck
    }
    return result;
}
\end{code}

\index{testing}

The best way to test the \java{merge} method is to build and shuffle a deck.
Then use subdeck to form two (small) hands, and use selection sort (from the previous section) to sort the two halves.
Then you can pass the two halves to \java{merge} to see if it works.

\section{Mergesort algorithm}

Once your \java{merge} method is working correctly, you can out try a simple version of \java{mergeSort}:

\begin{code}
public static Deck mergeSort(Deck deck) {
    // find the midpoint of the deck
    // divide the deck into two subdecks
    // sort the subdecks using sortDeck
    // merge the two halves and return the result
}
\end{code}

Then, if you get that working, the real fun begins!
The magical thing about mergesort is that it is inherently recursive.
At the point where you sort the subdecks, why should you invoke the slower version of \java{sortDeck}?
Why not just invoke the spiffy new \java{mergeSort} you are in the process of writing?

\index{recursion}

Not only is that a good idea, it is {\em necessary} to achieve the $\log_2$ performance advantage.
To make it work recursively, you have to have a base case---otherwise it recurses forever.
A simple base case is a subdeck with 0 or 1 cards.
If \java{mergesort} receives such a small subdeck, it can return it unmodified since it is already sorted.

The recursive version of \java{mergesort} should look something like this:

\begin{code}
public static Deck mergeSort(Deck deck) {
    // if the deck is 0 or 1 cards, return it
    // find the midpoint of the deck
    // divide the deck into two subdecks
    // sort the subdecks using mergesort
    // merge the two halves and return the result
}
\end{code}

\index{leap of faith}

As usual, there are two ways to think about recursive programs: you can think through the entire flow of execution, or you can make the ``leap of faith'' (see Section~\ref{leap of faith}).
This example should encourage you to make the leap of faith!

When you use \java{sortDeck} to sort the subdecks, you don't feel compelled to follow the flow of execution, right?
You just assume it works because you already debugged it.
Well, all you did to make \java{mergeSort} recursive was replace one sorting algorithm with another.
There is no reason to read the program any differently.

Actually, you have to give some thought to getting the base case right and making sure that you reach it eventually.
But other than that, writing the recursive version should be no problem.


\section{Inserting new cards}

\index{insertion sort}
\index{sort!insertion}

One last sorting algorithm is called {\bf insertion sort}, because it's based on inserting an item into a previously sorted list.
In the card playing example, humans typically apply the following algorithm when they are dealt new cards:

\begin{enumerate}
\item Use sequential search to find the insertion point (i.e., the index in the array where the new \java{Card} belongs).
\item Insert the new card at that position.
\end{enumerate}

That's easy enough when holding a small set of cards in your hand: you generally can make room for one more card.
But in Java, we're talking about modifying an array of fixed length.
If the array has five \java{Card}s, you can't just insert a sixth \java{Card} in the middle of it.

Consequently, the second step above is a bit more complicated:

\begin{enumerate}
\item Use sequential search to find the insertion point (i.e., the index in the array where the new \java{Card} belongs).
\item Create a new array with a length of one more element.
\item Copy existing elements from the old array to their corresponding position in the new array (skipping the insertion point).
\item Insert the new card at the insertion point.
\end{enumerate}

We can extend this insertion algorithm to sort an entire (unsorted) deck of cards.
Of course, we don't want to create a new array and copy elements over 52 times.
But we'll need a way to run sequential search over and over again.


\section{Insertion sort algorithm}

The resulting algorithm consists of two loops.
The outer loop (for $i$) starts at index 1 (not 0) and attempts to insert each card, treating all the cards to the left as a previously sorted array.
The inner loop (for $j$) searches for the insertion point in the range $0$ to $i-1$, while at the same time shifting applicable cards to the right.
The last statement performs the actual insertion of each card.

\begin{code}
public static Deck insertionSort(Deck deck) {
    for (int i = 1; i < cards.length; i++) {
        Card temp = cards[i];
        int j = i - 1;
        while (j >= 0 && Card.compareCard(temp, cards[j]) < 0) {
            cards[j + 1] = cards[j];
            j--;
        }
        cards[j + 1] = temp;
    }
}
\end{code}

It may be difficult to visualize how these algorithms work by simply looking at the source code.
Fortunately the Internet is full of animations, video tutorials, and other resources to help you.

As with other sorting algorithms, Wikipedia is a reasonable place to get more information: \url{https://en.wikipedia.org/wiki/Selection_sort}.
You should also check out \url{http://www.sorting-algorithms.com/} which shows eight different algorithms side by side, comparing both their techniques and overall efficiency.


\section{Vocabulary}

\begin{description}

\term{pseudocode}
A way of designing programs by writing rough drafts in a combination of English and Java.

\term{top-down development}
Breaking down a problem into sub-problems, and solving each sub-problem one at a time.

\term{selection sort}
A simple sorting algorithm that searches for the smallest element $n$ times.

\term{helper method}
Often a small method that does not do anything enormously useful by itself, but which helps another, more useful method.

\term{mergesort}
A recursive sorting algorithm that divides an array into two parts, sorts each part (using mergesort), and merges the results.

\term{insertion sort}
Another sorting algorithm that inserts elements into place, one at a time.

\end{description}


\section{Exercises}


\begin{exercise}
The goal of this exercise is to implement the shuffling and sorting algorithms from this chapter.

\begin{enumerate}

%\item Download the code from this chapter from \url{http://thinkapjava.com/code/Card2.java} and import it into your development environment.
%I have provided outlines for the methods you will write, so the program should compile.
%But when it runs it prints messages indicating that the empty methods are not working.
%When you fill them in correctly, the messages should go away.

%\item If you did Exercise~\ref{ex.randint}, you already wrote \java{randomInt}.
%Otherwise, write it now and add code to test it.

\item Write a method called \java{swapCards} that takes a deck (array of cards) and two indexes, and that switches the cards at those two locations.

HINT: it should switch references, not the contents of the objects.
This is also faster; it correctly handles the case where cards are aliased.

\item Write a method called \java{shuffleDeck} that uses the algorithm in Section~\ref{shuffle}.
You might want to use the \java{randomInt} method from Exercise~\ref{ex.randint}.

\item Write a method called \java{indexLowestCard} that uses the \java{compareCard} method to find the lowest card in a given range of the deck (from \java{lowIndex} to \java{highIndex}, including both).

\item Write a method called \java{sortDeck} that arranges a deck of cards from lowest to highest.

\item Using the pseudocode in Section~\ref{mergesort}, write the method called \java{merge}.
Be sure to test it before trying to use it as part of a \java{mergeSort}.

\item Write the simple version of \java{mergeSort}, the one that divides the deck in half, uses \java{sortDeck} to sort the two halves, and uses \java{merge} to create a new, fully-sorted deck.

\item Write the fully recursive version of \java{mergeSort}.
Remember that \java{sortDeck} is a modifier and \java{mergeSort} is a function, which means that they get invoked differently:

\begin{code}
sortDeck(deck);              // modifies existing deck
deck = mergeSort(deck);      // replaces old deck with new
\end{code}

\end{enumerate}
\end{exercise}


\backmatter
\appendix

%\input{todo-tex/chapter17.tex}
%\input{todo-tex/chapter18.tex}
%\input{todo-tex/chapter19.tex}
%\input{todo-tex/chapter20.tex}

\printindex
\cleardoublepage

\end{document}
