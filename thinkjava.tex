\documentclass[12pt]{book}

\title{Think Java}
\author{Allen Downey and Chris Mayfield}

\newcommand{\thetitle}{Think Java: How to Think Like a Computer Scientist}
\newcommand{\theauthors}{Allen Downey and Chris Mayfield}
\newcommand{\theversion}{Version 6.0 Draft -- \today}

%%%% Both LATEX and PLASTEX

% balanced index with TOC entry
\usepackage{makeidx}
\makeindex

% automatically index glossary terms
\newcommand{\term}[1]{%
\index{#1}
\item[#1:]}

\usepackage{amsmath}
\usepackage{amsthm}

% format end of chapter excercises
\newtheoremstyle{exercise}
  {12pt}        % space above
  {12pt}        % space below
  {}            % body font
  {}            % indent amount
  {\bfseries}   % head font
  {}            % punctuation
  {12pt}        % head space
  {}            % custom head
\theoremstyle{exercise}
\newtheorem{exercise}{Exercise}[chapter]

\usepackage{graphicx}
%\graphicspath{{figs/}}

\usepackage{url}

\newif\ifplastex
\plastexfalse

\ifplastex
%%%% PLASTEX ONLY

\usepackage{localdef}

\newcount\anchorcnt
\newcommand*{\Anchor}[1]{%
  \@bsphack%
    \Hy@GlobalStepCount\anchorcnt%
    \edef\@currentHref{anchor.\the\anchorcnt}% 
    \Hy@raisedlink{\hyper@anchorstart{\@currentHref}\hyper@anchorend}% 
    \M@gettitle{}\label{#1}% 
    \@esphack%
}

\newcommand{\java}[1]{\verb"#1"}
\newcommand{\stdout}[1]{\verb"#1"}

\else
%%%% LATEX ONLY

\usepackage{tocloft}
\usepackage{fancyhdr}
\usepackage[totoc]{idxlayout}

\usepackage{geometry}
\geometry{
    width=5.5in,
    height=8.5in,
    hmarginratio=3:2,
    vmarginratio=1:1,
    includehead=true,
    headheight=15pt
}

% paragraph spacing
\setlength{\parindent}{0pt}                      % 17.62482pt
\setlength{\parskip}{12pt plus 4pt minus 4pt}    % 0.0pt plus 1.0pt
\linespread{1.05}
\def\arraystretch{1.5}

% list spacing
\setlength{\topsep}{5pt plus 2pt minus 3pt}      % 10.0pt plus 4.0pt minus 6.0pt
\setlength{\partopsep}{-6pt plus 2pt minus 2pt}  %  3.0pt plus 2.0pt minus 2.0pt
\setlength{\itemsep}{0pt}                        %  5.0pt plus 2.5pt minus 1.0pt

% these are copied from tex/latex/base/book.cls
% all I changed is afterskip
\makeatletter
\renewcommand{\section}{\@startsection {section}{1}{\z@}%
    {-3.5ex \@plus -1ex \@minus -.2ex}%
    {0.7ex \@plus.2ex}%
    {\normalfont\Large\bfseries}}
\renewcommand\subsection{\@startsection{subsection}{2}{\z@}%
    {-3.25ex\@plus -1ex \@minus -.2ex}%
    {0.3ex \@plus .2ex}%
    {\normalfont\large\bfseries}}
\renewcommand\subsubsection{\@startsection{subsubsection}{3}{\z@}%
    {-3.25ex\@plus -1ex \@minus -.2ex}%
    {0.3ex \@plus .2ex}%
    {\normalfont\normalsize\bfseries}}
\makeatother

% table of contents vertical spacing
\setlength\cftparskip{8pt plus 4pt minus 4pt}

% The following line adds a little extra space to the column
% in which the Section numbers appear in the table of contents
\makeatletter
\renewcommand{\l@section}{\@dottedtocline{1}{1.5em}{3.0em}}
\makeatother

% customize page headers
\pagestyle{fancyplain}
\renewcommand{\chaptermark}[1]{\markboth{Chapter \thechapter ~~ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection ~~ #1}}
\lhead[\fancyplain{}{\bfseries\thepage}]%
      {\fancyplain{}{\bfseries\rightmark}}
\rhead[\fancyplain{}{\bfseries\leftmark}]%
      {\fancyplain{}{\bfseries\thepage}}
\cfoot{}
%\rfoot{\textcolor{gray}{\tiny ThinkJava Draft \today}}

%% tweak spacing of figures and captions
%\usepackage{floatrow}
%\usepackage{caption}
%\captionsetup{
%    font=small,
%    labelformat=empty,
%    justification=centering,
%    skip=4pt
%}

% colors for code listings and output
\usepackage{xcolor}
\definecolor{bgcolor}{HTML}{FAFAFA}
\definecolor{comment}{HTML}{007C00}
\definecolor{keyword}{HTML}{0000FF}
\definecolor{strings}{HTML}{B20000}

% syntax highlighting in code listings
\usepackage{textcomp}
\usepackage{listings}
\lstset{
    language=java,
    basicstyle=\ttfamily,
    backgroundcolor=\color{bgcolor},
    commentstyle=\color{comment},
    keywordstyle=\color{keyword},
    stringstyle=\color{strings},
    columns=fullflexible,
    keepspaces=true,
    showstringspaces=false,
    upquote=true,
    aboveskip=\parskip,
    belowskip=\parskip
}

% code listing environments
\lstnewenvironment{code}
{\minipage{\linewidth}}
{\endminipage}
\lstnewenvironment{stdout}
{\lstset{commentstyle=,keywordstyle=,stringstyle=}\minipage{\linewidth}}
{\endminipage}

% pdf hyperlinks, table of contents, and document properties
\usepackage[pdftex]{hyperref}
\hypersetup{%
  pdftitle={\thetitle},
  pdfauthor={\theauthors},
  pdfsubject={\theversion},
  pdfkeywords={},
  bookmarksopen=false,
  colorlinks=true,
  citecolor=black,
  filecolor=black,
  linkcolor=black,
  urlcolor=blue
}

% inline syntax formatting
\newcommand{\java}[1]{\lstinline{#1}} %\end{

% END OF LATEX ONLY
\fi


%% END OF PREAMBLE

\begin{document}

\frontmatter


\ifplastex
%PLASTEX ONLY
    \maketitle

\else
%LATEX ONLY

%--title page--------------------------------------------------
\pagebreak
\thispagestyle{empty}

\begin{flushright}
\vspace*{2.0in}

{\huge Think Java}

\vspace{0.25in}
{\LARGE How to Think Like a Computer Scientist}

\vspace{1in}
{\Large \theauthors}

\vspace{1in}
{\large \theversion}

\vfill

\end{flushright}

%--copyright--------------------------------------------------
\pagebreak
\thispagestyle{empty}

Copyright \copyright ~2016 Allen Downey and Chris Mayfield.

{\bf NOTE: This version of the book is a work in progress and won't be completed until February 2016.}

\vspace{0.25in}

Permission is granted to copy, distribute, transmit, and adapt this work under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License: \url{http://creativecommons.org/licenses/by-nc-sa/3.0/}

The original form of this book is \LaTeX\ source code.
Compiling the \LaTeX\ source has the effect of generating a device-independent representation of the book, which can be converted to other formats and printed.

The \LaTeX\ source for this book is available from \url{http://thinkjava.org}.
%-----------------------------------------------------------------

%\input{todo-tex/preface.tex}

% table of contents
\cleardoublepage
\setcounter{tocdepth}{1}
\tableofcontents

%%%% END OF LATEX ONLY
\fi


\mainmatter


\chapter{The way of the program}

The goal of this book is to teach you to think like a computer scientist.
This way of thinking combines some of the best features of mathematics, engineering, and natural science.
Like mathematicians, computer scientists use formal languages to denote ideas (specifically computations).
Like engineers, they design things, assembling components into systems and evaluating trade-offs among alternatives.
And like scientists, they observe the behavior of complex systems, form hypotheses, and test predictions.
\index{problem-solving}

The single most important skill for a computer scientist is {\bf problem-solving}.
It involves the ability to formulate problems, think creatively about solutions, and express solutions clearly and accurately.
As it turns out, the process of learning to program is an excellent opportunity to develop problem-solving skills.
That's why this chapter is called, ``The way of the program.''

On one level you will be learning to program, a useful skill by itself.
But on another level you will use programming as a means to an end.
As we go along, that end will become clearer.
Learning how to think in terms of computation is much more valuable than simply learning how to write code.


\section{What is programming?}

\index{program}
A {\bf program} is a sequence of instructions that specifies how to perform a computation.
%\footnote{This definition does not apply to all programming languages; for alternatives, see \url{http://en.wikipedia.org/wiki/Declarative_programming}.}
The computation might be something mathematical, like solving a system of equations or finding the roots of a polynomial.
It can also be a symbolic computation, like searching and replacing text in a document or (strangely enough) compiling a program.
The details look different in different languages, but a few basic instructions appear in just about every language.

\begin{description}
\item[input:] Get data from the keyboard, a file, a sensor, or some other device.
\item[output:] Display data on the screen or send data to a file or other device.
\item[math:] Perform basic mathematical operations like addition and division.
\item[decisions:] Check for certain conditions and execute the appropriate code.
\item[repetition:] Perform some action repeatedly, usually with some variation.
\end{description}

\index{programming}

Believe it or not, that's pretty much all there is to it.
Every program you've ever used, no matter how complicated, is made up of instructions that look much like these.
So you can think of {\bf programming} as the process of breaking down a large, complex task into smaller and smaller subtasks.
The process continues until the subtasks are simple enough to be performed with the basic instructions provided by computer hardware.


\section{What is computer science?}

One of the most interesting aspects of writing programs is deciding how to solve a particular problem, especially when there are multiple solutions.
For example, there are numerous ways to sort a list of numbers, and each way has its advantages (see \url{http://www.sorting-algorithms.com/}).
In order to determine which way is best for a given situation, we need techniques for describing and analyzing solutions formally.
That is where computer science comes in.

\index{computer science}
\index{algorithm}

Put simply, {\bf computer science} is the science of algorithms, including their discovery and analysis.
An {\bf algorithm} is a sequence of steps that specify exactly how to solve a problem.
Some algorithms are better than others in terms of how long they take or how much memory they use.
As you learn to develop algorithms for problems you haven't solved before, you also learn to think like a computer scientist.
%It's much more fun to discover new algorithms than to write the code for solutions that other people came up with!

\index{bug}
\index{debugging}

Designing algorithms and writing code is difficult and error-prone.
For historical reasons, programming errors are called {\bf bugs}, and the process of tracking them down and correcting them is called {\bf debugging}.
As you learn to debug your programs, you will develop new problem-solving skills.
You will need to think creatively when unexpected errors happen.

%In the old days, computer scientists had to deal with real bugs flying into their systems.
%You probably won't have that problem, but you will need to think creatively when unexpected errors happen.

%\begin{figure}[!h]
%\begin{center}
%\includegraphics[height=2.2in]{figs/firstbug.jpg}
%\caption{The first computer bug, taped to Grace Hopper's log book in 1947.
%\\ She discovered the moth in an electromagnetic relay of the Mark II.}
%\end{center}
%\end{figure}

% ABD: I don't love this particular piece of mythology, partly because it's not accurate, and partly because stories about the old days bore students.

Although it can be frustrating, debugging is an intellectually rich, challenging, and interesting part of computer programming.
In some ways, debugging is like detective work.
You are confronted with clues, and you have to infer the processes and events that led to the results you see.
Thinking about how to correct programs and improve their performance sometimes even leads to the discovery of new algorithms.


\section{Introduction to Java}

\index{high-level language}
\index{language!high-level}

The programming language you will learn is Java, which is relatively new (Sun released the first version in May 1995).
Java is an example of a {\bf high-level language}.
Other high-level languages you may have heard of include C and C++, JavaScript, Python, Ruby, and Visual Basic.

\index{low-level language}
\index{language!low-level}

There are also {\bf low-level languages}, sometimes referred to as ``machine languages'' or ``assembly languages.''
Loosely speaking, computers can only run programs written in low-level languages.
So programs written in a high-level language have to be translated before they can run.
This translation takes some time, which is a small disadvantage of high-level languages.
But the advantages of high-level languages are enormous.
As a result, low-level languages are only used for programs that need to interact directly with hardware.

\index{portable}

Due to the advantages, almost all programs are written in high-level languages.
First, it is {\em much} easier to program in a high-level language.
Programs take less time to write, are shorter and easier to read, and are more likely to be correct.
Second, high-level languages are {\bf portable}, meaning that they can run on different kinds of computers with few or no modifications.
Low-level programs can only run on one kind of computer, and have to be rewritten to run on another.

\index{interpreter}

Two kinds of programs translate high-level languages into low-level languages: interpreters and compilers.
An {\bf interpreter} reads a high-level program and executes it, meaning that it does what the program says.
It processes the program a little at a time, alternately reading lines and performing computations.
% Figure 1.1 shows the structure of an interpreter.

\begin{figure}[!h]
\begin{center}
\includegraphics{figs/interpreter.pdf}
\caption{How interpreted languages like Python and Ruby are executed.}
\end{center}
\end{figure}

\index{compiler}
\index{source code}
\index{object code}
\index{executable}

In contrast, a {\bf compiler} reads the entire program and translates it completely before the program starts running.
In this context, the high-level program is called the {\bf source code}, and the translated program is called the {\bf object code} or the {\bf executable}.
Once a program is compiled, you can execute it repeatedly without further translation.
As a result, compiled programs often run faster than interpreted programs.
% Figure 1.2 shows the structure of a compiler.

\index{byte code}

Java is {\em both} compiled and interpreted.
Instead of translating programs directly into machine language, the Java compiler generates {\bf byte code}.
Similar to machine language, byte code is easy (and fast) to interpret.
But it is also portable, like a high-level language.
Thus it is possible to compile a Java program on one machine, transfer the byte code to another machine, and then execute (interpret) the byte code on the other machine.
%This ability is an advantage of Java over some other high-level languages.

\begin{figure}[!h]
\begin{center}
\includegraphics{figs/compiler.pdf}
\caption{The process of editing, compiling, and running a Java program.}
\end{center}
\end{figure}

Although this process may seem complicated, in most program development environments these steps are automated for you.
Usually you will only have to write a program and press a button or type a single command to compile and run it.
On the other hand, it is important to know what steps are happening in the background, so if something goes wrong you can figure out what it is.


\section{Formal languages}

\index{natural language}
\index{language!natural}

Learning a programming language is very different from learning a {\bf natural language} such as English, Spanish, or German.
The languages that people speak evolved naturally over time.
%They were not designed by people, although we try to impose order on them for practical reasons.

\index{formal language}
\index{language!formal}

In contrast, {\bf formal languages} are designed by people for specific applications.
For example, the notation that mathematicians use is a formal language that is particularly good at denoting relationships among numbers and symbols.
Chemists use a formal language to represent the chemical structure of molecules.
And most importantly:

\index{programming language}
\index{language!programming}

\begin{quote}
{\bf Programming languages are formal languages that have been designed to express computations.}
\end{quote}

\index{syntax}
\index{semantics}

Formal languages have strict rules about both the {\bf syntax} (structure) and the {\bf semantics} (meaning) of statements.
For example, $3 + 3 = 6$ is a syntactically correct mathematical statement, but $3\ + = 3\ \$\ 6$ is not.
$1 + 2 = 4$ uses correct syntax, but is semantically incorrect.
$H_2O$ is a syntactically correct chemical formula, but $_2Zz$ is not.

%\subsection{Tokens and grammar}

\index{token}

Syntax rules come in two flavors, pertaining to tokens and grammar.
{\bf Tokens} are the basic elements of the language, like words, numbers, and chemical elements.
One of the problems with $3\ + = 3\ \$\ 6$ is that $\$$ is not a legal token in mathematics.
Similarly, $_2Zz$ is not legal because there is no element with the abbreviation $Zz$.

\index{grammar}

The second type of syntax rule pertains to the {\bf grammar} of the language, or the way tokens can be arranged.
The statement $3\ + = 3$ is structurally illegal, even though $+$ and $=$ are legal tokens, because you can't have one right after the other.
Similarly, in a chemical formula the subscript comes after the element name, not before.

\index{parse}

When you read a sentence in English or a statement in a formal language, you have to figure out its structure.
This process is called {\bf parsing}, and in a natural language you learn to do it unconsciously.
As you learn to program, you will learn to parse Java code.

%For example, when you hear the statement ``the penny dropped,'' you understand that the penny is the subject and ``dropped'' is the predicate.
%After you have parsed the statement, you can begin to figure out what it means.
%Assuming that you know what a penny is and what it means to drop, you will understand the general implication of this statement.

%\subsection{Reading source code}


Beginning programmers, who are used to natural languages, often have a hard time adjusting to formal languages.
Although formal and natural languages have features in common---tokens, grammar, and meaning---there are some differences:

\begin{description}

\term{ambiguity}
Natural languages are full of ambiguity, which people deal with by using contextual clues and other information.
Formal languages are designed to be nearly or completely unambiguous, which means that any statement has exactly one meaning, regardless of context.

\term{redundancy}
In order to make up for ambiguity and reduce misunderstandings, natural languages employ lots of redundancy.
As a result, they are often verbose.
Formal languages are less redundant and more concise.

\term{literalness}
Natural languages are full of idiom and metaphor.
When someone says ``the penny dropped'' there is no penny and nothing dropping.
This idiom means that someone finally realized something after a period of confusion.
In contrast, formal languages mean exactly what they say.

\end{description}

%In some ways, the difference between natural and formal language is like the difference between poetry and prose, but more so.

%\begin{description}

%\term{poetry}
%Words are used for their sounds as well as for their meaning, and the whole poe%m together creates an effect or emotional response.
%Ambiguity is not only common but often deliberate.

%\term{prose}
%The literal meaning of words is more important, and the structure contributes more meaning.
%Prose is more amenable to analysis than poetry but still often ambiguous.

%\term{program}
%The meaning of a computer program is unambiguous and literal, and can be understood entirely by analysis of the tokens and grammar.

%\end{description}

%Here are some suggestions for reading programs (and other formal languages).

Small errors in spelling and punctuation, which you can get away with in natural languages, can make a big difference in a formal language.

Also, formal languages are more dense than natural languages, so it takes longer to read them.
The structure is very important, so it is not always a good idea to read from top to bottom, left to right.
Over time you will learn to parse programs in your head, identifying the tokens and interpreting the structure.
And you will learn to read and write programs more quickly.



\section{The hello world program}
\label{sec:hello}

\index{hello world}

Traditionally, the first program you write when learning a new programming language is called the hello world program.
All it does is display the words ``Hello, World!''\ on the screen.
In Java, it looks like this:

\begin{code}
public class Hello {

    public static void main(String[] args) {
        // generate some simple output
        System.out.println("Hello, World!");
    }

}
\end{code}

Note the output of this program does not include the quote marks:

\begin{stdout}
Hello, World!
\end{stdout}

\index{public}
\index{static}

Unfortunately in Java, even this simple example requires language features that are difficult to explain to beginners.
But it provides a preview of topics that we will see in detail later on.
The word \java{public} means the code can be accessed from other source files.
The word \java{static} means that memory is allocated for the program in advance.
We will discuss \java{void}, \java{String}, and \java{args} in the next few chapters.
For now, let's focus on the overall structure.

\index{class!definition}
\index{method!definition}

Java programs are made up of {\bf class} and {\bf method} definitions, which generally have the form:

\begin{code}
public class CLASSNAME {

    METHOD {
        STATEMENTS
    }

    METHOD {
        STATEMENTS
    }

}
\end{code}

\index{class!name}

Here \java{CLASSNAME} indicates the name chosen by the programmer.
Java requires the class name to match the source file name.
In the hello world example, the file name must be {\tt Hello.java} because the class name is \java{Hello}.

\index{statement}
\index{main}

Classes define a program's methods, or named sequences of {\bf statements}.
The \java{Hello} class has only one method:

\begin{code}
    public static void main(String[] args)
\end{code}

The name and format of \java{main} is special; it marks the place in the class where execution begins.
When the program runs, it starts at the first statement in \java{main} and ends when it finishes the last statement.

\index{braces}
\index{squiggly braces}

Java uses squiggly braces (\{ and \}) to group things together.
In {\tt Hello.java}, the outermost braces (lines 1 and 8) contain the class definition, and the inner braces (lines 3 and 6) contain the definition of \java{main} method.

% ABD: It looks like we don't have line numbers in the listings.
% Is that a problem for the text here?

\index{println}
\index{statement!print}

The main method can have any number of statements, but the \java{Hello} example has only one.
It is a {\bf print statement}, meaning that it displays a message on the screen.
Confusingly, print can mean both ``display something on the screen'' and ``send something to the printer.''
%I won't say much about sending things to the printer;
In this book, we'll do all our printing on the screen.
The print statement ends with a semicolon (\java{;}).

\index{comments!inline}
\index{statement!comment}

Line 4 contains a {\bf comment}, or a bit of English text that explains the code that follows.
When the compiler sees \java{//}, it ignores everything from there until the end of the line.
It is a good idea to write a comment before every major block of code so that other programmers (including your future self) can understand what you meant to do.


\section{Setting up a programming environment}

\index{JDK}

In order to compile Java programs on your own computer, you will need to install the Java Development Kit (JDK).
This free software by Oracle includes tools for developing and debugging Java programs.
All the examples in this book were developed and tested using Java SE Version 7.
If you are using a more recent version, the examples in this book should still work.
If you are using an older version, a few of them might not.

\begin{figure}[!h]
\begin{center}
\includegraphics[width=\textwidth]{figs/drjava-hello.png}
\caption{Screenshot of DrJava editing the hello world program.}
\end{center}
\end{figure}

\index{DrJava}

We will use DrJava as the primary development environment throughout the book.
A useful feature of DrJava is the Interactions Pane at the bottom of the window.
It provides the ability to try out code quickly, without having to write a class definition and save/compile/run the program.
Refer to the DrJava documentation (\url{http://drjava.org/docs/quickstart/}) for more details.

Step-by-step instructions for installing the JDK and configuring DrJava are available on this book's website: \url{http://thinkjava.org/}

% TODO: when we have the specific URL for the install page, let's put it here.

\subsection{Command-line interface}

\index{command-line}
\index{terminal}

One of the most powerful and useful skills you can learn is how to use the {\bf command-line interface}, also called the {\em terminal}.
The command line is a direct interface to the operating system.
It allows you to run programs, manage files and directories, and monitor system resources.
Many advanced tools, both for software development and general purpose computing, are available only at the command line.

There are many good tutorials online for learning the command-line for your operating system; just search the web for ``command line tutorial.''
To get started, you only need to know four commands: how to change the working directory ({\tt cd}), list directory contents ({\tt ls}), compile Java programs ({\tt javac}), and run Java programs ({\tt java}).

% ABD: There's a conflict here between ``Find the details for your system'' and ``Here are the UNIX commands''.

\begin{figure}[!h]
\begin{center}
\includegraphics[width=4.5in]{figs/terminal.png}
\caption{Compiling and running {\tt Hello.java} from the command line.}
\end{center}
\end{figure}

In this example, the {\tt Hello.java} source file is stored in the {\tt Desktop} directory.
After changing to that location and listing the files, we use the {\tt javac} command to compile {\tt Hello.java}.
Running {\tt ls} again, we see that the compiler generated a new file, {\tt Hello.class}, which contains the byte code.
We run the program using the {\tt java} command, which displays the output on the following line.

Note that the {\tt javac} command requires a {\em file name} (or multiple source files separated by spaces), whereas the {\tt java} command requires a single {\em class name}.
If you use DrJava, it runs these commands for you and displays the output in the Interactions Pane.

Taking time to learn this efficient and elegant way of interacting with your operating system will make you more productive.
People who don't use the command line don't know what they're missing.

% ABD: Maybe add a reference to Neal Stephenson's book?


\section{Printing strings}

You can put as many statements as you want in \java{main}.
For example, to print more than one line:

\begin{code}
public class Hello {

    public static void main(String[] args) {
        // generate some simple output
        System.out.println("Hello, World!");  // print one line
        System.out.println("How are you?");   // print another
    }

}
\end{code}

As this program demonstrates, you can put comments at the end of a line as well as on lines all by themselves.

\index{String}
\index{type!String}

Phrases that appear in quotation marks are called {\bf strings}, because they contain a sequence of characters strung together.
Strings can contain any combination of letters, numbers, punctuation marks, symbols, and even non-printable characters like tab and backspace.

\index{newline}
\index{print}
\index{statement!print}

The name \java{println} is short for ``print line.''
It appends a special character, called a {\bf newline}, that advances the cursor to the beginning of the next line.
%The next time \java{println} is invoked, the new text appears on the next line.
To display the output from multiple print statements on one line, use \java{print}:

\begin{code}
public class Goodbye {

    public static void main(String[] args) {
        System.out.print("Goodbye, ");
        System.out.println("cruel world");
    }

}
\end{code}

The output appears on a single line as {\tt Goodbye, cruel world}.
Notice that there is a space between the word ``Goodbye'' and the second quotation mark.
This space appears in the output, so it affects the {\em behavior} of the program.

\subsection{Code formatting}
\label{sec:formatting}

Spaces that appear outside of quotation marks generally do not affect the behavior of the program.
For example, we could have written:

\begin{code}
public class Goodbye {
public static void main(String[] args) {
System.out.print("Goodbye, ");
System.out.println("cruel world");
}
}
\end{code}

This program would compile and run just as well as the original.
The newlines at the end of each line do not affect the program's behavior either.
So we could have also written:

\begin{code}
public class Goodbye { public static void main(String[] args) {
System.out.print("Goodbye, "); System.out.println
("cruel world");}}
\end{code}

It still works, but the program is getting harder and harder to read.
Newlines and spaces are important for organizing your program visually, making it easier to understand the program and find errors when they occur.
%Formatting your code well does not take much effort, and it pays huge dividends.
%We will discuss readability and style guidelines in the next chapter.

\subsection{Escape sequences}

It is possible to print multiple lines of output in just one line of code.
You just have to tell Java where to put the line breaks.

\begin{code}
public class Hello {

    public static void main(String[] args) {
        System.out.print("Hello!\nHow are you doing?\n");
    }

}
\end{code}

The output is two lines, each ending with a newline character:

\begin{stdout}
Hello!
How are you doing?
\end{stdout}

\index{escape sequence}

The code \verb"\n" is an {\bf escape sequence}, which is a sequence of characters in a string that represents a special character.
The backslash allows you to ``escape'' the string's literal interpretation.
Notice there is no space between \verb"\n" and \verb"How".
If you add a space there, there will be a space at the beginning of the second line.

\begin{table}[!h]
\begin{center}
\begin{tabular}{|c|c|}
\hline
\verb"\n" & newline \\
\hline
\verb"\t" & tab \\
\hline
\verb'\"' & double quote \\
\hline
\verb"\\" & backslash \\
\hline
\end{tabular}
\caption{Common escape sequences}
\end{center}
\end{table}

Another common use of escape sequences is to have quote marks inside of strings.
Since double quotes indicate the beginning and end of strings, you need to escape them with a backslash.

\begin{code}
    System.out.println("She said \"Hello!\" to me.");
\end{code}

The result is:

\begin{stdout}
She said "Hello!" to me.
\end{stdout}


\section{Debugging}
\label{sec:examples}

It is a good idea to read this book in front of a computer so you can try out the examples as you go.
You can run many of the examples directly in DrJava's Interactions Pane, but if you put the code in a source file, it will be easier to try out variations.

Whenever you are experimenting with a new feature, you should also try to make mistakes.
For example, in the hello world program, what happens if you leave out one of the quotation marks?
What if you leave out both?
What if you spell \java{println} wrong?
This kind of experiment helps you remember what you read.
It also helps with debugging, because you get to know what the error messages mean.
It is better to make mistakes now and on purpose than later on and accidentally.

\index{experimental debugging}
\index{debugging!experimental}

%\index{Holmes, Sherlock}
%\index{Doyle, Arthur Conan}

Debugging is like an experimental science.
Once you have an idea about what is going wrong, you modify your program and try again.
If your hypothesis was correct, then you can predict the result of the modification, and you take a step closer to a working program.
If your hypothesis was wrong, you have to come up with a new one.
%As Sherlock Holmes pointed out, ``When you have eliminated the impossible, whatever remains, however improbable, must be the truth.''
%(A.~Conan Doyle, {\em The Sign of Four}.)

Programming and debugging should go hand in hand.
Don't just write a bunch of code and then perform trial and error debugging until it all works.
Instead, start with a program that does {\em something} and make small modifications, debugging them as you go, until the program does what you want.
That way you will always have a working program, and it will be easier to isolate errors.

\index{Linux}
\index{Torvalds, Linus}
\index{Greenfield, Larry}

A great example of this principle is the Linux operating system, which contains millions of lines of code.
It started out as a simple program Linus Torvalds used to explore the Intel 80386 chip.
According to Larry Greenfield, ``One of Linus's earlier projects was a program that would switch between printing AAAA and BBBB.
This later evolved to Linux.'' ({\em The Linux Users' Guide})

%Later chapters will make more suggestions about debugging and other programming practices.

Finally, programming sometimes brings out strong emotions.
If you are struggling with a difficult bug, you might feel angry, despondent, or embarrassed.
Remember that you are not alone, and most if not all programmers have had similar experiences.
Don't hesitate to reach out to a friend and ask questions!

%\index{emotional debugging}
%\index{debugging!emotional response}

%There is evidence that people naturally respond to computers as if they were people.
%When they work well, we think of them as teammates, and when they are obstinate or rude, we respond to them the same way we respond to rude, obstinate people.
%(Reeves and Nass, {\it The Media Equation: How People Treat Computers, Television, and New Media Like Real People and Places})

%Preparing for these reactions might help you deal with them.
%One approach is to think of the computer as an employee with certain strengths, like speed and precision, and particular weaknesses, like lack of empathy and inability to grasp the big picture.

%Your job is to be a good manager: find ways to take advantage of the strengths and mitigate the weaknesses.
%And find ways to use your emotions to engage with the problem, without letting your reactions interfere with your ability to work effectively.

%Learning to debug can be frustrating, but it is a valuable skill that is useful for many activities beyond programming.
%At the end of each chapter there is a debugging section, like this one, with my thoughts about debugging.
%I hope they help!


\section{Vocabulary}

Throughout the book, we try to define each term the first time we use
it.
And the end of each chapter, we include the new terms and their definitions.
If you spend some time learning this vocablary, you will have an easier time reading the following chapters.

\begin{description}

\term{problem-solving}
The process of formulating a problem, finding a solution, and expressing the solution.

\term{program}
A sequence of instructions that specify how to perform tasks on a computer.

\term{programming}
The application of problem-solving to creating executable computer programs.

\term{computer science}
The scientific and practical approach to computation and its applications.

\term{algorithm}
A procedure or formula for solving a problem, with or without a computer.

\term{bug}
An error in a program.

\term{debugging}
The process of finding and removing any of the three kinds of errors.

\term{high-level language}
A programming language that is designed to be easy for humans to read and write.

\term{low-level language}
A programming language that is designed to be easy for a computer to run.
Also called ``machine language'' or ``assembly language.''

\term{portable}
The ability of a program to run on more than one kind of computer.

\term{interpret}
To run a program in a high-level language by translating it one line at a time and immediately executing the corresponding instructions.

\term{compile}
To translate a program in a high-level language into a low-level language, all at once, in preparation for later execution.

\term{source code}
A program in a high-level language, before being compiled.

\term{object code}
The output of the compiler, after translating the program.

\term{executable}
Another name for object code that is ready to run on specific hardware.

\term{byte code}
A special kind of object code used for Java programs.
Byte code is similar to a low-level language, but it is portable like a high-level language.

\term{natural language}
Any of the languages people speak that have evolved naturally.

\term{formal language}
A language people have designed for specific purposes, like representing mathematical ideas or computer programs.

\term{programming language}
A formal language that has been designed to express computations.

\term{syntax}
The structure of a program.

\term{semantics}
The meaning of a program.

\term{token}
A basic element of a program, such as a word, space, symbol, or number.

\term{grammar}
A set of rules that determines whether a statement is legal.

\term{parse}
To examine a program and analyze the syntactic structure.

\term{statement}
A part of a program that specifies a computation.

\term{method}
A named sequence of statements.

\term{class}
For now, a collection of related methods. (We will see later that there is more to it.)

\term{print statement}
A statement that causes output to be displayed on the screen.

\term{comment}
A part of a program that contains information about the program but has no effect when the program runs.

\term{command-line}
A means of interacting with the computer by issuing commands in the form of successive lines of text.

\term{string}
A sequence of characters; the primary data type for text.

\term{newline}
A special character signifying the end of a line of text.
Also known as line ending, end of line (EOL), or line break.

\term{escape sequence}
A sequence of code that represents a special character when used inside a string.

\end{description}


\section{Exercises}

At the end of each chapter we include exercises you can do with the things you've learned.
We encourage you to at least attempt every problem.
You can't learn to program by reading along; you have to practice.

\begin{exercise}

Computer scientists have the annoying habit of using common English words to mean something other than their common English meaning.
For example, in English, statements and comments are the same thing, but in programs they are different.

The glossary at the end of each chapter is intended to highlight words and phrases that have special meanings in computer science.
When you see familiar words, don't assume that you know what they mean!

\begin{enumerate}
\item In computer jargon, what's the difference between a statement and a comment?
\item What does it mean to say that a program is portable?
\item What is an executable?
\end{enumerate}

\end{exercise}


\begin{exercise}

Before you do anything else, find out how to compile and run a Java program in your environment.
Some environments provide sample programs similar to the example in Section~\ref{sec:hello}.

\begin{enumerate}
\item Type in the ``Hello, world'' program, then compile and run it.

\item Add a print statement that prints a second message after the ``Hello, world!''.
Say something witty like, ``How are you?''
Compile and run the program again.

\item Add a comment to the program (anywhere), recompile, and run it again.
The new comment should not affect the result.
\end{enumerate}

This exercise may seem trivial, but it is the starting place for many of the programs we will work with.
To debug with confidence, you have to have confidence in your programming environment.
In some environments, it is easy to lose track of which program is executing.
You might find yourself trying to debug one program while you are accidentally running another.
Adding (and changing) print statements is a simple way to be sure that the program you are looking at is the program you are running.

\end{exercise}


\begin{exercise}

It is a good idea to commit as many errors as you can think of, so that you see what error messages the compiler produces.
Sometimes the compiler tells you exactly what is wrong, and all you have to do is fix it.
But sometimes the error messages are misleading.
You will develop a sense for when you can trust the compiler and when you have to figure things out yourself.

\begin {enumerate}
\item Remove one of the open squiggly-braces.
\item Remove one of the close squiggly-braces.
\item Instead of \java{main}, write \java{mian}.
\item Remove the word \java{static}.
\item Remove the word \java{public}.
\item Remove the word \java{System}.
\item Replace \java{println} with {Println}.
\item Replace \java{println} with {print}.
This one is tricky because it is a logic error, not a syntax error.
The statement \java{System.out.print} is legal, but it may or may not do what you expect.
\item Delete one of the parentheses.  Add an extra one.
\end {enumerate}

\end{exercise}


\chapter{Variables and arithmetic}

This chapter is about storing values in computer memory and doing basic arithmetic.
More importantly, it discusses how to {\em compose} statements using smaller building blocks such as variables and operators.
We also discuss code quality, which is almost as important as correctness.
High quality code is easier to read, which makes it easier to maintain and debug.

%For better or worse, Java performs some conversions automatically when you have different types of data in the same statement.
%Following style guidelines helps you to avoid common programming mistakes that are difficult to debug.


\section{Types of errors}

\index{error!message}

%As you begin writing your own programs, you will encounter various error messages.
Three kinds of errors can occur in a program: syntax errors, runtime errors, and logic errors.
It is useful to distinguish between them in order to track them down more quickly.
Regardless of what type of error occurs, remember to {\em read and think about the error messages carefully}.
They will usually point you in the right direction to fix your program.

\subsection{Syntax errors}

\index{syntax error}
\index{error!syntax}

The compiler can only translate a program if the syntax is correct; otherwise, it fails and displays an error message.
For example, parentheses have to come in matching pairs.
So \java{(1 + 2)} is legal, but \java{8)} is a {\bf syntax error}.

In English, readers can tolerate most syntax errors, which is why we can read the poetry of E.\ E.\ Cummings without spewing error messages.
Java is not so forgiving; if there is a single syntax error anywhere in your program, the compiler will display an error message and quit, and you will not be able to run the program.

\begin{figure}[!h]
\begin{center}
\includegraphics[width=\textwidth]{figs/syntax-error.png}
\caption{A syntax error caused by a missing brace.}
\label{fig:syntax}
\end{center}
\end{figure}

To make matters worse, the error messages you get from the compiler are often not very helpful.
As shown in Figure~\ref{fig:syntax}, removing the closing brace on line 8 of the hello world program results in ``Error: reached end of file while parsing.''
The compiler also reports that the problem was found on line 6, which in this case is not at fault.
Since line 8 was deleted, the compiler simply reported the last line of the file.

During the first few weeks of your programming career, you will probably spend a lot of time tracking down syntax errors.
But as you gain experience, you will make fewer mistakes and find them more quickly.

\subsection{Runtime errors}

\index{runtime error}
\index{error!runtime}
%\index{type-safe}
%\index{language!type-safe}

The second type of error is a {\bf runtime error}, so called because it does not appear until after the program has started running.
In Java, these errors occur when the interpreter is executing the byte code and something goes wrong.
%Java is designed to be a {\bf type-safe} language, which means that the compiler can detect many potential errors cased by common programming mistakes.
Runtime errors are rare in the simple programs you will see in the first few chapters, so it might be a while before you encounter one.

\index{exception}

These errors are also called {\em exceptions} because they usually indicate that something exceptional (and bad) has happened.
In most environments they appear as windows or dialog boxes that contain information about what happened and what the program was doing when it happened.
For example, if you accidentally divide by zero you will get an \java{ArithmeticException}:

\begin{small}
\begin{stdout}
Exception in thread "main" java.lang.ArithmeticException: / by zero
    at Hello.main(Hello.java:5)
\end{stdout}
\end{small}

This information is useful for debugging.
The first line gives a brief description of the error (/ by zero).
The subsequent lines report the class and method names (Hello.main), along with the file name and line number where the error occurred (Hello.java:5).
Keep in mind that the line where the program crashed may not be the line that needs to be fixed.

\subsection{Logic errors}

\index{logic error}
\index{error!logic}

The third type of error is the {\bf logic error}.
If there is an error in your program's logic, it will compile and run successfully in the sense that the computer will not generate any error messages.
But it will not do the right thing.
It will do something else.
Specifically, it will do what you told it to do.
Here is an example of a logic error in the hello world program:

\begin{code}
public class Hello {

    public static void main(String[] args) {
        System.out.println("Goodbye, world.");
    }

}
\end{code}

This program compiles and runs just fine.
The problem is that the main method is not the program we intended.
The meaning of the program is wrong, because it says goodbye instead of hello.
In addition, world is not capitalized, and it ends with a period instead of an exclamation point.

Identifying logic errors can be tricky because it requires you to challenge your assumptions, both about the code and the requirements.
You will need to work backwards by looking at the output of the program, try to figure out what it is doing, and make sure you understand what it should be doing.


\section{Creating variables}

\index{variable}
\index{value}

One of the most powerful features of a programming language is the ability to define and manipulate {\bf variables}.
A variable is a named location of computer memory that stores a {\bf value}.
Values may be numbers, text, images, sounds, and other types of data.
%They can be printed, and as we'll see later, operated on.
To store a value in memory, you first have to create a variable.
%Since the values we want to store are text, we declare that the new variable is a string:

\begin{code}
    String message;
\end{code}

\index{declaration}
\index{statement!declaration}
\index{type!int}
\index{type!char}
\index{type!String}

This statement is a {\bf declaration}, because it declares that the variable named \java{message} has the type \java{String}.
Each variable has a {\bf type} that determines what kind of values it can store.
For example, the \java{int} type can store integers, and the \java{char} type can store characters.

Some types begin with a capital letter and some with lower-case.
We will learn the significance of this distinction later, but for now you should take care to get it right.
There is no such type as \java{Int} or \java{string}, and the compiler will complain if you make one up.

To declare an integer variable, the syntax is:

\begin{code}
    int x;
\end{code}

Note that \java{x} is an arbitrary name for the variable.
In general, you should use names that indicate what the variables mean.
For example, if you saw these variable declarations, you could probably guess what values would be stored in them:

\begin{code}
    String firstName;
    String lastName;
    int hour, minute;
\end{code}

This example also demonstrates the syntax for declaring multiple variables with the same type: \java{hour} and \java{minute} are both integers.
Note that each declaration statement ends with a semicolon.

You can use any name you want for a variable.
But there are certain words that are reserved in Java, because they are used by the compiler to parse the structure of the program.
These {\bf keywords} include \java{public}, \java{class}, \java{static}, \java{void}, \java{int}, and others (there are currently 50 in Java).
Search the Internet for ``Java keywords'' to see the complete list.

%The complete list is available at \url{https://docs.oracle.com/javase/tutorial/}.
%This site, provided by Oracle, includes Java documentation I refer to throughout the book.

Rather than memorize the keywords, you should take advantage of the syntax highlighting provided in many development environments (including DrJava).
As you type, the tokens in your program will appear in different colors.
For example, keywords might be blue, strings red, comments green, and other code black.
If you type a variable name and it turns blue, watch out!

\subsection{Assignment}

\index{assignment}
\index{statement!assignment}

Now that we have created variables, we want to store values.
We do that with an {\bf assignment} statement.

\begin{code}
    message = "Hello!";  // give message the value "Hello!"
    hour = 10;           // assign the value 10 to hour
    minute = 59;         // set minute to 59
    hour = 11;           // change the hour to 11
\end{code}

This example shows four assignments, and the comments illustrate different ways people sometimes talk about assignment statements.
The vocabulary can be confusing here, but the idea is straightforward:

\begin{itemize}
\item When you declare a variable, you create a named storage location.
\item When you make an assignment to a variable, you give it a value.
\item If you reassign the variable, its value changes.
\end{itemize}

As a general rule, a variable has to have the same type as the value you assign to it.
For example, you cannot store a \java{String} in \java{minute} or an integer in \java{message}.
We will see some examples that seem to break this rule, but we'll get to that later.

%On the other hand, that rule can be confusing.
%There are many ways that you can convert values from one type to another, and Java sometimes converts things automatically.
%For now you should remember the general rule, and we'll talk about exceptions later.

A common source of confusion is that some strings {\em look} like integers, but they are not.
For example, \java{message} can contain the string \java{"123"}, which is made up of the characters \java{'1'}, \java{'2'}, and \java{'3'}.
But that is not the same thing as the integer \java{123}.

\begin{code}
    message = "123";  // legal
    message = 123;    // not legal
\end{code}

\subsection{Memory diagrams}

\index{memory diagram}

A common way to represent variables on paper is to draw a box with the name of the variable on the outside and the value of the variable on the inside.
This diagram shows the effect of the four assignments in the previous section:

\begin{center}
\begin{tabular}{rl}
message & \framebox[2cm]{Hello!} \\
   hour & \framebox[1cm]{11} \\
 minute & \framebox[1cm]{59} \\
\end{tabular}
\end{center}

% ABD: In the hour box, consider showing 10 crossed out, followed by 11?

Each box represents the storage location that holds the variable's value.
Once declared, you cannot change the name of a variable, but you can change the value as many times as you like.
For example, \java{hour} was initially \java{10}, then reassigned to \java{11}.
The diagram shows only the final value.

%Since these locations can be anywhere in memory, we refer to them by the variable name.
%The storage location does not change; those memory cells are simply reused.


\section{Printing variables}
\label{sec:printvar}

You can display the value of a variable using \java{print} or \java{println}.
The following program declares a variable named \java{firstLine}, assigns it the value \java{"Hello, again!"}, and then prints that value.

\begin{code}
public class Hello {
    public static void main(String[] args) {
        String firstLine;
        firstLine = "Hello, again!";
        System.out.println(firstLine);
    }
}
\end{code}

When we talk about printing a variable, we generally mean printing the {\em value} of the variable.
To print the {\em name} of a variable, you have to put it in quotes.
%For example: \java{System.out.println("firstLine");}
For example, you can write:

\begin{code}
    String firstLine;
    firstLine = "Hello, again!";
    System.out.print("The value of firstLine is ");
    System.out.println(firstLine);
\end{code}

The output of this program is:

\begin{stdout}
The value of firstLine is Hello, again!
\end{stdout}

%The output does not contain quote marks around \java{Hello, again!}.
%Those quote marks were part of the source code, not the value.

The syntax for printing a variable is the same regardless of the variable's type.
For example:

\begin{code}
    int hour, minute;
    hour = 11;
    minute = 59;
    System.out.print("The current time is ");
    System.out.print(hour);
    System.out.print(":");
    System.out.print(minute);
    System.out.println(".");
\end{code}

The output of this program is:

\begin{stdout}
The current time is 11:59.
\end{stdout}

To output multiple values on the same line, it's common to use several \java{print} statements followed by a \java{println} at the end.
{\bf Don't forget the \java{println}!}
On many operating systems, the output from \java{print} is stored without being displayed until \java{println} is invoked, at which point the entire line is displayed at once.
If you omit the \java{println}, the program may display the stored output at unexpected times or even terminate without displaying anything.


\section{Arithmetic operators}
\label{sec:arithops}

%Recall that Java programs are organized into {\em classes}, each of which has one or more {\em methods}, each of which has one or more {\em statements}.
%Most statements consist of one or more {\bf expressions}.

\index{operator}

{\bf Operators} are symbols that represent computations like addition and multiplication.
%Most operators in Java do what you expect them to do, since they are common mathematical symbols.
For example, the operator for addition is \java{+}, subtraction is \java{-}, multiplication is \java{*}, and division is \java{/}.
%Variables are replaced with their values before the computation is performed.

The following program converts the time of day to minutes:

\begin{code}
    int hour, minute;
    hour = 11;
    minute = 59;
    System.out.print("Number of minutes since midnight: ");
    System.out.println(hour * 60 + minute);
\end{code}

\index{expression}

In this program, \java{hour * 60 + minute} is an {\bf expression}, which represents a single value to be computed.
When the program runs, each variable is replaced by its current value, and then the operators are applied.
The result is:

\begin{stdout}
Number of minutes since midnight: 719
\end{stdout}

Expressions are generally a combination of numbers, variables, and operators.
When complied and executed, they become a single value:

\begin{code}
    1 + 1     hour - 1     hour * 60 + minute     minute / 60
    2         11 - 1       11 * 60 + 59           59 / 60
              10           660 + 59               0
                           719
\end{code}

Addition, subtraction, and multiplication all do what you expect, but you might be surprised by division.
For example, the following lines try to compute the fraction of an hour that has elapsed:

\begin{code}
    System.out.print("Fraction of the hour that has passed: ");
    System.out.println(minute / 60);
\end{code}

But the program outputs:

\begin{stdout}
Fraction of the hour that has passed: 0
\end{stdout}

\index{division!integer}
\index{integer division}

This result often confuses people.
After all, the value of \java{minute} is 59, and 59 divided by 60 should be 0.98333, not 0.
The problem here is that Java performs {\em integer division}.
When the values being divided are integers, the result is also an integer.
Computer hardware is designed so that integer division always {\em rounds down}, even in cases like this one where the next integer is close.

One solution is to calculate a percentage rather than a fraction:

\begin{code}
    System.out.print("Percent of the hour that has passed: ");
    System.out.println(minute * 100 / 60);
\end{code}

The new output is:

\begin{stdout}
Percent of the hour that has passed: 98
\end{stdout}

Again the result is rounded down, but at least now it's approximately correct.
%To get a more precise answer, we can use a different type of variable that can store fractional values.


\section{Floating-point numbers}

\index{floating-point}
\index{double (floating-point)}
\index{type!double}

A more general solution is to use {\bf floating-point} numbers, which can represent fractions as well as integers.
%As the name implies, the decimal point floats around (i.e., you can have as many decimal places as you want).

In Java, the default floating-point type is called \java{double}, which is short for double-precision.
You can create \java{double} variables and assign values to them using the same syntax we used for the other types:

\begin{code}
    double pi;
    pi = 3.14159;
\end{code}

Although floating-point numbers are useful, they can be a source of confusion.
For example, Java distinguishes the integer value \java{1} from the floating-point value \java{1.0}, even though they seem to be the same number.
They belong to different data types, and strictly speaking, you are not allowed to make assignments between types.

The following is illegal because the variable on the left is an \java{int} and the value on the right is a \java{double}.

\begin{code}
    int x;
    x = 1.1;  // syntax error
\end{code}

But it is easy to forget this rule because in many cases Java {\em automatically} converts from one type to another:

\begin{code}
    double y;
    y = 1;  // bad style
\end{code}

The above example should be illegal, but Java allows it by converting the \java{int} value \java{1} to the \java{double} value \java{1.0} automatically.
This leniency is convenient, but it often causes problems for beginners. For example:

\begin{code}
    double y;
    y = 1 / 3;  // logic error
\end{code}

\index{division!integer}
\index{integer division}

You might expect the variable \java{y} to get the value \java{0.333333}, which is a legal floating-point value.
But instead it gets the value \java{0.0}.
The reason is that the expression on the right divides two integers.
So Java does {\em integer division}, which yields the \java{int} value \java{0}.
Converted to \java{double}, the final result is \java{0.0}.

One way to solve this problem (after you finally discover that bug) is to make the right-hand side a floating-point expression.
The following initializes \java{y} to \java{0.333333}, as expected:

\begin{code}
    double y;
    y = 1.0 / 3.0;  // correct
\end{code}

As a matter of style, you should always assign floating-point values to floating-point variables.
The compiler won't make you do it, but you never know when a bug like this one will come back and haunt you.


\section{Rounding errors}

%The operations we have seen so far---addition, subtraction, multiplication, and division---also work on floating-point values, although you might be interested to know that the underlying mechanism is completely different.
%In fact, most processors have special circuitry just for performing floating-point operations.

\index{rounding error}

On hardware, floating-point numbers are only {\it approximately} correct.
Some numbers, like reasonably-sized integers, can be represented exactly.
But repeating fractions, like $1/3$, and irrational numbers, like $\pi$, cannot.
To represent these numbers, computers have to round off to the nearest floating-point number.
The difference between the number we want and the floating-point number we get is called {\bf rounding error}.

%Notwithstanding, there is a fundamental flaw with floating-point arithmetic.
%In mathematics, there is an infinite number of real numbers.
%But computer processors are finite; they cannot represent {\em every} possible floating-point number.
%Even with double-precision, you will frequently run into problems.

\index{arithmetic!floating-point}

For example, the following two statements should be equivalent:

\begin{code}
    System.out.println(0.1 * 10);
    System.out.println(0.1 + 0.1 + 0.1 + 0.1 + 0.1
                     + 0.1 + 0.1 + 0.1 + 0.1 + 0.1);
\end{code}

But on many machines, the output is:

\begin{stdout}
1.0
0.9999999999999999
\end{stdout}

The problem is that \java{0.1}, which is a terminating fraction in base 10, is a repeating fraction in base 2.
So its floating-point representation is only approximate.
When we add up the approximations, the rounding errors accumulate.

For many applications, like computer graphics, encryption, statistical analysis, and multimedia rendering, floating-point arithmetic has benefits that outweigh the costs.
But if you need {\em absolute} precision, use integers instead.
For example, consider a bank account with a balance of \$123.45:

\begin{code}
    double balance = 123.45;  // potential rounding error
\end{code}

In this example, balances will become inaccurate over time as the variable is used in arithmetic operations like deposits and withdrawals.
The result would be angry customers and potential law suits.
You can avoid the problem by representing the balance as an integer:

\begin{code}
    int balance = 12345;      // total number of cents
\end{code}

\index{type!long}

This solution works as long as the number of cents doesn't exceed the largest integer, which is about 2 billion.
If necessary you can use \java{long} instead, which has a max value of $2^{63}-1$ (about 92 quadrillion dollars).
Hopefully nobody will ever need that much money!


\section{Operators for strings}

\index{string operator}
\index{operator!string}

In general, you cannot perform mathematical operations on strings, even if the strings look like numbers.
The following expressions are illegal:

\begin{code}
    "Hello" - 1     "World" / 123     "Hello" * "World"
\end{code}

%Note that it's unclear looking at these expressions whether \java{message} is an integer or a string.
%The only way to tell the type of a variable is to look at the place where it is declared.

\index{concatenate}

The \java{+} operator does work with strings, but it might not do what you expect.
For strings, the \java{+} operator performs {\bf concatenation}, which means joining each part end-to-end.
So \java{"Hello, " + "world!"} yields the string \java{"Hello, world!"}.
Likewise, the expression \java{"Hello, " + name} adds the value of \java{name} to the hello string, which is handy for creating a personalized greeting.

%When you append two strings, make sure one of them contains a space character.
%Otherwise you will end up with something like \java{"Hello,world!"}.

%\subsection{Adding Strings and numbers}

%If you add an \java{int} and a \java{double}, Java automatically converts the \java{int} into a \java{double} before performing the addition:

%\begin{code}
%    System.out.println(1 + 2.0);
%    // prints 3.0
%\end{code}

Since addition is defined for both numbers and strings, Java performs automatic conversions you may not expect:

% TODO: use DrJava interactive format for these examples?

\begin{code}
    System.out.println(1 + 2 + "Hello");
    // the output is 3Hello

    System.out.println("Hello" + 1 + 2);
    // the output is Hello12
\end{code}

Java executes these operations from left to right.
In the first line, \java{1 + 2} is the value \java{3}, and \java{3 + "Hello"} is the value \java{"3Hello"}.
But in the second line, \java{"Hello" + 1} is \java{"Hello1"}, and \java{"Hello1" + 2} is \java{"Hello12"}.
The difference is when the conversion from integer to string actually takes place.

%Fortunately, this situation only happens when using the plus operator.
%You cannot, for example, store an integer directly in a string variable.
%
%\begin{code}
%     String number = 5;  // syntax error
%\end{code}

%In general, it's better not to compose multiple additions of varying data types.
%Instead you can break those statements into multiple lines, or use another method like \java{printf} to achieve the same results.


% TODO: add the following subsection before/after this section?
%\section{Type conversion}
%\index{type!conversion}
%\index{typecasting}

%You might wonder how you can get away with an expression like \java{
%"The log of x is " + result}, since one of the operands is a \java{String}
%and the other is a \java{double}.  In this case Java is being
%smart on our behalf, automatically converting the \java{double} to a
%\java{String} before it does the string concatenation.

%This kind of feature is an example of a common problem in designing a
%programming language, which is that there is a conflict between {\em
%formalism}, which is the requirement that formal languages should have
%simple rules with few exceptions, and {\em convenience}, which is the
%requirement that programming languages be easy to use in practice.

%More often than not, convenience wins, which is usually good for
%expert programmers (who are spared from rigorous but unwieldy
%formalism), but bad for beginning programmers, who are often baffled
%by the complexity of the rules and the number of exceptions.  In this
%book I have tried to simplify things by emphasizing the rules and
%omitting many of the exceptions.

%Whenever you try to ``add'' two
%expressions, if one of them is a \java{String}, Java converts the
%other to a \java{String} and then perform string concatenation.
%What do you think happens if you perform an operation between
%an integer and a floating-point value?


\section{Order of operations}

\index{order of operations}
\index{precedence}

When more than one operator appears in an expression, the order of evaluation depends on the rules of {\bf precedence}.
Generally speaking, Java executes individual operations from left to right (as was the case in the previous section).
But for numeric operators, Java follows mathematical conventions:

\begin{itemize}

\item Multiplication and division happen before addition and subtraction.
So \java{2 * 3 - 1} yields 5, not 4, and \java{2 / 3 - 1} yields -1, not 1.
Remember that because of integer division, \java{2 / 3} is 0.

\item If the operators have the same precedence, they are evaluated from left to right.
So in the expression \java{minute * 100 / 60}, the multiplication happens first, yielding \java{5900 / 60}, which in turn yields \java{98}.
If these same operations had gone from right to left, the result would have been \java{59 * 1}, which is incorrect.

\item Any time you want to override the rules of precedence (or you are not sure what they are) you can use parentheses.
Expressions in parentheses are evaluated first, so \java{2 * (3 - 1)} is 4.
You can also use parentheses to make an expression easier to read, as in \java{(minute * 100) / 60}, even though it doesn't change the actual result.

\end{itemize}

Don't work too hard to remember all the rules of precedence, especially for other operators.
If it's not obvious by looking at the expression, use parentheses to make it more clear.


\section{Composition}

\index{composition}

So far we have looked at the elements of a programming language---variables, expressions, and statements---in isolation, without talking about how to put them all together.

One of the most useful features of programming languages is their ability to take small building blocks and {\bf compose} them.
For example, we know how to multiply numbers and we know how to print.
It turns out we can combine these operations into a single statement:

\begin{code}
    System.out.println(17 * 3);
\end{code}

Any expression involving numbers, strings, and variables can be used inside a print statement.
We've already seen one example:

\begin{code}
    System.out.println(hour * 60 + minute);
\end{code}

You can also put arbitrary expressions on the right side of an assignment:

\begin{code}
    int percentage;
    percentage = (minute * 100) / 60;
\end{code}

The left side of an assignment must be a {\em variable name}, not an expression.
That's because the left side indicates where the result will be stored,
and expressions do not represent storage locations.

\begin{code}
    hour = minute + 1;  // correct
    minute + 1 = hour;  // syntax error
\end{code}

\index{readability}

The ability to compose operations may not seem that impressive now, but we will see examples later on that allow us to write complex computations neatly and concisely.

Before you get too carried away with composition, keep in mind that other people will be reading your source code.
In practice, software developers spend the vast majority of their time {\em understanding} and {\em modifying} existing code.
Thus it's far more important to write code that is readable than to write code that is (or appears to be) optimal.
%There is much beauty in simplicity.
In general, each line of code should be a single step of the algorithm.


\section{Formatting and style}

\index{whitespace}

Recall from Section~\ref{sec:formatting} that the compiler generally ignores {\bf whitespace}, i.e., newlines, tab characters, and other spaces.
Programmers have a lot of freedom in how they {\em format} their code in terms of indenting, blank lines, spaces around operators, etc.
However with that freedom comes responsibility, both to yourself (when you look at the code in the future) and to others who will be reading, understanding, and modifying your code.

\index{Google style}

Virtually every organization that does a lot of software development has strict guidelines on how to format source code.
For example, Google published its Java coding standards for use in open-source projects:
\url{http://google.github.io/styleguide/javaguide.html}
It is easier to understand a large codebase when all the source code is formatted consistently.
%Plus following style guidelines helps you to avoid common programming mistakes that are difficult to debug.

\index{Checkstyle}

Style rules can be difficult to learn, especially for beginners who haven't yet seen many of the language features discussed in them.
Fortunately there are many tools that help programmers find and correct formatting errors.
One prominent example is Checkstyle, which has the built-in ability to enforce most of Google's coding standards:
\url{http://checkstyle.sourceforge.net/}

Checkstyle is primarily a command-line tool.
Instructions for downloading and running Checkstyle are available on our website: \url{http://thinkjava.org/}

% TODO: When we have the website up, let's update this with a more specific URL

There are limits to what automatic style checkers can do.
In particular, they can't evaluate the {\em quality} of your comments, the {\em meaning} of your variable names, or the {\em structure} of your algorithms.
Good comments make it easier for experienced developers to identify errors in your code.
Good variable names communicate the intent of your program and how the data is organized.
And good programs are designed to be efficient and demonstrably correct.


\section{Vocabulary}

\begin{description}

\term{syntax error}
An error in a program that makes it impossible to parse (and therefore impossible to compile).

%\term{type-safe}
%A property of Java that makes it possible to catch some errors at compile time.

\term{runtime error}
An error in a program that makes it impossible to execute completely.
In Java, they are ``exceptions'' that terminate the program.

\term{logic error}
An error in a program that makes it do something other than what the programmer intended.

\term{variable}
A named storage location for values.
All variables have a type, which is declared when the variable is created.

\term{value}
A number or string that can be stored in a variable.
Every value belongs to a type (for example, \java{int} or \java{String}).

\term{declaration}
A statement that creates a new variable and specifies its type.

\term{type}
Mathematically speaking, a set of values.
The type of a variable determines which values it can have.

\term{keyword}
A reserved word used by the compiler to parse programs.
You cannot use keywords (like \java{public}, \java{class}, and \java{void}) as variable names.

\term{assignment}
A statement that stores a value in a memory location.

\term{operator}
A symbol that represents a computation like addition, multiplication, or string concatenation.

%\term{operand}
%One of the values on which an operator operates.

\term{expression}
A combination of variables, operators, and values that represents a single value.
Expressions also have types, as determined by their operators and operands.

\term{floating-point}
A data type that represents decimal numbers (numbers that have an integer part and a fractional part).
In Java, the default floating-point type is \java{double}.

\term{rounding error}
The small difference between a floating-point number and its actual representation on computer hardware.

\term{concatenate}
To join two values end-to-end.
For string values, concatenation means to append.

\term{precedence}
The order in which operations are evaluated.

\term{composition}
The ability to combine simple expressions and statements into compound expressions and statements, making it possible to represent complex computations in a concise manner.

\term{whitespace}
Newlines, tab characters, and other spaces in a source program.
Its purpose in the Java language is to separate tokens.

%\term{wildcard}
%A command-line feature that allows you to specify a pattern of file names.

\end{description}


\section{Exercises}


\begin{exercise}

If you are using this book in a class, you might enjoy this exercise.
Find a partner and play {\it Stump the Chump}:

Start with a program that compiles and runs correctly.
One player turns away while the other player adds an error to the program.
Then the first player tries to find and fix the error.
You get two points if you find the error without compiling the program, one point if you find it using the compiler, and your opponent gets a point if you don't find it.

\end{exercise}


\begin{exercise}
\label{ex:date}

The point of this exercise is (1) to use string concatenation to display values with different types (\java{int} and \java{String}), and (2) to practice developing programs gradually by adding a few statements at a time.

\begin{enumerate}

\item Create a new program named {\tt Date.java}.
Copy or type in something like the ``Hello, World!'' program and make sure you can compile and run it.

\item Following the example in Section~\ref{sec:printvar}, write a program that creates variables named \java{day}, \java{date}, \java{month}, and \java{year}.
\java{day} will contain the day of the week and \java{date} will contain the day of the month.
What type is each variable?
Assign values to those variables that represent today's date.

\item Print the value of each variable on a line by itself.
This is an intermediate step that is useful for checking that everything is working so far.

\item Modify the program so that it prints the date in standard American format, for example: {\tt Thursday, July 16, 2015}.

\item Modify the program again so that the total output is:

\begin{stdout}
American format:
Thursday, July 16, 2015
European format:
Thursday 16 July, 2015
\end{stdout}

\end{enumerate}

HINT: You should be able to copy, paste, and modify the code from Step 4 when completing Step 5.

\end{exercise}


\begin{exercise}

The point of this exercise is (1) to use some of the arithmetic operators, and (2) to start thinking about compound entities (like time of day) that that are represented with multiple values.

\begin{enumerate}

\item Create a new program called {\tt Time.java}.
From now on, we won't remind you to start with a small, working program, but you should.

\item Following the example program in Section~\ref{sec:printvar}, create variables named \java{hour}, \java{minute}, and \java{second}.
Assign values that are roughly the current time.
Use a 24-hour clock, i.e., so that at 2pm the value of \java{hour} is 14.

\item Make the program calculate and print the number of seconds since the most recent midnight.

\item Make the program calculate and print the number of seconds remaining in the day.

\item Make the program calculate and print the percentage of the day that has passed.
You might run into problems when computing percentages with integers, so consider using floating-point.

\item Change the values of \java{hour}, \java{minute}, and \java{second} to reflect the current time.
Check that the program works correctly each time you run it.

\end{enumerate}

HINT: You may want to use additional variables to hold values during the computation.
Variables that are used in a computation but never printed are sometimes called intermediate or temporary variables.

\end{exercise}


\chapter{Input and output}

%A number of years ago, Jeannette Wing published a terrific editorial with the title {\it Computational Thinking}, or in her own words, ``Ways to Think Like a Computer Scientist'' (see Communications of the ACM, March 2006).
%This 3-page article summarizes many of the problem-solving techniques you will discover while learning to program.
%Everyone interested in learning computer science beyond programming should read it.
%She defines the field this way:

%\index{computer science}

%\begin{quote}
%{\bf ``Computer science is the study of computation---what can be computed and how to compute it.''}
%\end{quote}

The programs we've looked at so far just display messages, which doesn't involve a lot of real computation.
This chapter will show you how to read input from the keyboard, use that input to calculate a result, and then format that result for output.
%We will also look at some technical details about how operating systems work.


\section{The System class}
\label{sec:system}

\index{System class}
\index{class!System}

\java{System.out.println} can display the value of any type of variable.
You can even use \java{println} to print the value of \java{System.out}:

\begin{code}
    System.out.println(System.out);
\end{code}

The result is:

\begin{stdout}
java.io.PrintStream@685d72cd
\end{stdout}

\index{package}

From this output we can see that \java{System.out} is a \java{PrintStream}, which is defined in a package called \java{java.io}.
A {\bf package} is a collection of related classes; \java{java.io} contains classes for ``I/O'' which stands for input and output.

\index{address}

After the {\tt @} sign is the location of the object in memory, which is called its {\bf address}.
In this example the address is \java{685d72cd}, but if you run the same code you will likely get something different.
%You can think of the address as a unique identifier for the object.

\index{object}

\java{System.out} is an {\bf object}, which means that it is a special value that provides methods.
Specifically, \java{System.out} provides methods for displaying output, including \java{print} and \java{println}.
Numbers with type \java{int} and \java{double} are not objects because they provide no methods.
Strings are objects; we will see some of their methods soon.

\index{library}

The \java{System} class is defined in a file called {\tt System.java}, and {\tt PrintStream} is defined in {\tt PrintStream.java}.
These files are part of the Java {\bf library}, which is an extensive collection of classes you can use in your programs.

\begin{figure}[!h]
\begin{center}
\includegraphics{figs/system.pdf}
\caption{\java{System.out.println} refers to the \java{out} variable of the \java{System} class, which is a \java{PrintStream} that provides a method called \java{println}.}
\end{center}
\end{figure}

%Both \java{System} and \java{PrintStream} are written in Java, and later in the book we'll examine their source code.
%For now, you should understand that \java{System.out} is a \java{PrintStream} object.
%Because Java is an {\em object-oriented} language, much of the library is organized around objects that perform specific actions.

% ABD: there is so much new vocab in these sections, I want to reduce the number of new ideas

%\index{operating system}

%As with most software, Java programs run on top of an {\bf operating system} that manages the keyboard, the display, main memory, disk drives, printers, the network, and other hardware resources.
%Common examples of operating systems include Android, iOS, Linux, Mac OS~X, and Windows.
%When starting Java programs, the operating system directs \java{System.out} to the screen.

%\index{abstraction}

%Note the exact type of display doesn't matter, whether it's a 5-inch touch screen or 30-inch monitor.
%From the programmer's point of view, \java{System.out} simply provides the means for printing messages.
%Computer scientists often use {\bf abstraction} to deal with the complexity of software.
%The \java{System} class is a platform-independent abstraction of the operating system.
%The operating system itself is a layer of abstraction on top of computer hardware.


\section{The Scanner class}

\index{Scanner class}
\index{class!Scanner}

%\index{byte}
%
%From the operating system's point of view, data from the keyboard arrives in a series of hardware control signals.
%The operating system translates these signals into a stream of {\bf bytes} (small integers), which in turn need to be translated into characters.
%\java{System.in} provides the means for reading one byte of input at a time, which is hardly useful for programs that would rather read in an entire word or line of input.

The \java{System} class also provides an object named \java{in}, which is an \java{InputStream} that provides methods for reading input from the keyboard.
%As with \java{System.out}, the exact type of keyboard (or even touch screen) does not matter to the programmer.
These methods perform simple operations, but they are not easy to use.
Fortunately, Java provides other classes that make it easier to handle common input tasks.

\index{class!utility}
\index{utility class}

For example, \java{Scanner} is a class that provides methods for inputting words, numbers, and other data.
\java{Scanner} is provided by \java{java.util}, which is a package that contains classes so useful they are called {\bf utility classes}.
Before you can use \java{Scanner}, you have to import it at the top of your source file:

\begin{code}
import java.util.Scanner;
\end{code}

\index{import}
\index{statement!import}

This {\bf import statement} tells the compiler that when you say \java{Scanner}, you mean the one defined in \java{java.util}.
It's necessary because there might be another class named \java{Scanner} in another package.
Using an import statement makes your code unambiguous.

Next you have to create a \java{Scanner} object using the keyword \java{new}.
%In most programs, you will need only one \java{Scanner}, since there is only one source of input.
The following code declares a \java{Scanner} variable and then creates a \java{Scanner} object:

\begin{code}
    Scanner in;
    in = new Scanner(System.in);
\end{code}

\index{argument}

Although \java{Scanner} is not a method, the syntax is the same as a method call.
We pass \java{System.in} as an argument, which specifies that we are planning to input values from the keyboard.
Alternatively, you can declare the variable and assign it using one line of code.
%This latter syntax is more convenient, since it's a one-time setup for many programs.
%Just make sure you understand that it's two statements in one.

\begin{code}
    Scanner in = new Scanner(System.in);
\end{code}

The new \java{Scanner} object (stored in the variable \java{in}) provides a method called \java{nextLine} that reads a line of input from the keyboard and returns a String.
The following example reads two lines and repeats them back to the user.

\begin{code}
import java.util.Scanner;

public class Echo {
    public static void main(String[] args) {
        String line;
        Scanner in = new Scanner(System.in);

        System.out.print("Type something:");
        line = in.nextLine();
        System.out.println("You said: " + line);

        System.out.print("Type something else:");
        line = in.nextLine();
        System.out.println("You also said: " + line);
    }
}
\end{code}

If you omit the import statement and later refer to \java{Scanner}, you will get a compiler error like ``cannot find symbol.''
That means the compiler doesn't know what you mean by \java{Scanner}.

You might wonder why we can use the \java{System} class without importing it.
\java{System} belongs to the \java{java.lang} package, which is imported automatically.
According to the documentation, \java{java.lang} ``provides classes that are fundamental to the design of the Java programming language.''
The \java{String} class is also part of the \java{java.lang} package.

\subsection{Structure of Java programs}
\label{sec:library}

At this point, we have seen all of the elements that make up Java programs.
The following figure shows these organizational units.

\begin{figure}[!h]
\begin{center}
\includegraphics[width=4in]{figs/package.pdf}
\caption{Elements of the Java language, from largest to smallest.}
\end{center}
\end{figure}

To review, a package is a collection of classes, which define methods.
Methods contain statements, some of which contain expressions.
Expressions are made up of tokens, which include variable names, numbers, operators, keywords, and punctuation like braces and semicolons.

The standard edition of Java comes with {\em several thousand} classes you can \java{import}, which can be both exciting and intimidating.
You can browse this library on Oracle's website: \url{http://docs.oracle.com/javase/7/docs/api/}
Note there is a major difference between the Java {\em language}, which deals with syntax and grammar, and the Java {\em library}, which provides the built-in classes.
In fact, most of the Java library itself is written in Java.

%To help keep things organized, classes are grouped into {\bf packages}.
%Just as each \java{class} is a separate file, each \java{package} is a separate folder.

%In order to use a class defined in another package (and in another folder), you have to {\bf import} it first.

%\begin{code}
%import java.io.File;
%import java.io.PrintStream;
%import java.util.Date;
%import java.util.Scanner;
%\end{code}

%All \java{import} statements appear at the top of the source file, above the class definition.
%It's not uncommon for Java programs to have many import statements.


\section{Inches to centimeters}

Now let's see an example that's a little more useful.
Although most of the world has adopted the metric system for weights and measures, some countries are stuck with English units.
For example, when talking with friends in Europe about the weather, people in the United States may have to convert from Celsius to Fahrenheit and back.
%And when making an international purchase online, you may have to convert your nation's currency into another based on the exchange rate.
Or you might want to convert your height in inches to centimeters.

%An everyday problem that computers are great at solving is converting numbers from one unit into another.
%For the rest of the chapter, we will look at how to write programs that solve these types of problems.
%Specifically, each program will 1) prompt the user for input, 2) read input from the keyboard, 3) calculate a result, and 4) format the result for output.
%The focus will not only be on Java syntax and language features, but also on the {\em process} of solving the problem, documenting the code, and testing the solution.

We can write a program to help.
We can use a \java{Scanner} to input a measurement in inches, convert to centimeters, and then print the results.
These lines declare the variables and create the \java{Scanner}:

% ABD: I am inclined not to include comments in most of the code
% examples because (1) I think it makes the code less cluttered and
% easier to read, and (2) they are often redundant with the text.

% I understand that it would be good to demonstrate good commenting
% style.  Despite this benefit, I think it's better to leave
% them out.  But I don't feel strongly about it.

\begin{code}
    int inch;  // the input
    double cm;  // the output
    Scanner in = new Scanner(System.in);
\end{code}

The first step is to prompt the user for the input.
We'll use \java{print} instead of \java{println} so they can enter the input on the same line.

\begin{code}
    System.out.print("How many inches? ");
    inch = in.nextInt();
\end{code}

Next we multiply the number of inches by 2.54, since that's how many centimeters there are per inch.
Finally we display the results on one line, but use two print statements since it's easier to read.

\begin{code}
    cm = inch * 2.54;
    System.out.print(inch + " in = ");
    System.out.println(cm + " cm");
\end{code}

\index{magic number}

This code works, but it has a problem.
If another programmer reads this code, they might wonder where 2.54 comes from.
Numbers that appear in an expression with no explanation are called {\bf magic numbers}.
For the benefit of other programmers (and yourself in the future), it is helpful to assign magic numbers to variables with informative names:

\begin{code}
    final double cmPerInch = 2.54;
    cm = inch * cmPerInch;
    System.out.print(inch + " in = ");
    System.out.println(cm + " cm");
\end{code}

\subsection{Literals and constants}

\index{literal}

Parts of the output we have been printing (\java{" in = "}, \java{" cm"}, etc.) are {\em literal} string values.
{\bf Literals} are data embedded directly into programs.
In contrast, variables (\java{inch}, \java{cm}, etc.) are the names of values stored in memory.
The English word {\em variable} implies that this data is subject to change.

As we saw with \java{cmPerInch}, it's often useful to give names to literals that will be used throughout the program.
But when doing so, we don't want those variables to be changed accidentally because of an unexpected bug in the code.
As another example, consider the famous card game that comes with most versions of Microsoft Windows.

\begin{code}
    final String title = "Solitaire";
    final int deckSize = 52;
\end{code}

\index{final}
\index{constant}
\index{initialize}

The keyword \java{final} indicates these variables are {\bf constants} and therefore may be assigned only one time.
Constants are generally declared and {\bf initialized} on the same line of code.
%The term initialize means to assign for the first time.
If you attempt to assign \java{title} or \java{deckSize} later in the program, the compiler will report an error.
This feature helps prevent you from making mistakes.

It's good practice to create final variables for constant values, rather than repeat literal values again and again.
For one, it makes the program easier to understand.
When looking at the code, it may not be obvious what the number \java{52} means.
The name \java{deckSize} explains the programmer's intent.
Second, named constants make the program easier to maintain.
If we want to change the title from \java{"Solitaire"} to \java{"Klondike"}, we would only need to change one line of code (as opposed to every line where that title is used).


\section{Formatting output}

When printing floating-point numbers, Java automatically decides how many decimal places to display.

% ABD: What do you think of using the DrJava interpreter format to show the result of simple examples, as in the following?

\begin{code}
    System.out.print(7.0 / 3.0);
    // prints 2.3333333333333335   note: 5 is a rounding error
\end{code}

\index{printf}
\index{argument}

\java{System.out} provides another method called \java{printf}, where the ``f'' stands for ``formatted''.
The first argument of \java{printf} is a {\em format string} that specifies how values should be displayed.
%It contains a template for the text you want to output, as well as positions where it will substitute other values.
The other arguments are the values themselves.

\begin{code}
    System.out.printf("Seven thirds = %.3f", 7.0 / 3.0);
    // prints Seven thirds = 2.333
\end{code}

\index{format specifier}

This format string contains ordinary text followed by a {\bf format specifier}, which is a special sequence that starts with a percent sign.
The format specifier \verb"%.3f" indicates that the value should be displayed as floating-point with three decimal places.
Here's an example that contains two format specifiers:

\begin{code}
   inch = 100;
   cm = inch * cmPerInch;
   System.out.printf("%d in = %f cm\n", inch, cm);
   // prints 100 in = 254.000000 cm
\end{code}

The values are matched up with the format specifiers in order, so \java{inch} is displayed as an integer (``d'' stands for ``decimal'') and \java{cm} is displayed as a floating-point number.
Format strings often end with a newline character (\verb"\n"), since \java{printf} does not append a newline like \java{println} does.

Learning \java{printf} is like learning a sub-language within Java.
There are many options, and the details can be overwhelming.
But here are some common uses, to give you an idea of how it works:

\begin{table}[!h]
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
\verb"%d" & decimal integer & 12345 \\
\hline
\verb"%,d" & decimal integer with comma separators & 12,345 \\
\hline
\verb"%08d" & padded with zeros, at least 8 digits wide & 00012345 \\
\hline
\verb"%f" & floating-point & 6.789000 \\
\hline
\verb"%.2f" & floating-point {\em rounded} to 2 decimal places & 6.79 \\
\hline
\end{tabular}
\caption{Example format specifiers}
\end{center}
\end{table}

For more details, refer to the documentation of \java{java.util.Formatter}
or search the web for ``java formatting.''


\section{Centimeters to inches}
\label{sec:rounding}

Now suppose we have a measurement in centimeters and we want to round it off to the nearest inch.
It is tempting to write:

\begin{code}
    inch = cm / centPerInch;  // syntax error
\end{code}

But the result is an error---you get something like, ``Bad types in assignment: from double to int.''
The problem is that the value on the right is floating-point and the variable on the left is an integer.

%Java converts an \java{int} to a \java{double} automatically, since no information is lost in the process.
%On the other hand, going from \java{double} to \java{int} gets rid of the decimal places.
%Java doesn't perform this operation automatically in order to ensure that you are aware of the loss of the fractional part of the number.

\index{type cast}
\index{operator!cast}

The simplest way to convert a floating-point value to an integer is to use a {\bf type cast}, so called because it molds or ``casts'' a value from one shape to another.
The syntax for type casting is to put the name of the type in parentheses and use it as an operator.

\begin{code}
    double pi = 3.14159;
    int x = (int) pi;
\end{code}

%\index{truncate}

The \java{(int)} operator has the effect of converting what follows into an integer.
In this example, \java{x} gets the value \java{3}.
Converting to an integer always rounds {\em toward zero}, even if the fraction part is \java{0.999999} (or \java{-0.999999}).

Type casting takes precedence over arithmetic operations.
In this example, the value of \java{pi} gets converted to an integer first.
So the result is 60.0, not 62.

\begin{code}
    double pi = 3.14159;
    double x = (int) pi * 20.0;
\end{code}

%Operator precedence and integer truncation make type casting somewhat error-prone.

Keeping that in mind, here's how we can convert a measurement in centimeters to inches.

\begin{code}
    inch = (int) (cm / centPerInch);
    System.out.printf("%f cm = %d in\n", cent, inch);
\end{code}

The parentheses after the cast operator require the division to come before the type cast.
This result will be rounded toward zero, but we will learn in the next chapter how to round floating-point numbers to the closest integer.

\subsection{Modulus operator}

Let's take the example one step further: suppose you have a measurement in inches and you want to convert to feet and inches.
The goal is divide by 12 (the number of inches in a foot) and keep the remainder.

\index{modulus}
\index{operator!modulus}

We have already seen the division operator (\java{/}), which computes the quotient of two numbers.
If the numbers are integers, it performs integer division.
Java also provides the {\bf modulus} operator (\java{\%}), which divides two numbers and computes the remainder.

Assuming the following variables are integers, we can convert 76 inches to feet and inches like this:

\begin{code}
    quotient = 76 / 12;   // division
    remainder = 76 % 12;  // modulus
\end{code}

The first line yields 6.
The second line, which is pronounced ``76 mod 12,'' yields 4.
So 76 inches is 6 feet, 4 inches.

Although the modulus operator is a percent sign, you might find it helpful to think of it as a division sign ($\div$) rotated to the left.
Note that both \java{/} and \java{\%} perform {\em integer division}.
The reason why integer division ``rounds down'' is that the hardware computes the quotient and remainder separately.
%Many algorithms, including the example above, perform division and modulus together.

\index{divisible}
\index{extract digits}

Integer division turns out to be surprisingly useful.
For example, you can check whether one number is divisible by another: if \java{x \% y} is zero, then \java{x} is divisible by \java{y}.
You can also use modulus to ``extract'' digits from a number: \java{x \% 10} yields the rightmost digit of \java{x}, and \java{x \% 100} yields the last two digits.
Also, many encryption algorithms are based on modular arithmetic.


\section{Putting it all together}

%\begin{itemize}

%% Chapter 1
%\item Write a class and main
%\item Display simple output
%\item Compile and run programs
%\item Correct syntax errors

%% Chapter 2
%\item Declare/assign variables
%\item Create named constants
%\item Perform basic arithmetic
%\item Compose multiple operations

%% Chapter 3
%\item Browse the Java library
%\item Import Java library classes
%\item Initialize a Scanner object
%\item Get input from the keyboard
%\item Read/write documentation
%\item Format output with printf
%\item Divide and mod integers

%\end{itemize}

At this point you know enough Java to write useful programs that solve everyday problems.
You've seen how to 1) import Java library classes, 2) initialize a \java{Scanner} object, 3) get input from the keyboard, 4) format output with \java{printf}, and 5) divide and mod integers.
Now we can put them together in a complete program:

%Since we've looked at each of these topics in isolation, it's important to see how they fit together in a complete program.
%If you've been working through the examples on your computer as you've been reading (like we recommended in Section~\ref{sec:examples}), then good job!

\begin{code}
import java.util.Scanner;

/**
 * Converts centimeters to feet and inches.
 */
public class Convert {
    public static void main(String[] args) {
        double cm;
        int feet, inches;
        final double centPerInch = 2.54;
        Scanner in = new Scanner(System.in);

        // prompt the user and get the value
        System.out.print("Exactly how many cm? ");
        cm = in.nextDouble();

        // convert and output the result
        inches = (int) (cm / centPerInch);
        feet = inches / 12;
        inches = inches % 12;
        System.out.printf("%.2f cm = %d ft, %d in\n",
                          cm, feet, inches);
    }
}
\end{code}

\begin{itemize}

\item Although not required, all variables and constants are declared at the top of \java{main}.
This practice makes it easier to find their types later on and helps the reader know what data is involved in the algorithm.

\item For readability, each major step of the algorithm is separated by a blank line and begins with a comment.

\item Integer division and modulus often go together.
Notice how \java{inches} gets reassigned (which replaces its value) just before the \java{printf}.

\item When statements get long (generally wider than 80 characters), a common style convention is to break them across multiple lines.
The reader should never have to scroll horizontally.

\end{itemize}

%As an exercise, try running this code through Checkstyle.


\section{The Scanner bug}

Now that you've had some experience with \java{Scanner}, there is an unexpected behavior we want to warn you about.
Consider a simple program that asks users for their name and age.
Somewhere in the middle of the code, we have the following lines:

\begin{code}
    System.out.print("What is your name? ");
    name = in.nextLine();
    System.out.print("What is your age? ");
    age = in.nextInt();
    System.out.printf("Hello %s, age %d\n", name, age);
\end{code}

The output of the \java{printf} statement looks something like this:

\begin{stdout}
Hello Darth Vader, age 45
\end{stdout}

When you read a \java{String} followed by an \java{int}, everything works just fine.
But when you read an \java{int} followed by a \java{String}, something strange happens.

\begin{code}
    System.out.print("What is your age? ");
    age = in.nextInt();
    System.out.print("What is your name? ");
    name = in.nextLine();
    System.out.printf("Hello %s, age %d\n", name, age);
\end{code}

Try running the above example.
It doesn't let you input your name and immediately displays the output:

\begin{stdout}
What is your name? Hello , age 45
\end{stdout}

To understand what is happening, recall that computers do not {\em see} input as multiple lines like we do.
Instead, the operating system simply forwards a stream of characters to your program via \java{System.in}:

\begin{center}
\includegraphics{figs/vader1.pdf}
\end{center}

The up-arrow represents the next character to be read by \java{Scanner}.
When you call \java{nextInt}, it will read characters until a non-digit is found.

\begin{center}
\includegraphics{figs/vader2.pdf}
\end{center}

At this point, \java{nextInt} returns the \java{int} value \java{45}.
The program then asks \java{"What is your name? "} and calls \java{nextLine}.
\java{Scanner} will read characters until a newline is found.
Since the next character to be read already is a newline, \java{nextLine} returns the empty string \java{""}.

To solve this problem, you need to add an extra call to \java{nextLine} after you call \java{nextInt}.

\begin{code}
    System.out.print("What is your age? ");
    age = in.nextInt();
    in.nextLine();  // read the newline
    System.out.print("What is your name? ");
    name = in.nextLine();
    System.out.printf("Hello %s, age %d\n", name, age);
\end{code}

This technique is common when reading \java{int} or \java{double} values that appear on their own line.
First you read the number, then you read the rest of the line (which is just a newline character).
Note that you do not have to assign the return value of \java{nextLine} to a variable in that case; you can simply ignore it.


\section{Command-line testing}

You should review the advice in Section~\ref{sec:examples}, now that you've written some more substantial programs.
Remember, it's more effective to program and debug your code little by little than to attempt writing everything at once.
And once you've completed programming an algorithm, it's important to test that it works correctly on a variety of inputs.

Throughout the book, we will illustrate techniques for testing your programs.
Most if not all testing is based on a simple idea: does the program do what we expect it to do?
For simple programs, it's not difficult to run them several times and see what happens.
But at some point, you will get tired of typing the same test cases over and over.

We can automate the process of entering input and comparing {\em expected output} with {\em actual output} using the command-line.
The basic idea is to store the test cases in plain text files and trick Java into thinking they are coming from the keyboard.
Here are step by step instructions.

\begin{enumerate}

\item Make sure you can compile and run the {\tt Convert.java} example in the previous section.
%You can also download a copy from \url{http://thinkjava.org/}.

\item In the same directory as {\tt Convert.java}, create a plain text file named {\tt test.in} (``in'' is for input).
Enter the following line and save the file.

\begin{stdout}
193.04
\end{stdout}

\item Create a second plain text file named {\tt test.exp} (``exp'' is for expected).
Enter the following line and save the file.

\begin{stdout}
193.04 cm = 6 ft, 4 in
\end{stdout}

\item Open a command-line, and change to the directory with these files.
Run the following command to test the program.

\begin{stdout}
java Convert < test.in > test.out
\end{stdout}

\end{enumerate}

\index{redirection operator}

On the command-line, {\tt <} and {\tt >} are {\bf redirection operators}.
The first one redirects the contents of {\tt test.in} to \java{System.in}, as if it were entered from the keyboard.
The second one redirects the contents of \java{System.out} to a new file {\tt test.out}, much like a screen capture.
In other words, the {\tt test.out} file contains the output of your program.

% ABD: Since I killed the previous reference to abstraction, I am inclined
% to kill this one too.  The problem in both places is that it pulls the
% focus off topic.

%Redirecting a program's input and output is an example of how computer scientists use abstraction.
%Notice that \java{System.in} is not called \java{Keyboard}, and \java{System.out} is not called \java{Display}.
%In practice, these objects could be text files, network connections, microphones and speakers, or some other byte streams.
%What's great is that doesn't change anything about how you write the code.

By the way, it's perfectly okay to compile your programs in DrJava (or some other environment) and run them from the command-line.
Knowing both techniques allows you to use the right tool for the job.

At this point, we just need to compare the contents {\tt test.out} with {\tt test.exp}.
If the files are the same, then the program outputted what we expected it to output.
If not, then we found a bug, and we can use the output to begin debugging our program.
Fortunately, there's a simple way to compare files on the command-line:

\begin{stdout}
diff test.exp test.out
\end{stdout}

The {\tt diff} utility summarizes the differences between two files.
If there are no differences, then it prints nothing, which in our case is what we want.
If the expected output differs from the actual output, then we need to continue debugging.
Usually the program is at fault, and {\tt diff} provides some insight about what is broken.
But there's also a chance that we have a correct program and the expected output is wrong.

Interpreting the results from {\tt diff} can be confusing, but fortunately there are many graphical tools that show the differences between two files. For example, on Windows you can install WinMerge, on Mac you can use {\tt opendiff} (which comes with Xcode), and on Linux there's {\tt meld}. Regardless what tool you use, the goal is the same. Debug your program until the actual output is {\it identical} to the expected output.

\begin{figure}[!h]
\begin{center}
\includegraphics[width=0.9\textwidth]{figs/meld.png}
\caption{Using {\tt meld} to compare the expected output with the actual output.}
\end{center}
\end{figure}


\section{Vocabulary}

\begin{description}

\term{package}
A group of classes that are related to each other.
Java classes are organized into packages.

\term{address}
The storage location of a variable or object in memory.
Addresses are integers encoded in hexadecimal (base 16).

\term{object}
An abstract entity that represents data and performs actions.
In Java, objects are stored in memory and referenced by variables.

\term{library}
A collection of packages and classes that are available for use in other programs.
Libraries are often distributed in {\tt .jar} (Java Archive) files.

%\term{operating system}
%Software that is always running behind the scenes on your computer.
%It controls the execution of application programs and manages hardware resources.

%\term{abstraction}
%The process of reducing information and/or detail to focus on high-level concepts.

%\term{byte}
%A single unit of data on a computer; enough to represent one character.

\term{utility class}
A class that provides commonly needed functionality.

\term{import}
A statement that allows programs to use classes defined in other packages.

\term{magic number}
A unique value with unexplained meaning or multiple occurrences.
They should generally be replaced with named constants.

\term{literal}
A constant value written directly in the source code.
For example, \java{"Hello"} is a string literal and \java{74} is an integer literal.

\term{constant}
A variable that can only be assigned one time.
Once initialized, its value cannot be changed.

\term{initialize}
To assign an initial value to a variable.

\term{format specifier}
A special code beginning with percent sign and ending with a single letter that stands for the data type.

\term{type cast}
An operation that explicitly converts one data type into another, sometimes with loss of information.
In Java it appears as a type name in parentheses, like \java{(int)}.

%\term{truncate}
%To make shorter by cutting something off.
%Casting a floating-point value to an integer simply removes the fractional part.

\term{modulus}
An operator that yields the remainder when one integer is divided by another.
In Java, it is denoted with a percent sign (e.g., \java{5 \% 2} is \java{1}).

\term{redirection operator}
A command-line feature that substitutes \java{System.in} and/or \java{System.out} with a plain text file.

\end{description}


\section{Exercises}


\begin{exercise}

When you use \java{printf}, the Java compiler does not check your formatting string.
See what happens if you try to display value with type \java{int} using \verb"%f".
And what happens if you display a \java{float} using \verb"%d"?
What if you use two format specifiers, but then only provide one value?

\end{exercise}


\begin{exercise}

TODO

\end{exercise}


\begin{exercise}

TODO

\end{exercise}


\chapter{Void methods}
\label{voidmeth}

So far we've only written short programs that have a single class with a \java{main} method.
In this chapter, we'll show you how to organize longer programs into multiple methods and classes.
%We will also take a look at separate compilation.

\index{method}

% ABD: In theory I like the idea of providing a chapter overview, but
% in practice I find them impossible to write without breaking the rules
% (like using terms before defining them, etc)

At a conceptual level, a {\bf method} represents a mathematical {\em function} or a general {\em procedure}.
Some methods perform a computation and return a result.
For example, \java{Math.sqrt(25)} returns the value \java{5.0}.
Other methods (including \java{main}) carry out a sequence of actions without returning a result.
Java uses the keyword \java{void} to declare such methods.
Regardless whether they return a value or not, methods enable you to break down a complex program into smaller blocks of code.


\section{Math methods}

\index{Math class}
\index{class!Math}
\index{expression}
\index{argument}

In mathematics, you have probably seen functions like $\sin$ and $\log$, and you have learned to evaluate expressions like $\sin(\pi/2)$ and $\log(1/x)$.
First, you evaluate the expression in parentheses, which is called the {\bf argument} of the function.
Then you can evaluate the function itself, maybe by punching it into a calculator.

This process can be applied repeatedly to evaluate more complex expressions like $\log(1/\sin(\pi/2))$.
First we evaluate the argument of the innermost function, then evaluate the function itself, and so on.

\index{invoke}

The Java library includes a \java{Math} class that provides most common mathematical operations.
%These functions are called {\bf methods}.
\java{Math} is in the \java{java.lang} package, so you don't have to import it.
You can {\bf invoke} Math methods like this:

\begin{code}
    double root = Math.sqrt(17.0);
    double angle = 1.5;
    double height = Math.sin(angle);
\end{code}

The first line sets \java{root} to the square root of 17.
The third line finds the sine of the value of \java{angle}.

\index{degrees}
\index{radians}

Arguments of the trigonometric functions---\java{sin}, \java{cos}, and \java{tan}---should be in {\em radians}.
To convert from degrees to radians, you can divide by 180 and multiply by $\pi$.
Conveniently, the \java{Math} class provides a \java{final double} named \java{PI} that contains an approximation of $\pi$:

\begin{code}
    double degrees = 90;
    double angle = degrees / 180.0 * Math.PI;
\end{code}

Notice that \java{PI} is in capital letters.
Java does not recognize \java{Pi}, \java{pi}, or \java{pie}.
Also, \java{PI} is the name of a variable, not a method, so it doesn't have parentheses.
The same is true for the constant \java{Math.E}, which approximates Euler's number.

It turns out that converting to/from radians is a common operation, so the \java{Math} class provides methods for that.

\begin{code}
    double radians = Math.toRadians(180.0);
    double degrees = Math.toDegrees(Math.PI);
\end{code}

\index{type!long}

If you haven't already, take a look at the documentation for \java{Math} so you know what methods are provided.
For example, another useful method is \java{round}, which rounds a floating-point value to the nearest integer and returns a \java{long}.

\begin{code}
    long x = Math.round(Math.PI * 20.0);
\end{code}

In Java, \java{int} values are stored using 32 bits (4 bytes) of memory, whereas \java{long} values are stored in 64 bits (8 bytes).
As a result, \java{long} variables can represent much larger integers.
In the above example, the multiplication happens first, before the method is invoked.
The result is 63 (rounded up from 62.8319).

\subsection{Composition revisited}

\index{composition}
\index{expression}

Just as with mathematical functions, Java methods can be {\bf composed}.
That means you can use one expression as part of another.
For example, you can use any expression as an argument to a method:

\begin{code}
    double x = Math.cos(angle + Math.PI / 2);
\end{code}

This statement takes the value \java{Math.PI}, divides it by two, and then adds the result to the value of the variable \java{angle}.
The sum is then passed as an argument to \java{cos}.
You can also take the result of one method and pass it as an argument to another:

\begin{code}
    double x = Math.exp(Math.log(10.0));
\end{code}

In Java, the \java{log} method always uses base $e$.
So this statement finds the log base $e$ of 10, and then raises $e$ to that power.
The result gets assigned to \java{x}.
%Do you know what it is without reaching for a calculator?

When using \java{Math} methods, it is a common error to forget to specify the class name \java{Math}.
For example, \java{Math.pow} takes two arguments and raises the first argument to the power of the second.

\begin{code}
    pow(2.0, 10.0);  // syntax error
\end{code}

If you try to invoke \java{Math.pow} this way, the compiler will say it ``cannot find symbol'' (i.e., there is no method named \java{pow} in the current class).


\section{Adding new methods}
\label{adding_methods}

\index{method!definition}
\index{main}
\index{method!main}

Like the \java{Math} class, you can write your own set of methods for use in other programs.
%One of the most powerful features of a programming language is the ability to add new methods.
Let's revisit the method definition for \java{main}:

\begin{code}
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
\end{code}

\index{public}
\index{void}
\index{type!void}

The first line contains information about the method:
\java{main} is a \java{public} method, which means it can be invoked from other classes;
it is a \java{static} method, but we're not going to explain what that means yet;
and it is a \java{void} method, which means that it doesn't yield a result (unlike the \java{Math} methods).

\index{parameter}

The statement in parentheses declares a parameter named
\java{args}.  A {\bf parameter} is a variable that stores an argument.
This parameter has type \java{String[]}, which means that whoever invokes \java{main} must provide an array of Strings (we'll get to arrays in a later chapter).

You can define other methods using syntax that is similar to \java{main}:

\begin{code}
    public static void NAME(PARAMETERS) {
        STATEMENTS
    }
\end{code}

By convention, methods start with a lower case letter and use ``camel case,'' which is a cute name for \java{jammingWordsTogetherLikeThis}.
You can use any name you want for your method, except \java{main} or any of the Java keywords.

% TODO: move the definition of ``argument'' to Ch3?

The list of parameters specifies what values, if any, you have to provide in order to invoke the new method.
The first methods we are going to write have no parameters, so the parameter list is empty.  Here's an example:

\begin{code}
    public static void newLine() {
        System.out.println();
    }
\end{code}

The name of this method is \java{newLine}.
It contains only one statement, which prints a blank line.
In \java{main}, we can invoke the new method like this:

\begin{code}
    public static void main(String[] args) {
        System.out.println("First line.");
        newLine();
        System.out.println("Second line.");
    }
\end{code}

Because \java{newLine} is in the same class as \java{main}, we don't have to specify the class name.
The output of this program is:

\begin{stdout}
First line.

Second line.
\end{stdout}

Notice the extra space between the lines.
If we wanted more space between them, we could invoke the same method repeatedly:

\begin{code}
    public static void main(String[] args) {
        System.out.println("First line.");
        newLine();
        newLine();
        newLine();
        System.out.println("Second line.");
    }
\end{code}

Or we could write a new method that prints three blank lines:

\begin{code}
    public static void threeLine() {
        newLine();
        newLine();
        newLine();
    }

    public static void main(String[] args) {
        System.out.println("First line.");
        threeLine();
        System.out.println("Second line.");
    }
\end{code}

You can invoke the same method more than once, and you can have one method invoke another.
In this example, \java{main} invokes \java{threeLine}, and \java{threeLine} invokes \java{newLine}.

%In \java{threeLine} I wrote three statements all on the same line, which is syntactically legal (remember that spaces and new lines usually don't change the meaning of a program).
%It is usually a good idea to put each statement on its own line, but I sometimes break that rule.

You might wonder why it is worth the trouble to create new methods.
There are many reasons, but this example demonstrates a few of them:

\begin{enumerate}

\item Creating a new method gives you an opportunity to give a name to a group of statements, which makes code easier to read and understand.
%Methods simplify a program by hiding complex computations behind a single statement, and by using English words in place of arcane code.
%Which is clearer, \java{newLine} or \java{System.out.println()}?

\item Introducing new methods can make a program smaller by eliminating repetitive code.
For example, to print nine consecutive new lines, you could invoke \java{threeLine} three times.

\item A common problem-solving technique is to break things down into sub-problems.
Methods allow you to focus on each sub-problem in isolation, and then compose them into a complete solution.

\end{enumerate}

%Perhaps most importantly, organizing your code into multiple methods allows you to test individual parts of your program separately.
%It's easier to get a complex program working if you know that each sub-part works correctly.

%In Section~\ref{methods} we will come back to this question and list some additional benefits of dividing programs into methods.


\section{Classes and methods}

\index{class}
\index{method}

Pulling together the code from the previous section, the complete program looks like this:

\begin{code}
public class NewLine {

    public static void newLine() {
        System.out.println();
    }

    public static void threeLine() {
        newLine();
        newLine();
        newLine();
    }

    public static void main(String[] args) {
        System.out.println("First line.");
        threeLine();
        System.out.println("Second line.");
    }
}
\end{code}

\index{case-sensitive}

The first line is the class definition.
Class names should be capitalized; this convention helps readers tell the difference between classes and methods in your source code.
The \java{NewLine} class contains three \java{void} methods: \java{newLine}, \java{threeLine}, and \java{main}.
Java is a case-sensitive language, so \java{NewLine} and \java{newLine} are considered different.

\subsection{Programs with multiple methods}

\index{order of execution}

When you look at a class definition that contains several methods, it is tempting to read it from top to bottom.
But that is likely to be confusing, because that is not the {\bf order of execution} of the program.

Execution always begins at the first statement of \java{main}, regardless of where it is in the source file.
In the previous example, we deliberately put \java{main} at the bottom of the program.
Statements are executed one at a time, in order, until you reach a method invocation.
Think of method invocations as a detour in the flow of execution.
Instead of going to the next statement, you go to the first line of the invoked method, execute the statements there, and then come back and pick up again where you left off.

That sounds simple enough, but remember that one method can invoke another one.
In the middle of \java{main}, we go off to execute the statements in \java{threeLine}.
But while we are executing \java{threeLine}, we go off to execute \java{newLine}.
Then \java{newLine} invokes \java{println}, which causes yet another detour.

Fortunately, Java is adept at keeping track of where it is.
So when \java{println} completes, it picks up where it left off in \java{newLine}, and then gets back to \java{threeLine}, and then finally gets back to \java{main} so the program can terminate.
In summary, when you read a program, don't read from top to bottom.
Instead, follow the flow of execution.

%Technically, the program does not terminate at the end of \java{main}.
%Instead, execution picks up where it left off in the program that invoked \java{main}, which is the Java interpreter.
%The interpreter takes care of things like deleting windows and general cleanup, and {\em then} the program terminates.


\section{Parameters and arguments}

\index{parameter}
\index{argument}

Some of the methods we have used require arguments, which are values that you provide when you invoke the method.
For example, to find the sine of a number, you have to provide the number.
So \java{sin} takes a \java{double} as an argument.
To print a message, you have to provide the string.
So \java{println} takes a \java{String} as an argument.
Some methods take more than one argument.
For example, \java{Math.pow} takes two \java{double}s: the base and the exponent.

When you use a method, you provide the arguments.
When you write a method, you list the parameters.
The parameter list indicates what arguments are required.
Here's a method that takes a string and prints it twice:

\begin{code}
    public static void printTwice(String s) {
        System.out.println(s);
        System.out.println(s);
    }
\end{code}

\java{printTwice} has a parameter named \java{s} with type \java{String}.
The parameter name hints that it is a \java{String}, but you could use any legal variable name.
When we invoke \java{printTwice}, we have to provide an argument with type \java{String}.
Before the method executes, the argument gets assigned to the parameter.

In this example, the argument \java{"Don't make me say this twice!"} gets assigned to the parameter \java{s}.

\begin{code}
    printTwice("Don't make me say this twice!");
\end{code}

\index{parameter passing}

This process is called {\bf parameter passing} because the value gets passed from outside the method to the inside.
An argument can be any kind of expression, so if you have a \java{String} variable, you can use it as an argument:

\begin{code}
    String argument = "Never say never.";
    printTwice(argument);
\end{code}

The value you provide as an argument must have the same type as the parameter.
For example, if you try:

\begin{code}
    printTwice(17);  // syntax error
\end{code}

You will get the compiler error ``cannot find symbol,'' which might be confusing.
Java is looking for a method named \java{printTwice} that can take an integer.
Since there isn't one in the current class, Java can't find such a ``symbol.''

There are some apparent exceptions to this rule, because sometimes Java converts from one type to another automatically.
For example, \java{Math.sqrt} requires a \java{double} value.
If you run \java{Math.sqrt(25)}, the interger value \java{25} is automatically converted to the floating-point value \java{25.0}.

\java{System.out.println} can accept any type as an argument.
But generally speaking, that is an exception; most methods are not so accommodating.

\subsection{Methods with multiple parameters}
\label{time}

\index{parameter!multiple}
\index{method!multiple parameter}
\index{class!Time}

The syntax for declaring and invoking methods with multiple parameters is a common source of confusion.
For one, you have to declare the type of every parameter separately.

\begin{code}
    public static void printTime(int hour, int minute) {
        System.out.print(hour);
        System.out.print(":");
        System.out.println(minute);
    }
\end{code}

It might be tempting to write ``\java{int hour, minute}'' but that format is only legal for variable declarations, not parameter lists.
Another common source of confusion is that you do not have to declare the types of arguments in a method call.
The following is incorrect:

\begin{code}
    int hour = 11;
    int minute = 59;
    printTime(int hour, int minute);  // syntax error
\end{code}

In this case, Java can tell the type of \java{hour} and \java{minute} by looking at their declarations.
It is unnecessary (and therefore not allowed) to include the type when you pass them as arguments.
The correct syntax is:

\begin{code}
    printTime(hour, minute);
\end{code}

When you call a method, Java {\it copies the value} of any arguments you provide into the method's parameters.
It's common for two methods (e.g., \java{main} and \java{printTime}) to have variables with the same name, to show how data passes from one method to the next.
But remember that these variables are stored in different memory locations.
Changing the value of \java{hour} or \java{minute} in \java{printTime} has no effect on the original variables in \java{main}.


\section{Reading documentation}
\label{sec:apidocs}

\index{documentation}

For a comprehensive example of what methods are like, take a look at the documentation for \java{Scanner}.
You can find it in the Java library (see the link in Section~\ref{sec:library}) or simply do a web search for ``java scanner.''
The latter technique is more useful in the long run, especially as Oracle releases new versions of Java.
Either way, you should get something like Figure~\ref{fig:javadoc}.

\begin{figure}[!h]
\begin{center}
\includegraphics[width=0.9\textwidth]{figs/scanner.png}
\caption{Screenshot of the documentation for \java{Scanner} on Oracle's website.}
\label{fig:javadoc}
\end{center}
\end{figure}

Scroll down to the ``Method Summary'' section.
In the previous chapter, we introduced methods for reading the ``next'' input.
As you can see, the \java{Scanner} class provides quite a few of them.
Click on the link for \java{nextInt}, and it will scroll down to more details:

\begin{stdout}
public int nextInt()
Scans the next token of the input as an int.
\end{stdout}

\index{signature}

The first line is the method's {\bf signature}, which specifies the name of the method, its return type, and parameters.
In this example, \java{nextInt} returns an \java{int}.
The empty parentheses mean that \java{nextInt} has no parameters.
The next line explains what the method does.
The subsequent lines (not shown) describe each parameter (if any) and the return value.
Explanations are often redundant, but the documentation is supposed to fit this standard format.
%The last line describes the exceptions this method might throw.

It might take some time to get comfortable reading this kind of information, but it's well worth the effort.
Knowing what methods a class provides helps you avoid reinventing the wheel.
Whenever you learn about a new class, you should take a quick look at its documentation.
On that note, take a few minutes to review the documentation for \java{System} and \java{String}.


\section{Writing documentation}

\index{Javadoc}

A nice feature of the Java language is the ability to write documentation at the same time you are writing the source code.
That way, the documentation stays in sync with the classes and methods themselves.
In fact, the HTML pages you browsed in the previous section were automatically generated using a tool called {\bf Javadoc}.
This tool is part of the standard JDK, and you can run it directly from DrJava by pressing the {\tt Javadoc} button on the toolbar.

\index{comments!documentation}
\index{documentation comments}

Javadoc parses your source files for {\bf documentation comments} and extracts other relevant information about your class and method definitions.
Given the prevalence of this tool, people sometimes refer to documentation as ``Javadoc comments.''
In contrast to inline comments that begin with \java{//}, documentation comments begin with \java{/**} (two stars) and end with \java{*/} (one star).
Anything in between these two tokens becomes part of the documentation.
%As a rule of thumb, you should document every class and every method.

\begin{code}
/**
 * Example program that demonstrates print vs println.
 */
public class Goodbye {

    /**
     * Application entry point; simply prints a greeting.
     */
    public static void main(String[] args) {
        System.out.print("Goodbye, ");  // note the space
        System.out.println("cruel world");
    }

}
\end{code}

This example has perhaps too many comments, since all the program does is print a single message.
But it illustrates the differences between inline and documentation comments:

\begin{itemize}
\item Inline comments tend to be short phrases that help explain complex parts of a method.
Documentation comments are typically complete sentences that begin with a capital letter and end with a period.

\item Documentation comments often span multiple lines.
By convention, each line begins with a \java{*} that is aligned vertically with the start and end of the comment.

\item Some development environments (e.g., Eclipse and NetBeans) automatically display documentation comments when you hover your mouse over the name of a class or method.

\end{itemize}

Writing documentation and inline comments is essential for making source code readable.
As we discussed in an earlier chapter, people spend the majority of their development time understanding and modifying existing code.
You should not only write good comments for others, but for yourself as well.
When you haven't looked at your own code for a while, it takes a long time to remember how it works (or what you were trying to do) if there's no comments.


\section{Stack diagrams and scope}
\label{stack}

\index{stack diagram}
\index{diagram!stack}

Pulling together the code examples from the previous section, here is a complete
class definition:

\begin{code}
public class PrintTwice {

    public static void printTwice(String s) {
        System.out.println(s);
        System.out.println(s);
    }

    public static void main(String[] args) {
        String argument = "Never say never.";
        printTwice(argument);
    }

}
\end{code}

Parameters and other variables only exist inside their own methods.
Within the confines of \java{main}, there is no such thing as \java{s}.
If you try to use it there, the compiler will complain.
Similarly, inside \java{printTwice} there is no such thing as \java{argument}.
That variable belongs to the \java{main} method.

One way to keep track of where each variable is defined is to draw a {\bf stack diagram}.
The stack diagram for this example looks like this:

\begin{figure}[!h]
\begin{center}
\includegraphics[scale=0.9]{figs/stack.pdf}
\caption{Stack diagram for the \java{PrintTwice} program.}
\end{center}
\end{figure}

\index{frame}

For each method there is a box called a {\bf frame} that contains the method's parameters and variables.
The name of the method appears outside the frame.
The value of each variable is drawn inside a box with the name of the variable beside it.
(Note for people who know too much: this diagram leaves out an important detail about strings that we will explain later.)

\index{scope}

Stack diagrams help you to visualize the {\bf scope} of a variable, which is the area of a program where a variable exists.
It's possible to have two variables with the same name in two different methods.
Each only exists within its own method, so they don't interfere with each other.


\section{Tracing with a debugger}
\label{debugger}

\index{debugger}

Keeping track of variables and methods on paper is a useful skill, and you should practice drawing stack diagrams.
Another way to visualize the scope of variables and the flow of execution is to use a {\bf debugger}.
Regardless which development environment you use, the overall process is the same:

\index{breakpoint}

\begin{enumerate}
\item Set {\bf breakpoints} on lines where you want the program to pause.
\item Step through the code one line at a time and watch what it does.
\item Check the values of variables and see when and how they change.
\end{enumerate}

For example, open any program in DrJava and move the cursor to the first line of \java{main}.
Press Ctrl+B to toggle a breakpoint on the current line; it should now be highlighted in red.
Press Ctrl+Shift+D to turn on Debug Mode; a new pane should appear at the bottom of the window.
(These commands are also available from the {\em Debugger} menu, in case you forget the shortcut keys.)

\index{call stack}

When you run the program, execution pauses at the first breakpoint.
The debug pane shows the {\bf call stack}, with the current method on top of the stack.
You might be surprised to see how many methods were called before the \java{main} method!
To the right are several buttons that allow you to step through the code at your own pace.
You can also press ``Automatic Trace'' to watch DrJava run your code one line at a time.

\begin{figure}[!h]
\begin{center}
\includegraphics[width=\textwidth]{figs/debugger.png}
\caption{Screenshot of the DrJava debugger.
Execution is currently paused on the first line of \java{printTwice}.
There is a breakpoint on the first line of \java{main}.}
\end{center}
\end{figure}

Using a debugger is like having the computer proofread your code out loud.
When the program is paused, you can examine (or even change) the value of any variable using the Interactions Pane.
Tracing allows you to verify how control and data passes from one method to another.
%You can edit your code while debugging it, but the changes won't take effect until after you compile.
%The result can be confusing, so we don't recommend it.
%The debugger may get out of sync if you add or delete multiple lines of code while the program is paused.
You might expect the code do one thing, but then the debugger shows it doing something else.
At that moment, you gain insight about what may be wrong with the code.


\section{Vocabulary}

\begin{description}

% Note: expanded definition from Chapter 1
\term{method}
A named sequence of statements that performs a procedure or function.
Methods may or may not take parameters, and may or may not return a value.

\term{invoke}
To call or run a method, i.e., cause it to execute.

\term{parameter}
A piece of information that a method requires before it can run.
Parameters are variables: they contain values and have types.

\term{argument}
A value that you provide when you invoke a method.
This value must have the same type as the corresponding parameter.

% Note: expanded definition from Chapter 2
\term{composition}
The ability to combine simple expressions and statements into compound expressions and statements, making it possible to use intermediate computations as arguments.

\term{order of execution}
The order in which Java executes methods and statements.
It may not necessarily be from top to bottom, left to right.

\term{parameter passing}
The process of assigning an argument value to a parameter variable.

\term{signature}
The first line of a method that defines its name, return type, and parameters.

\term{Javadoc}
A tool that reads Java source code and generates documentation in HTML format.

\term{documentation}
Comments that describe the technical operation of a class or method.

\term{stack diagram}
A memory diagram that shows which variables belong to which methods at a certain point in the program.
The methods calls are ``stacked'' from top to bottom, in the order of execution.

\term{frame}
A structure (represented by a box in stack diagrams) that contains a method's parameters and variables.

\term{scope}
The area of a program where a variable exists.

\term{debugger}
A tool that allows you to run one statement at a time and see the contents of variables.

\term{breakpoint}
A line of code where the debugger will pause a running program.

\term{call stack}
The history of method calls and where to resume execution after each method returns.

\end{description}


\section{Exercises}


\begin{exercise}

The point of this exercise is to practice reading code and to make sure that you understand the flow of execution through a program with multiple methods.

\begin{enumerate}

\item What is the output of the following program?
Be precise about where there are spaces and where there are newlines.
(Hint: Start by describing in words what \java{ping} and \java{baffle} do when they are invoked.)

\item Draw a stack diagram that shows the state of the program the first time \java{ping} is invoked.

%\item What happens if you add a method call to \java{baffle();} at the end of the \java{ping} method? (We will see why in the next chapter.)

\end{enumerate}

\begin{code}
    public static void zoop() {
        baffle();
        System.out.print("You wugga ");
        baffle();
    }
    public static void main(String[] args) {
        System.out.print("No, I ");
        zoop();
        System.out.print("I ");
        baffle();
    }
    public static void baffle() {
        System.out.print("wug");
        ping();
    }
    public static void ping() {
        System.out.println(".");
    }
\end{code}

\end{exercise}


\begin{exercise}
This exercise builds on the previous one by using parameters.
Make sure you understand both the order of execution and the flow of data.

\begin{enumerate}

\item Draw a stack diagram that shows the state of the program the {\it second} time \java{ping} is invoked.

\item What is the complete output of the program?

\end{enumerate}

\begin{code}
    public static void zoop(String fred, int bob) {
        System.out.println(fred);
        if (bob == 5) {
            ping("not ");
        } else {
            System.out.println("!");
        }
    }

    public static void main(String[] args) {
        int bizz = 5;
        int buzz = 2;
        zoop("just for", bizz);
        clink(2 * buzz);
    }

    public static void clink(int fork) {
        System.out.print("It's ");
        zoop("breakfast ", fork) ;
    }

    public static void ping(String strangStrung) {
        System.out.println("any " + strangStrung + "more ");
    }
\end{code}
\end{exercise}


\begin{exercise}

What is the difference between a variable and a method?
In terms of their syntax, how does the Java compiler tell the difference between the two?

%A variable is a {\em location of data}, whereas a method is a {\em location of code}.
%In Java, methods always have parentheses, even if they have no arguments like \java{System.out.println()}.

\end{exercise}


\begin{exercise}

Draw a stack diagram that shows the state of the program in Section~\ref{time} when \java{main} invokes \java{printTime} with the arguments \java{11} and \java{59}.

\end{exercise}


\begin{exercise}

The point of this exercise is to make sure you understand how to write and invoke methods that take parameters.

\begin{enumerate}
\item Write the first line of a method named \java{zool} that takes three parameters: an \java{int} and two \java{Strings}.

\item Write a line of code that calls \java{zool}, passing as arguments the value \java{11}, the name of your first pet, and the name of the street you grew up on.
\end{enumerate}

\end{exercise}


\begin{exercise}

The purpose of this exercise is to take code from a previous exercise and encapsulate it in a method that takes parameters.
You should start with a working solution to Exercise~\ref{ex:date}.

\begin{enumerate}

\item Write a method called \java{printAmerican} that takes the day, date, month and year as parameters and that prints them in American format.

\item Test your method by invoking it from \java{main} and passing appropriate arguments.
The output should look something like this (except that the date might be different):

\begin{stdout}
Saturday, July 16, 2011
\end{stdout}

\item Once you have debugged \java{printAmerican}, write another method called \java{printEuropean} that prints the date in European format.

\end{enumerate}

\end{exercise}


\chapter{Decisions and logic}

\index{boolean}
\index{type!boolean}

% TODO(ABD): I'd like an intro that presents the contents of the chapter in
% terms of new capabilities: what can we do at the end of this chapter
% that we can't do now?

The programs we've seen so far do pretty much the same thing every time, regardless of the input.
For more complex computations, programs usually react to the inputs, check for certain conditions, and generate appropriate results.
This chapter presents the features you need for programs to make complex decisions: a new data type called \java{boolean}, additional operators for expressing logic, and \java{if} statements.

%\java{boolean} is named after George Boole, who developed a formal system that represents logic using the values {\it true} and {\it false} and operations like {\it and}, {\it or}, and {\it not}.
%In Java, the values \java{true} and \java{false} belong to the data type \java{boolean}.

%\java{true} and \java{false} are special values in Java, and together they make up a type called {\bf boolean}.
%You might recall that when I defined a type, I said it was a set of values.
%In the case of \java{int}s, \java{double}s and \java{String}s, those sets are pretty big.
%For \java{boolean}s, there are only two values.
%The values \java{true} and \java{false} are keywords in Java, so they may appear in a different color, depending on your development environment.


\section{Assignment revisited}

\index{assignment}
\index{statement!assignment}

You can make more than one assignment to the same variable; the effect is to replace the old value with the new.
One way to remember this behavior is to think of variables as {\em containers}.
When you assign a value to a variable, you change the contents of the container.

\begin{center}
\includegraphics{figs/assign2.pdf}
\end{center}

%TODO(CSM): multiple assignment means "int x=0, y=0;" using the comma operator
%\index{multiple assignment}
%
%\begin{code}
%    int liz = 5;
%    System.out.print(liz);
%    liz = 7;
%    System.out.println(liz);
%\end{code}
%
%The output of this program is {\tt 57}, because the first time we print \java{liz} her value is 5, and the second time her value is 7.

When there are multiple assignments to a variable, it is especially important to distinguish between an assignment statement and a statement of equality.
Because Java uses the \java{=} symbol for assignment, it is tempting to interpret a statement like \java{a = b} as a statement of equality.
It is not!

First of all, equality is commutative, and assignment is not.
For example, in mathematics if $a = 7$ then $7 = a$.
In Java \java{a = 7;} is a legal assignment statement, but \java{7 = a;} is not.
Assignment {\em always} executes from right to left.

Furthermore, in mathematics, a statement of equality is true for all time.
If $a = b$ now, then $a$ will always equal $b$.
In Java, an assignment statement can make two variables equal, but they don't have to stay that way.

\begin{code}
    int a = 5;
    int b = a;     // a and b are now equal
    a = 3;         // a and b are no longer equal
\end{code}

The third line changes the value of \java{a}, but it does not change the value of \java{b}, so they are no longer equal.
In some programming languages a different symbol is used for assignment, such as {\tt <-} or {\tt :=}, to avoid this confusion.

%Although multiple assignment is frequently useful, you should use it with caution.
%If the values of variables change often, it can make the code difficult to read and debug.


\section{Relational operators}

\index{operator!relational}
\index{relational operator}
\index{operator!comparison}
\index{comparison operator}

{\bf Relational operators} are used to check conditions like whether two values are equal, or whether one is greater than the other.
The following expressions show how they are used:

\begin{code}
    x == y          // x is equal to y
    x != y          // x is not equal to y
    x > y           // x is greater than y
    x < y           // x is less than y
    x >= y          // x is greater than or equal to y
    x <= y          // x is less than or equal to y
\end{code}

The result of a relational operator is one of two special values, \java{true} or \java{false}.
These values belong to the type \java{boolean}; in fact, they are the only values for the type \java{boolean}.

You are probably familiar with these operations, but notice that the Java syntax is different from mathematical symbols like $=$, $\neq$, and $\le$.
A common error is to use a single \java{=} instead of a double \java{==}.
Remember that \java{=} is the assignment operator, and \java{==} is a comparison operator.
Also, there is no such thing as \java{=<} or \java{=>} operators.

The two sides of a relational operator have to be compatible.
For example, the expression \java{5 < "6"} is invalid because \java{5} is an \java{int} and \java{"6"} is a \java{String}.
When comparing values of different numeric types, Java applies the same conversion rules we saw previously with the assignment operator.
For example, when evaluating the expression \java{5 < 6.0}, Java automatically converts the \java{5} to \java{5.0}.

Most relational operators don't work with strings.
Confusingly, \java{==} and \java{!=} do work with strings---they just don't do what you expect.
We'll explain what they do later; in the meantime, don't use them with strings.
Instead, you should use the \java{String} methods \java{equals} and \java{compareTo}:

\begin{code}
    String fruit1 = "Apple";
    String fruit2 = "Orange";
    System.out.println(fruit1.equals(fruit2));
    System.out.println(fruit1.compareTo(fruit2));
\end{code}


\section{Conditional operators}

\index{conditional operator}
\index{operator!conditional}
\index{logical operator}
\index{operator!logical}

Java has three {\bf conditional operators}: \java{&&}, \java{||}, and \java{!}, which respectively stand for {\it and}, {\it or}, and {\it not}.
The semantics of these operators are similar to their meanings in English.

For example, \java{x > 0 && x < 10} is true when \java{x} is both greater than zero and less than 10.
The expression \java{evenFlag || n \% 3 == 0} is true if {\it either} condition is true, that is, if \java{evenFlag} is true or the number \java{n} is divisible by 3.
Finally, the \java{!} operator inverts a boolean expression.
So \java{!evenFlag} is \java{true} if \java{evenFlag} is \java{false}.

\index{short circuit}

Conditional operators evaluate the second expression only when necessary.
For example, \java{true || anything} is always true, so Java does not need to evaluate the expression \java{anything}.
Likewise, \java{false && anything} is always false.
Ignoring the second operand, when possible, is called {\bf short circuit} evaluation, by analogy with an electrical circuit.
Short circuit evaluation can save time, especially if \java{anything} is a method call.
It can also avoid unnecessary errors, if \java{anything} might fail based on the first operand.

\index{De Morgan's laws}

When solving logic problems using conditional operators, you will often need to negate \java{&&} and \java{||} operations.
{\bf De Morgan's laws} show how to simplify such expressions:

\begin{itemize}
\item \java{!(A && B)} ~is the same as~ \java{!A || !B}
\item \java{!(A || B)} ~is the same as~ \java{!A && !B}
\end{itemize}

In other words, negating a conditional expression is the same as negating each term and changing the operator.
Note that since the \java{!} operator has higher precedence than \java{&&} and \java{||}, you don't need to put parentheses around the individual terms \java{!A} and \java{!B}.

De Morgan's laws also apply to the relational operators.
In this case, negating each term means using the ``opposite'' relational operator.

\begin{itemize}
\item \java{!(x < 5 && y == 3)} ~is the same as~ \java{x >= 5 || y != 3}
\item \java{!(x >= 1 || y != 7)} ~is the same as~ \java{x < 1 && y == 7}
\end{itemize}

It may help to read these examples out loud in English.
For instance, ``If I don't want x to be less than 5, and I don't want y to be 3, then I need x to be greater than or equal to 5, or I need y to be anything but 3.''


\section{DrJava interactions}

A good way to gain experience with relational and conditional operators is to use the Interactions Pane of DrJava.
As shown in Figure~\ref{fig:drjava}, you can declare several variables and {\it interactively} test your logic skills.
Don't forget that you can try out many of the examples in this book this same way.

% try to determine their result before running the code.
%
% ABD: I worry about instructions like this, because students seldom follow them.
% Can we create some exercises (and move this section to the end of the chapter)?

\begin{figure}[!h]
\begin{center}
\includegraphics[width=\textwidth]{figs/drjava-logic.png}
\caption{Screenshot of the Interactions Pane in DrJava.}
\label{fig:drjava}
\end{center}
\end{figure}

There is one subtle detail to note when using the Interactions feature.
If you don't end an expression (or statement) with a semicolon, DrJava automatically prints its value.
Notice in Figure~\ref{fig:drjava} how the variable declarations end with semicolons, but the logic expressions in the following lines do not.

What's nice about this feature is that you don't have to create a new class, declare a main method, write arbitrary expressions inside \java{System.out.println} statements, save the source file, and get all of your code to compile in advance.
In addition, you can press the up/down arrows on the keyboard to repeat previous commands and experiment with incremental differences.

\index{order of operations}
\index{precedence}

Notice how none of the expressions in this example require parentheses.
Java evaluates arithmetic operators first, then the relational operators, then conditional operators, and finally the assignment operator.
Do a web search for ``java operator precedence'' to see the complete list of rules.
If two operators have the same precedence, Java evaluates them from left to right.


\section{The if-else statement}

\index{decision statement}
\index{statement!if}

To write useful programs, we almost always need to check conditions and react accordingly.
{\bf Decision statements} give us this ability.
The simplest decision statement in Java is the \java{if} statement:

\begin{code}
    if (x > 0) {
        System.out.println("x is positive");
    }
\end{code}

The expression in parentheses is called the condition.
If it is true, the statements in braces get executed.
If the condition is false, execution skips over that block of code.
The condition in parentheses can be {\it any} boolean expression.

\index{branch}
\index{statement!else}
\index{decision!alternative}

A second form of decision statement is alternative execution, in which there are two possibilities indicated by \java{if} and \java{else}.
The possibilities are called {\bf branches}, and the condition determines which one gets executed:

\begin{code}
    if (x % 2 == 0) {
        System.out.println("x is even");
    } else {
        System.out.println("x is odd");
    }
\end{code}

If the remainder when \java{x} is divided by 2 is zero, we know that \java{x} is even, and this code prints a message to that effect.
If the condition is false, the second print statement is executed instead.
Since the condition must be true or false, exactly one of the alternatives will be executed.

%\label{alternative}
%\index{parity}
%
%To follow up the previous chapter, if you need to check the {\bf parity} (evenness or oddness) of numbers often, you might want to ``wrap'' this code up in a method:
%
%\begin{code}
%    public static void printParity(int x) {
%        if (x % 2 == 0) {
%            System.out.println("x is even");
%        } else {
%            System.out.println("x is odd");
%        }
%    }
%\end{code}
%
%Now you have a method named \java{printParity} that will print an appropriate message for any integer you care to provide.
%In \java{main} you would invoke this method as follows:
%
%\begin{code}
%    printParity(17);
%\end{code}
%
%Always remember that when you invoke a method, you do not have to declare the types of the arguments you provide.
%Java can figure out what type they are.
%You should resist the temptation to write things like:
%
%\begin{code}
%    int number = 17;
%    printParity(int number);        // WRONG!!!
%\end{code}

\index{decision!chained}

Sometimes you want to check related conditions and choose one of several actions.
One way to do this is by {\bf chaining} a series of \java{if} and \java{else} statements:

\begin{code}
    if (x > 0) {
        System.out.println("x is positive");
    } else if (x < 0) {
        System.out.println("x is negative");
    } else {
        System.out.println("x is zero");
    }
\end{code}

These chains can be as long as you want, although they can be difficult to read if they get out of hand.
One way to make them easier to read is to use standard indentation, as demonstrated in these examples.
If you keep all the statements and braces lined up, you are less likely to make syntax errors.

\index{decision!nested}
\index{nested structure}

In addition to chaining, you can also make complex decisions by {\bf nesting} one decision inside another.
We could have written the previous example as:

\begin{code}
    if (x == 0) {
        System.out.println("x is zero");
    } else {
        if (x > 0) {
            System.out.println("x is positive");
        } else {
            System.out.println("x is negative");
        }
    }
\end{code}

The outer conditional has two branches:
the first branch contains a \java{print} statement; the second branch contains another decision statement, which has two branches of its own.
Each of them is a \java{print} statement, but they could have been decision statements as well.

These kinds of nested structures are common, but they get difficult to read very quickly.
Good indentation is essential to make the structure (or intended structure) apparent to the reader.


\section{Flag variables}

\index{expression!boolean}

Recall from Section~\ref{sec:arithops} that an expression is a combination of variables and operators that evaluates to a single value.
Expressions can be as simple as the literal \java{0} or more complex like \java{Math.cos(angle + Math.PI / 2)}.
Boolean expressions and variables work just like other types of expressions and variables:

\begin{code}
    boolean flag;
    flag = true;
    boolean testResult = false;
\end{code}

\index{initialization}
\index{statement!initialization}

The first line is a variable declaration, the second is an assignment, and the third is an initialization.
Since relational operators evaluate to a \java{boolean} value, you can store the result of a comparison in a variable:

\begin{code}
    boolean evenFlag = (n % 2 == 0);    // true if n is even
    boolean positiveFlag = (x > 0);     // true if x is positive
\end{code}

The parentheses are unnecessary, but they make the code easier to read.
A variable defined in this way is called a {\bf flag}, because it signals the presence or absence of some condition.

You can use flag variables as part of a conditional statement later:

\begin{code}
    if (evenFlag) {
        System.out.println("n was even when I checked it");
    }
\end{code}

Notice that you don't need to say \java{if (evenFlag == true)}.
Since \java{evenFlag} is a \java{boolean}, it's already a condition.
Likewise, to check if a flag is \java{false}:

\begin{code}
    if (!evenFlag) {
        System.out.println("n was odd when I checked it");
    }
\end{code}


\section{The return statement}

\index{return}
\index{statement!return}

The \java{return} statement allows you to terminate a method before you reach the end of it.
One reason to use \java{return} is if you detect an error condition:

\begin{code}
    public static void printLogarithm(double x) {
        if (x <= 0.0) {
            System.err.println("Error: x must be positive.");
            return;
        }
        double result = Math.log(x);
        System.out.println("The log of x is " + result);
    }
\end{code}

This example defines a method named \java{printLogarithm} that takes a \java{double} value (named \java{x}) as a parameter.
It checks whether \java{x} is less than or equal to zero, in which case it prints an error message and then uses \java{return} to exit the method.
The flow of execution immediately returns to the caller, and the remaining lines of the method are not executed.

\index{System.err}

Notice the floating-point value \java{0.0} on the right side of the condition.
Since \java{x} is a floating-point variable, you should compare it to a floating-point literal.
This example also uses \java{System.err}, which is the {\it standard error} output stream.
Your development environment might distinguish normal output and error output by using a different color.


\section{Validating input}

Here is a simple program that makes use of the \java{printLogarithm} method defined in the previous section:

\begin{code}
    public static void main(String args[]) {
        Scanner in = new Scanner(System.in);
        System.out.print("Enter a number: ");
        double x = in.nextDouble();
        printLogarithm(x);
    }
\end{code}

Up to this point, we have assumed that users always do what they're told.
But what happens if they make an innocent mistake?
Or even worse, what happens if they deliberately try to crash your program?

\begin{stdout}
Enter a number: Hello
Exception in thread "main" java.util.InputMismatchException
    at java.util.Scanner.throwFor(Scanner.java:909)
    at java.util.Scanner.next(Scanner.java:1530)
    at java.util.Scanner.nextDouble(Scanner.java:2456)
    at Example.main(Example.java:17)
\end{stdout}

In this example, the program calls the \java{nextDouble} method, so the \java{Scanner} attempts to parse a \java{double}.
However the user input is \java{"Hello"}, which causes an \java{InputMismatchException}.
We can prevent this error from happening by checking the input before parsing it:

\begin{code}
    public static void main(String args[]) {
        Scanner in = new Scanner(System.in);
        System.out.print("Enter a number: ");
        if (!in.hasNextDouble()) {
            String word = in.next();
            System.err.println(word + " is not a number");
            return;
        }
        double x = in.nextDouble();
        printLogarithm(x);
    }
\end{code}

The \java{Scanner} class provides \java{hasNext} methods for each of the \java{next} methods.
They return \java{true} or \java{false}, depending on the format of the next token of input.
In this example, we call \java{hasNextDouble} to check if the user entered a \java{double}.
If not, then we display an error message (using \java{System.err}) and abort the program.

If you \java{return} from \java{main}, the program ends immediately.
Notice also the use of the \java{!} operator, instead of the test \java{hasNextDouble() == false}.
Since the \java{hasNextDouble} method returns a boolean result, it is already a condition.


\section{Recursive methods}
\label{recursion}

\index{recursion}

Now that we have methods and if statements, we can explore one of the most magical and interesting things a program can do.
It is common for one method to invoke another, but what happens if a method invokes {\em itself}?
This process is called {\bf recursion}.
Consider the following example:

\begin{code}
    public static void countdown(int n) {
        if (n == 0) {
            System.out.println("Blastoff!");
        } else {
            System.out.println(n);
            countdown(n - 1);
        }
    }
\end{code}

The name of the method is \java{countdown}; it takes a single integer as a parameter.
If the parameter is zero, it prints the word ``Blastoff.''
Otherwise, it prints the number and then invokes itself, passing \java{n - 1} as the argument.

What happens if we invoke \java{countdown(3)} from \java{main}?

\vspace{-1ex}
\begin{quote}
The execution of \java{countdown} begins with \java{n == 3}, and since \java{n} is not zero, it prints the value 3, and then invokes itself...
\begin{quote}
The execution of \java{countdown} begins with \java{n == 2}, and since \java{n} is not zero, it prints the value 2, and then invokes itself...
\begin{quote}
The execution of \java{countdown} begins with \java{n == 1}, and since \java{n} is not zero, it prints the value 1, and then invokes itself...
\begin{quote}
The execution of \java{countdown} begins with \java{n == 0}, and since \java{n} is zero, it prints the word ``Blastoff!'' and then returns.
\end{quote}
The \java{countdown} that got \java{n == 1} returns.
\end{quote}
The \java{countdown} that got \java{n == 2} returns.
\end{quote}
The \java{countdown} that got \java{n == 3} returns.
\end{quote}
\vspace{-1ex}

And then you're back in \java{main}.
So the total output looks like:

\begin{stdout}
3
2
1
Blastoff!
\end{stdout}

As a second example, we'll rewrite the methods \java{newLine} and \java{threeLine} from Section~\ref{adding_methods}.

\begin{code}
    public static void newLine() {
        System.out.println();
    }

    public static void threeLine() {
        newLine();
        newLine();
        newLine();
    }
\end{code}

\index{newline}

Although these methods work, they would not be much help if we wanted to print 2 newlines, or 106.
A better alternative would be:

\begin{code}
    public static void nLines(int n) {
        if (n > 0) {
            System.out.println();
            nLines(n - 1);
        }
    }
\end{code}

This method is similar to \java{countdown}.
As long as $n$ is greater than zero, it prints a newline and then invokes itself to print $(n-1)$ additional newlines.
The total number of newlines is $1 + (n - 1)$, which is just what we wanted: $n$.


\section{Recursive stack diagrams}

\index{stack diagram}
\index{diagram!stack}

In the previous chapter, we used a stack diagram to represent the state of a program during a method invocation.
The same kind of diagram can make it easier to interpret a recursive method.

Remember that every time a method gets called, Java creates a new frame in memory that contains the current method's parameters and variables.
The following figure is a stack diagram for countdown, called with \java{n == 3}:

\begin{figure}[!h]
\begin{center}
\includegraphics{figs/stack2.pdf}
\caption{Stack diagram for the \java{countdown} program.}
\end{center}
\end{figure}

Note that the ``stack'' of method calls is upside down.
It's easier to draw stack diagrams from top to bottom, because you don't always know how much vertical space you will need in advance.

The stack frame for \java{main} is empty because \java{main} does not have any local variables.
It has one parameter, \java{args}, but since we're not using it, we left it out of the diagram.

There are four frames for \java{countdown}, each with a different value for the parameter \java{n}.
The last frame, with \java{n == 0}, is called the {\bf base case}.
It does not make a recursive call, so there are no more frames below it.

You should always check for a base case in your code, or else the recursion may keep going until the program runs out of memory.
For example, here is a recursive method without a base case:

\begin{code}
    public static void forever(String s) {
        System.out.println(s);
        forever(s);
    }
\end{code}

\index{call stack}
\index{stack overflow}

This \java{forever} method prints the string over 10,000 times, but then the program suddenly terminates with a \java{StackOverflowError}.
In other words, there's no more room on the stack for additional method calls.

Java sets aside a reasonable amount of memory for the call stack, so that it can remember where to return at the end of each method.
But if that memory fills up, it's usually because you have infinite recursion.

%Recall from Section~\ref{debugger} that Java automatically tracks the call and return of each method in memory, much like the stack diagrams we draw on paper.
%Each method call takes a little memory, but that memory can be reused when the method returns.


\section{Binary Numbers}

The \java{countdown} example has three parts: (1) it checks the base case, (2) prints something, and (3) makes a recursive call.
What do you think happens if you reverse steps 2 and 3, making the recursive call {\it before} printing?

\begin{code}
    public static void countup(int n) {
        if (n == 0) {
            System.out.println("Blastoff!");
        } else {
            countup(n - 1);
            System.out.println(n);
        }
    }
\end{code}

The stack diagram is the same as before, and the method is still called $n$ times.
But now the \java{System.out.println} happens just before each recursive call returns.
As a result, it counts up instead of down:

\begin{stdout}
Blastoff!
1
2
3
\end{stdout}

This behavior comes in handy when it is easier to compute results in reverse order.
For example, to convert a decimal integer into its {\bf binary} representation, you repeatedly divide the number by two:

\begin{stdout}
23 / 2 is 11 remainder 1
11 / 2 is  5 remainder 1
 5 / 2 is  2 remainder 1
 2 / 2 is  1 remainder 0
 1 / 2 is  0 remainder 1
\end{stdout}

So 23 in binary is 10111, which is the remainders in the above example from bottom to top.
Here is a recursive method that prints the binary representation of any positive integer:

\begin{code}
    public static void showBinary(int value) {
        if (value > 0) {
            showBinary(value / 2);
            System.out.print(value % 2);
        }
    }
\end{code}

If \java{value} is zero, \java{showBinary} does nothing (that's the base case).
If the argument is positive, the method divides it by two and calls \java{showBinary} recursively.
When the recursive call returns, the method prints one digit of the result and returns (again).
The leftmost digit is at the bottom of the stack, so it gets printed first.  The rightmost digit, at the top of the stack, gets printed last.

\begin{code}
    showBinary(23);
    // output is 10111
\end{code}

Learning to think recursively is an important aspect of learning to think like a computer scientist.
Many algorithms can be written concisely with recursive methods that perform computations on the way down, on the way up, or both.


\section{Vocabulary}

\begin{description}

\term{boolean}
A data type with only two values, \java{true} and \java{false}.

\index{operator!relational}
\term{relational operator}
An operator that compares two values and produces a boolean indicating the relationship between them.

\index{operator!conditional}
\term{conditional operator}
An operator that combines boolean values and produces boolean values.

\term{short circuit}
A way of evaluating conditional operators that only evaluates the second operand if necessary.

\term{De Morgan's laws}
Mathematical rules that show how to negate a conditional expression.

\term{decision statement}
A statement that uses a condition to determine which statements to execute.

\term{branch}
One of the alternative sets of statements inside a decision statement.

\term{chaining}
A way of joining several conditional statements in sequence.

\term{nesting}
Putting a conditional statement inside one or both branches of another conditional statement.

\term{flag}
A variable (usually \java{boolean}) that represents a condition or status.

\term{recursion}
The process of invoking the same method that you are currently executing.

\term{base case}
A condition that causes a recursive method {\it not} to make another recursive call.

\term{binary}
A system that uses only zeros and ones to represent numbers.
Also known as ``base 2.''

\end{description}


\section{Exercises}


\begin{exercise}

Conditional operators can simplify nested decision structures.
For example, how can you rewrite this code using a single \java{if} statement?

\begin{code}
    if (x > 0) {
        if (x < 10) {
            System.out.println("x is a positive single digit.");
        }
    }
\end{code}

\end{exercise}


\begin{exercise}

Fermat's Last Theorem says that there are no integers $a$, $b$, and $c$ such that
\[ a^n + b^n = c^n \]
except in the case when $n \leq 2$ (e.g., the Pythagorean Theorem).

Write a method named \java{checkFermat} that takes four integers as parameters---\java{a}, \java{b}, \java{c} and \java{n}---and that checks to see if Fermat's theorem holds.
If $n$ is greater than 2 and it turns out to be true that $a^n + b^n = c^n$, the program should print ``Holy smokes, Fermat was wrong!''
Otherwise the program should print ``No, that doesn't work.''

HINT: You may want to use \java{Math.pow} in your method.

\end{exercise}


\begin{exercise}

The purpose of this exercise is to take a problem and break it into smaller problems, and to solve the smaller problems by writing simple methods. Consider the first verse of the song ``99 Bottles of Pop'':

\begin{quote}
99 bottles of pop on the wall,\\
99 bottles of pop,\\
If one of those bottles should happen to fall,\\
98 bottles of pop on the wall.
\end{quote}

Subsequent verses are identical except that the number of bottles gets smaller by one in each verse, until the last verse:

\begin{quote}
1 bottle of pop on the wall,\\
1 bottle of pop,\\
If that last bottle should happen to fall,\\
No more bottles of pop on the wall.
\end{quote}

%And then the song (finally) ends.

Write a program that prints the entire lyrics of ``99 Bottles of Pop.''
Your program should include a {\it recursive} method that does the hard part, but you might want to write additional methods to separate the major functions of the program.
As you develop your code, test it with a small number of verses like ``3 Bottles of Pop.''

\end{exercise}


\begin{exercise}

Draw a stack diagram that shows the state of the program in Section~\ref{recursion} after \java{main} invokes \java{nLines} with the parameter \java{n == 4}, just before the last invocation of \java{nLines} returns.

\end{exercise}


\begin{exercise}

This exercise reviews the flow of execution through a program with multiple methods.
Read the following code and answer the questions.

\begin{code}
public class Buzz {

    public static void baffle(String blimp) {
        System.out.println(blimp);
        zippo("ping", -5);
    }

    public static void zippo(String quince, int flag) {
        if (flag < 0) {
            System.out.println(quince + " zoop");
        } else {
            System.out.println("ik");
            baffle(quince);
            System.out.println("boo-wa-ha-ha");
        }
    }

    public static void main(String[] args) {
        zippo("rattle", 13);
    }

}
\end{code}

\begin{enumerate}

\item Write the number {\tt 1} next to the first {\em statement} of this program that will be executed.
Be careful to distinguish things that are statements from things that are not.

\item Write the number {\tt 2} next to the second statement, and so on until the end of the program.
If a statement is executed more than once, it might end up with more than one number next to it.

\item What is the value of the parameter \java{blimp} when \java{baffle} gets invoked?

\item What is the output of this program?

\end{enumerate}

\end{exercise}


\chapter{Value methods}

\index{method!value}
\index{method!void}
\index{value method}
\index{void method}

Some of the methods we have used, like the \java{Math} methods, return values.
Others, like \java{println} and \java{newLine}, perform an action but don't return a value.
In Chapter~\ref{voidmeth}, we called methods that don't return a value {\bf void methods}.
The focus of this chapter is {\bf value methods}, or methods that compute and return a result.


\section{Return values}

\index{void}

The methods we have written so far, like \java{countdown} and \java{countup}, don't return values, which is why the first line has the keyword \java{void}.

\begin{code}
    public static void countup(int n) {
        if (n == 0) {
            System.out.println("Blastoff!");
        } else {
            countup(n - 1);
            System.out.println(n);
        }
    }
\end{code}

When you invoke a \java{void} method, it is typically on a line all by itself:

\begin{code}
    countup(3);
    System.out.println("Have a nice day.");
\end{code}

When you invoke a value method, it returns a value which we usually assign to a variable or use as part of an expression:

\begin{code}
    double error = Math.abs(expected - actual);
    double height = radius * Math.sin(angle);
\end{code}

\index{value method}
\index{method!value}

In this chapter, you will learn to write methods that return values.
Here's an example:  \java{area} takes a \java{double} as a parameter and returns the area of a circle with that radius:

\begin{code}
    public static double area(double radius) {
        double area;
        area = Math.PI * radius * radius;
        return area;
    }
\end{code}

The first thing you should notice is that the beginning of the method definition is different.
Instead of \java{public static void}, which indicates a \java{void} method, we see \java{public static double}, which means that the return value from this method is a \java{double}.
%I still haven't explained what \java{public static} means, but be patient.

\index{return}
\index{statement!return}

The last line is a new form of the \java{return} statement that includes a return value.
This statement means, ``return immediately from this method and use the following expression as the return value.''
The expression you provide can be arbitrarily complex, so we could have written this method more concisely:

\begin{code}
    public static double area(double radius) {
        return Math.PI * radius * radius;
    }
\end{code}

\index{temporary variable}
\index{variable!temporary}

On the other hand, {\bf temporary} variables like \java{area} often make debugging easier, especially when you are stepping through code using a debugger.

The type of the expression in the \java{return} statement must match the return type of the method.
When you declare that the return type is \java{double}, you are making a promise that this method will eventually produce a \java{double} value.
If you try to \java{return} with no expression, or an expression with the wrong type, the compiler will generate an error.

Sometimes it is useful to have multiple return statements, for example, one in each branch of a decision:

\begin{code}
    public static double absoluteValue(double x) {
        if (x < 0) {
            return -x;
        } else {
            return x;
        }
    }
\end{code}

Since these \java{return} statements are in an alternative structure, only one will be executed.
Although it is legal to have more than one \java{return} statement in a method, you should keep in mind that as soon as one is executed, the method terminates without executing any subsequent statements.

\index{dead code}

Code that appears after a \java{return} statement, or any place else where it can never be executed, is called {\bf dead code}.
The compiler will give you an ``unreachable statement'' error if part of your code is dead.

\begin{code}
    public static double absoluteValue(double x) {
        if (x < 0) {
            return -x;
        } else {
            return x;
        }
        System.out.println("This line is dead.");
    }
\end{code}

If you put \java{return} statements inside of a decision, you have to guarantee that {\em every possible path} through the program reaches a \java{return} statement.

\begin{code}
    public static double absoluteValue(double x) {
        if (x < 0) {
            return -x;
        } else if (x > 0) {
            return x;
        }
        // syntax error
    }
\end{code}

This program is not legal because when \java{x} is 0, neither condition is true.
As a result, the method ends without hitting a return statement.
The typical compiler error message is ``missing return statement'', which is confusing since there are already two of them.


\section{Writing methods}
\label{distance}

\index{incremental development}

At this point you should be able to look at Java methods and tell what they do.
But it may not be clear yet how to go about writing them.
In this section, we are going to model a technique called {\bf incremental development}.
As an example, imagine you want to find the distance between two points, given by the coordinates $(x_1, y_1)$ and $(x_2, y_2)$.
By the usual definition:

\[ distance = \sqrt{(x_2 - x_1)^2 +(y_2 - y_1)^2} \]

The first step is to consider what a \java{distance} method should look like in Java.
In other words, what are the inputs (parameters) and what is the output (return value)?
In this case, the two points are the parameters, and it is natural to represent them using four \java{double} values.
%, although we will see later that there is a \java{Point} object in Java that we could use.
The return value is the distance, which should also have type \java{double}.

\index{stub}

Already we can write an outline for the method, which is sometimes called a {\bf stub}.
This code includes the method signature and a \java{return} statement:

\begin{code}
    public static double distance
            (double x1, double y1, double x2, double y2) {
        return 0.0;
    }
\end{code}

The return statement is a placeholder that is necessary for the program to compile.
At this stage the program doesn't do anything useful, but it is worthwhile to compile it so we can identify any syntax errors before we add more code.

It's always a good idea to think about testing {\it before} you develop new methods; it can help you figure out how to implement them.
To test this new method, we can invoke it (in \java{main}) using sample values:

\begin{code}
    double dist = distance(1.0, 2.0, 4.0, 6.0);
\end{code}

These values make the horizontal distance 3.0 and the vertical distance 4.0.
That way, the result should be 5.0, the hypotenuse of a 3-4-5 triangle.
When you are testing a method, it is useful to know the right answer.

Once we have checked the syntax of the method definition, we can start adding lines of code one at a time.
After each incremental change, we recompile and run the program.
If there is an error at any point, we have a good idea where to look: the last line we added.

The next step is to find the differences $x_2 - x_1$ and $y_2 - y_1$.
We store those values in temporary variables named \java{dx} and \java{dy}.

\begin{code}
    public static double distance
            (double x1, double y1, double x2, double y2) {
        double dx = x2 - x1;
        double dy = y2 - y1;
        System.out.println("dx is " + dx);
        System.out.println("dy is " + dy);
        return 0.0;
    }
\end{code}

\index{scaffolding}

The print statements allows us to check the intermediate values before proceeding.
They should be 3.0 and 4.0.
We will remove the print statements when the method is finished.
Code like that is called {\bf scaffolding}, because it is helpful for building the program, but it is not part of the final product.

The next step is to square \java{dx} and \java{dy}.
We could use the \java{Math.pow} method, but it is simpler to multiply each term by itself.

\begin{code}
    public static double distance
            (double x1, double y1, double x2, double y2) {
        double dx = x2 - x1;
        double dy = y2 - y1;
        double dsquared = dx * dx + dy * dy;
        System.out.println("dsquared is " + dsquared);
        return 0.0;
    }
\end{code}

Again, you should compile and run the program at this stage and check the intermediate value, which should be 25.0.
Finally, we can use \java{Math.sqrt} to compute and return the result.

\begin{code}
    public static double distance
            (double x1, double y1, double x2, double y2) {
        double dx = x2 - x1;
        double dy = y2 - y1;
        double dsquared = dx*dx + dy*dy;
        double result = Math.sqrt(dsquared);
        return result;
    }
\end{code}

%In \java{main}, we can print and check the value of the result.

As you gain more experience programming, you might write and debug more than one line at a time.
Nevertheless, incremental development can save you a lot of time.
The key aspects of the process are:

\begin{itemize}

\item Start with a working program and make small, incremental changes.
At any point, if there is an error, you will know where to look.

\item Use temporary variables to hold intermediate values so you can check them, either with print statements or by using a debugger.

\item Once the program is working, you can remove scaffolding and consolidate multiple statements into compound expressions (but only if it does not make the program more difficult to read).

\end{itemize}


\section{Method composition}

\index{composition}

Once you define a new method, you can use it as part of an expression, or build new methods using existing methods.
For example, suppose someone gave you two points, the center of the circle and a point on the perimeter, and asked for the area of the circle.
Let's say the center point is stored in the variables \java{xc} and \java{yc}, and the perimeter point is in \java{xp} and \java{yp}.

The first step is to find the radius of the circle, which is the distance between the two points.
Fortunately, we have a method that does just that (\java{distance}).

% ABD: I am inclined to uncomment these code snippets before showing
% the complete function

\begin{code}
    double radius = distance(xc, yc, xp, yp);
\end{code}

The second step is to find the area of a circle with that radius.
We have a method for that computation too (\java{area}).

\begin{code}
    double area = area(radius);
    return area;
\end{code}

Putting everything together in a new method, we get:

\begin{code}
    public static double circleArea
            (double xc, double yc, double xp, double yp) {
        double radius = distance(xc, yc, xp, yp);
        double area = area(radius);
        return area;
    }
\end{code}

The temporary variables \java{radius} and \java{area} are useful for development and debugging, but once the program is working we can make it more concise by {\it composing} the method calls:

\begin{code}
    public static double circleArea
            (double xc, double yc, double xp, double yp) {
        return area(distance(xc, yc, xp, yp));
    }
\end{code}

Computer scientists deal with the complexity of large programs by breaking down computations into individual methods (which in turn may call other methods).
Data is passed around the program via method parameters and return statements.
By using incremental development, scaffolding, and testing, you can be confident that your code is correct.


\section{Overloading}
\label{overloading}

You might have noticed that \java{circleArea} and \java{area} perform similar functions.
They both find the area of a circle, but they take different parameters.
For \java{area}, we have to provide the radius; for \java{circleArea} we provide two points.

\index{overloading}

If two methods do the same thing, it is natural to give them the same name.
Having more than one method with the same name is called {\bf overloading}, and it is legal in Java as long as each version takes different parameters.
So we could rename \java{circleArea} to \java{area}:

\begin{code}
    public static double area
            (double x1, double y1, double x2, double y2) {
        return area(distance(xc, yc, xp, yp));
    }
\end{code}

Note that this new \java{area} method is {\em not} recursive.
When you invoke an overloaded method, Java knows which version you want by looking at the arguments that you provide.
If you write:

\begin{code}
    double x = area(3.0);
\end{code}

Java goes looking for a method named \java{area} that takes one \java{double} as an argument, and so it uses the first version, which interprets the argument as a radius.
If you write:

\begin{code}
    double x = area(1.0, 2.0, 4.0, 6.0);
\end{code}

Java uses the second version of \java{area}, which
actually invokes the first version.

Many Java methods are overloaded, meaning that there are different versions that accept different numbers or types of parameters.
For example, there are versions of \java{print} and \java{println} that accept a single parameter of any data type.
In the Math class, there is a version of \java{abs} that works on \java{double}s, and there is also a version for \java{int}s.

Although overloading is a useful feature, it should be used with caution.
You might get yourself nicely confused if you are trying to debug one version of a method while accidentally invoking a different one.


\section{Boolean methods}
\label{boolean}

\index{boolean}
\index{method!boolean}

Methods can return \java{boolean} values just like any other type, which is often convenient for hiding tests inside methods.
For example:

\begin{code}
    public static boolean isSingleDigit(int x) {
        if (x >= 0 && x < 10) {
            return true;
        } else {
            return false;
        }
    }
\end{code}

The name of this method is \java{isSingleDigit}.
It is common to give \java{boolean} methods names that sound like yes/no questions.
Since the return type is \java{boolean}, the return statement has to provide a boolean expression.

The code itself is straightforward, although it is longer than it needs to be.
Remember that the expression \java{x >= 0 \&\& x < 10} has type boolean, so there is nothing wrong with returning it directly (without the \java{if} statement):

\begin{code}
    public static boolean isSingleDigit(int x) {
        return x >= 0 && x < 10;
    }
\end{code}

In \java{main}, you can invoke the method in the usual ways:

\begin{code}
    System.out.println(isSingleDigit(2));
    boolean bigFlag = !isSingleDigit(17);
\end{code}

The first line prints \java{true} because 2 is a single-digit number.
The second line sets \java{bigFlag} to \java{true}, because 17 is {\em not} a single-digit number.

Decision statements often invoke \java{boolean} methods for the condition:

\begin{code}
    if (isSingleDigit(x)) {
        System.out.println("x is small");
    } else {
        System.out.println("x is big");
    }
\end{code}


\section{More recursion}
\label{factorial}

\index{recursion}
\index{language!complete}

\index{Turing, Alan}
\index{Church, Alonzo}

Now that we have methods that return values, we have a {\bf Turing complete} programming language.
That means Java can compute anything computable, for any reasonable definition of ``computable''.
This idea was developed by Alonzo Church and Alan Turing, so it is known as the Church-Turing thesis.
%You can read more about it at \url{http://en.wikipedia.org/wiki/Turing_thesis}.

To give you an idea of what you can do with the tools we have learned, let's look at some methods for evaluating recursively-defined mathematical functions.
A recursive definition is similar to a circular definition, in the sense that the definition contains a reference to the thing being defined.
A truly circular definition is not very useful:

\begin{description}
\term{recursive} an adjective used to describe a method that is recursive.
\end{description}

If you saw that definition in the dictionary, you might be annoyed.
In fact, if you search for recursion on Google, it displays ``Did you mean: recursion'' as an inside joke.

\index{factorial}

Many mathematical functions are defined recursively.
For example, if you look up the definition of {\bf factorial}, you get something like:

\vspace{-1ex}
\begin{eqnarray*}
&&  0! = 1 \\
&&  n! = n \cdot(n-1)!
\end{eqnarray*}
\vspace{-1ex}

Factorial is usually denoted with the symbol $!$, which is not to be confused with the Java operator \java{!} that means NOT.

This definition says that the factorial of 0 is 1, and the factorial of any other value $n$ is $n$ multiplied by the factorial of $n-1$.
So $3!$ is 3 times $2!$, which is 2 times $1!$, which is 1 times $0!$, which is 1.
Putting it all together, we get $3!$ equal to 3 times 2 times 1 times 1, which is 6.

If you can formulate a recursive definition of something, you can easily write a Java method to evaluate it.
The first step is to decide what the parameters and return type are.
Since factorial is defined for integers, the method takes an \java{int} as a parameter and returns an \java{int}.
So here's a good starting place:

\begin{code}
    public static int factorial(int n) {
        return 0;
    }
\end{code}

Next, we think about the base case.
If the argument happens to be zero, we simply return 1.

\begin{code}
    public static int factorial(int n) {
        if (n == 0) {
            return 1;
        }
        return 0;
    }
\end{code}

Otherwise, and this is the interesting part, we have to make a recursive call to find the factorial of $n-1$, and then multiply it by $n$.

\begin{code}
    public static int factorial(int n) {
        if (n == 0) {
            return 1;
        }
        int recurse = factorial(n - 1);
        int result = n * recurse;
        return result;
    }
\end{code}

The flow of execution for this program is similar to \java{countdown} from Section~5.8.
If we invoke \java{factorial} with the value 3:

\vspace{-1ex}
\begin{quote}
Since 3 is not zero, we take the second branch and calculate the factorial of $n-1$...
\begin{quote}
Since 2 is not zero, we take the second branch and calculate the factorial of $n-1$...
\begin{quote}
Since 1 is not zero, we take the second branch and calculate the factorial of $n-1$...
\begin{quote}
Since 0 {\em is} zero, we take the first branch and return the value 1 immediately.
% without making any more recursive invocations.
\end{quote}
The return value (1) gets multiplied by \java{n}, which is 1, and the result is returned.
\end{quote}
The return value (1) gets multiplied by \java{n}, which is 2, and the result is returned.
\end{quote}
The return value (2) gets multiplied by \java{n}, which is 3, and the result, 6, is returned to whatever invoked \java{factorial(3)}.
\end{quote}
\vspace{-1ex}

\index{stack}
\index{diagram!stack}

Figure~\ref{fig:stack3} shows what the stack diagram looks like for this sequence of method invocations.
The return values are shown being passed back up the stack.
Notice that \java{recurse} and \java{result} do not exist in the last frame, because when \java{n == 0} the code that creates them does not execute.

\begin{figure}[!h]
\begin{center}
\includegraphics{figs/stack3.pdf}
\caption{Stack diagram for the \java{factorial} method.}
\label{fig:stack3}
\end{center}
\end{figure}


\section{Leap of faith}
\label{leap of faith}

\index{leap of faith}

Following the flow of execution is one way to read programs, but it can quickly become overwhelming.
An alternative is a ``leap of faith'':
when you come to a method invocation, instead of following the flow of execution, you {\em assume} that the method works correctly and returns the appropriate value.

In fact, you are already practicing this leap of faith when you use methods in the Java library.
When you invoke \java{Math.cos} or \java{System.out.println}, you don't examine the implementations of those methods.
You just assume that they work properly.

You should apply the same reasoning to your own methods.
For example, in Section~\ref{boolean} we wrote a method called \java{isSingleDigit} that determines whether a number is between 0 and 9.
Once we convince ourselves that this method is correct---by testing and examination of the code---we can use the method without ever looking at the implementation again.

The same is true of recursive programs.
When you get to the recursive call, instead of following the flow of execution you should {\em assume} that the recursive invocation works.
For example, ``Assuming that I can find the factorial of $n-1$, can I compute the factorial of $n$?''
Yes you can, by multiplying by $n$.

Of course, it is strange to assume that the method works correctly when you have not finished writing it, but that's why it's called a leap of faith!


\section{One more example}
\label{fibonacci}

\index{fibonacci}

Another common recursively-defined mathematical function is the Fibonacci sequence, which has the following definition:

\vspace{-1ex}
\begin{eqnarray*}
&& fibonacci(1) = 1 \\
&& fibonacci(2) = 1 \\
&& fibonacci(n) = fibonacci(n-1) + fibonacci(n-2);
\end{eqnarray*}
\vspace{-1ex}

Translated into Java, this function is simply:

\begin{code}
    public static int fibonacci(int n) {
        if (n == 1 || n == 2) {
            return 1;
        }
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
\end{code}

If you try to follow the flow of execution here, even for small values of \java{n}, your head will explode.
But according to the leap of faith, if we assume that the two recursive invocations work correctly, then it is clear that we get the right result by adding them together.


\section{Testing with JUnit}
\label{JUnit}

To convince yourself that anything works, you should test it.
Since we can compute Fibonacci numbers by hand, we can write a simple \java{main} method to test the \java{fibonacci} method.
The first ten Fibonacci numbers are 1, 1, 2, 3, 5, 8, 13, 21, 34, and 55.

\begin{code}
    public static void main(String[] args) {
        if (fibonacci(1) != 1) {
            System.err.println("fibonacci(1) is incorrect");
        }
        // copy that if statement nine more times
    }
\end{code}

JUnit is a framework that helps automate and standardize this kind of testing (see \url{http://junit.org/}).
The basic pattern is simple:

\begin{itemize}
\item For every class \java{X} there is a corresponding class named \java{XTest} that is responsible for testing the class.
\item For every method \java{m} there is a corresponding method \java{testM} that is responsible for testing the method.
\end{itemize}

For example, the \java{fibonacci} method in the previous section belongs to a class named \java{Series}.
Here are the corresponding test class and test method:

\begin{code}
import junit.framework.TestCase;

public class SeriesTest extends TestCase {

    public void testFibonacci() {
        assertEquals(1, Series.fibonacci(1));
        assertEquals(1, Series.fibonacci(2));
        assertEquals(2, Series.fibonacci(3));
        assertEquals(3, Series.fibonacci(4));
        // six more assertEquals statements
    }
}
\end{code}

JUnit uses some Java language features we have not see yet, like the keyword \java{extends}.
But it's easy to get started by writing simple test methods.
In \mbox{DrJava}, you can select ``File $>$ New JUnit Test Case'' from the menu to generate a test class and methods.

JUnit provides a family of overloaded \java{assert} methods.
In the example above, \java{assertEquals} compares the expected value with the actual value, that is, what \java{fibonacci} returns.
If \java{assertEquals} fails, it displays an error showing the values that did not match.
This code is more concise than writing your own \java{if} statements and \java{System.err} messages.

To run JUnit directly from DrJava, click the {\tt Test} button on the toolbar.
If all your test methods pass, you will see a green bar in the lower right.
Otherwise, DrJava will take you directly to the first assertion that failed.


\section{Vocabulary}

\begin{description}

\term{value method}
A method that returns a value.

\term{void method}
A method that does not return a value.

\term{return type}
The type of value a method returns.

\term{return value}
The value provided as the result of a method invocation.

\term{void}
A special return type indicating the method does not return a value.

\term{temporary variable}
A variable that is short-lived, often used for debugging purposes.

\term{dead code}
Part of a program that can never be executed, often because it appears after a \java{return} statement.

\term{incremental development}
A process for creating programs by writing a few lines at a time,
compiling, and testing.

\term{stub}
A placeholder for an incomplete method so that the class will compile.

\term{scaffolding}
Code that is used during program development but is not part of the final version.

\term{overloading}
Defining more than one method with the same name but different parameters.
%When you invoke an overloaded method, Java knows which version to use by looking at the arguments you provide.

\term{Turing complete}
A programming language that can implement any theoretically possible algorithm.

\term{factorial}
The product of all the integers up to and including a given integer.

\end{description}


\section{Exercises}


\begin{exercise}

Answer the following questions by trying them out.
In fact, any time you have a question about what is legal or illegal in Java, a good way to find out is to ask the compiler.

\begin{enumerate}

\item What happens if you invoke a value method and don't do anything with the result?
(In other words, if you don't assign it to a variable or use it as part of a larger expression?)

\item What happens if you use a \java{print} method as part of an expression?
For example: \java{System.out.println("boo!") + 7;}

%TODO: any more?

\end{enumerate}

\end{exercise}


\begin{exercise}
\label{ex.isdiv}

Write a method named \java{isDivisible} that takes two integers, \java{n} and \java{m}, and that returns \java{true} if \java{n} is divisible by \java{m}, and \java{false} otherwise.

\end{exercise}


\begin{exercise}

If you are given three sticks, you may or may not be able to arrange them in a triangle.
For example, if one of the sticks is 12 inches long and the other two are one inch long, you will not be able to get the short sticks to meet in the middle.
For any three lengths, there is a simple test to see if it is possible to form a triangle:

\begin{quote}
``If any of the three lengths is greater than the sum of the other two, then you cannot form a triangle.''
\end{quote}

Write a method named \java{isTriangle} that takes three integers as arguments and returns either \java{true} or \java{false}, depending on whether you can or cannot form a triangle from sticks with the given lengths.
The point of this exercise is to use conditional statements to write a value method.

\end{exercise}


\begin{exercise}
\label{ex.multadd}

Many computations can be expressed more concisely using the ``multadd'' operation, which takes three operands and computes \java{a * b + c}.
Some processors even provide a hardware implementation of this operation for floating-point numbers.

\begin{enumerate}

\item Create a new program called {\tt Multadd.java}.

\item Write a method called \java{multadd} that takes three \java{doubles} as parameters and that returns \java{a * b + c}.

\item Write a \java{main} method that tests \java{multadd} by invoking it with a few simple parameters, like \java{1.0, 2.0, 3.0}.

\item Also in \java{main}, use \java{multadd} to compute the following values:
%
\begin{eqnarray*}
& \sin \frac{\pi}{4} + \frac{\cos \frac{\pi}{4}}{2} & \\
& \log 10 + \log 20 &
\end{eqnarray*}

\item Write a method called \java{yikes} that takes a double as a parameter and that uses \java{multadd} to calculate:
%
\begin{eqnarray*}
x e^{-x} + \sqrt{1 - e^{-x}}
\end{eqnarray*}
%
HINT: The Math method for raising $e$ to a power is \java{Math.exp}.

\end{enumerate}

In the last part, you get a chance to write a method that invokes a method you wrote.
Whenever you do that, it is a good idea to test the first method carefully before you start working on the second.
Otherwise, you might find yourself debugging two methods at the same time, which can be difficult.

One of the purposes of this exercise is to practice pattern-matching: the ability to recognize a specific problem as an instance of a general category of problems.

\end{exercise}


\begin{exercise}

In this exercise, you will use a stack diagram to understand the execution of the following recursive program.

\begin{code}
public class Prod {

    public static void main(String[] args) {
        System.out.println(prod(1, 4));
    }

    public static int prod(int m, int n) {
        if (m == n) {
            return n;
        } else {
            int recurse = prod(m, n-1);
            int result = n * recurse;
            return result;
        }
    }
}
\end{code}

\begin{enumerate}

\item Draw a stack diagram showing the state of the program just before the last instance of \java{prod} completes.
What is the output of this program?

\item Explain in a few words what \java{prod} does.

\item Rewrite \java{prod} without using temporary variables \java{recurse} and \java{result}.

\end{enumerate}

\end{exercise}


\begin{exercise}

What is the output of the following program?

\begin{code}
    public static void main(String[] args) {
        boolean flag1 = isHoopy(202);
        boolean flag2 = isFrabjuous(202);
        System.out.println(flag1);
        System.out.println(flag2);
        if (flag1 && flag2) {
            System.out.println("ping!");
        }
        if (flag1 || flag2) {
            System.out.println("pong!");
        }
    }

    public static boolean isHoopy(int x) {
        boolean hoopyFlag;
        if (x % 2 == 0) {
            hoopyFlag = true;
        } else {
            hoopyFlag = false;
        }
        return hoopyFlag;
    }

    public static boolean isFrabjuous(int x) {
        boolean frabjuousFlag;
        if (x > 0) {
            frabjuousFlag = true;
        } else {
            frabjuousFlag = false;
        }
        return frabjuousFlag;
    }
\end{code}

The purpose of this exercise is to make sure you understand logical operators and the flow of execution through value methods.

\end{exercise}


\begin{exercise}

The purpose of this exercise is to translate a recursive definition into a Java method.
The Ackermann function is defined for non-negative integers as follows:
\begin{eqnarray*}
A(m, n) = \begin{cases}
              n+1 & \mbox{if } m = 0 \\
        A(m-1, 1) & \mbox{if } m > 0 \mbox{ and } n = 0 \\
A(m-1, A(m, n-1)) & \mbox{if } m > 0 \mbox{ and } n > 0.
\end{cases}
\end{eqnarray*}

Write a method called \java{ack} that takes two \java{int}s as parameters and that computes and returns the value of the Ackermann function.

Test your implementation of Ackermann by invoking it from \java{main} and printing the return value.
Note the return value gets very big very quickly.
You should try it only for small values of $m$ and $n$ (not bigger than 3).

\end{exercise}


\begin{exercise}
\label{ex.power}

Write a recursive method called \java{power} that takes a double \java{x} and an integer \java{n} and that returns $x^n$.

Hint: a recursive definition of this operation is $x^n = x \cdot x^{n-1}$.
Also, remember that anything raised to the zeroeth power is 1.

Optional challenge: you can make this method more efficient, when \java{n} is even, using $x^n = \left( x^{n/2} \right)^2$.

\end{exercise}


\begin{exercise}
\label{gcd}

Write a method called \java{gcd} that takes two integer parameters and that uses Euclid's algorithm to compute and return the greatest common divisor of the two numbers.

The following technique is known as Euclid's Algorithm, because it appears in Euclid's {\em Elements} (Book 7, ca.~300 BC).
It may be the oldest recorded nontrivial algorithm.
The process is based on the observation that, if $r$ is the remainder when $a$ is divided by $b$, then the common divisors of $a$ and $b$ are the same as the common divisors of $b$ and $r$.
\[ gcd(a, b) = gcd(b, r) \]
%
We can use this fact to reduce the problem of computing a GCD to the problem of computing the GCD of smaller and smaller pairs of integers.
For example:
\[ gcd(36, 20) = gcd(20, 16) = gcd(16, 4) = gcd(4, 0) = 4 \]
%implies that the GCD of 36 and 20 is 4.

%It can be shown that for any two starting numbers, this repeated reduction eventually produces a pair where the second number is 0.
%Then the GCD is the other number in the pair.

(This exercise is based on page 44 of Ableson and Sussman's {\em Structure and Interpretation of Computer Programs}.)

\end{exercise}


\chapter{Loops and iteration}

Computers are often used to automate repetitive tasks.
Repeating tasks without making errors is something that computers do well and people do poorly.

\index{iteration}

We have already seen methods like \java{countdown} and \java{factorial} that use recursion to run the same code multiple times.
Although recursion is elegant and powerful, Java provides language features that make it much easier to repeat code.
In this chapter, we present {\bf iteration} using \java{while} and \java{for} statements.


\section{The while statement}

\index{statement!while}
\index{while statement}

Using a \java{while} statement, we can rewrite \java{countdown} this way:

\begin{code}
    public static void countdown(int n) {
        while (n > 0) {
            System.out.println(n);
            n = n - 1;
        }
        System.out.println("Blastoff!");
    }
\end{code}

You can almost read a \java{while} statement like English.
The above code means: ``While \java{n} is greater than zero, print the value of \java{n} and then reduce the value of \java{n} by 1.
When you get to zero, print the word Blastoff!''

More formally, the flow of execution for a \java{while} statement is three steps:

\begin{enumerate}

\item Evaluate the condition in parentheses, yielding \java{true} or \java{false}.

\item If the condition is \java{false}, exit the \java{while} block and continue execution at the next statement.

\item If the condition is \java{true}, execute the statements between the braces, and then go back to step 1.

\end{enumerate}

\index{loop}
\index{loop!body}
\index{body}

This type of flow is called a {\bf loop}, because the last step loops back around to the first.
The statements inside the \java{while} block are called the {\bf body} of the loop.
If the condition is \java{false} the first time, the statements inside the \java{while} block are never executed.

\index{loop!infinite}
\index{infinite loop}

The body of the loop should change the value of one or more variables so that, eventually, the condition becomes \java{false} and the loop terminates.
Otherwise the loop will repeat forever, which is called an {\bf infinite loop}.
An endless source of amusement for computer scientists is the observation that the directions on shampoo, ``Lather, rinse, repeat,'' are an infinite loop.

In the case of \java{countdown}, we can prove that the loop terminates when \java{n} is positive.
But in general, it is not so easy to tell whether a loop terminates.
For example, this loop continues until \java{n} is 1 (which makes the condition \java{false}).

\begin{code}
    public static void sequence(int n) {
        while (n != 1) {
            System.out.println(n);
            if (n % 2 == 0) {         // n is even
                n = n / 2;
            } else {                  // n is odd
                n = n * 3 + 1;
            }
        }
    }
\end{code}

At each iteration, the program prints the value of \java{n} and then checks whether it is even or odd.
If it is even, the value of \java{n} is divided by two.
If it is odd, the value is replaced by $3n+1$.
For example, if the starting value (the argument passed to \java{sequence}) is 3, the resulting sequence is 3, 10, 5, 16, 8, 4, 2, 1.

Since \java{n} sometimes increases and sometimes decreases, there is no obvious proof that \java{n} will ever reach 1 and that the program will ever terminate.
For some particular values of \java{n}, we can prove termination.
For example, if the starting value is a power of two, then the value of \java{n} will be even every time through the loop until we get to 1.
The previous example ends with such a sequence, starting with 16.

Particular values aside, the interesting question is whether we can prove that this program terminates for {\em all} values of n.
So far, no one has been able to prove it {\em or} disprove it!
For more information, see \url{http://en.wikipedia.org/wiki/Collatz_conjecture}.
%The field of computer science is interested in these types of questions, because their answers give insight to the limits of what computers can and cannot do.


\section{Generating tables}

\index{table}
\index{logarithm}

One of the things loops are good for is generating and printing tabular data.
Before computers were readily available, people had to calculate logarithms, sines and cosines, and other common mathematical functions by hand.
To make that easier, there were books containing long tables where you could find the values of various functions.
Creating these tables was slow and boring, and the results were often full of errors.

When computers appeared on the scene, one of the initial reactions was, ``This is great!
We can use the computers to generate the tables, so there will be no errors.''
That turned out to be true (mostly), but shortsighted.
Not much later, computers were so pervasive that printed tables became obsolete.

\index{division!floating-point}

Even so, for some operations, computers use tables of values to get an approximate answer, and then perform computations to improve the approximation.
In some cases, there have been errors in the underlying tables, most famously in the table the original Intel Pentium used to perform floating-point division (see \url{http://en.wikipedia.org/wiki/Pentium_FDIV_bug}).

Although a ``log table'' is not as useful as it once was, it still makes a good example of iteration.
The following program prints a sequence of values in the left column and their logarithms in the right column:

\begin{code}
    double x = 1.0;
    while (x < 10.0) {
        System.out.println(x + "   " + Math.log(x));
        x = x + 1.0;
    }
\end{code}

The output of this program is:

\begin{stdout}
1.0   0.0
2.0   0.6931471805599453
3.0   1.0986122886681098
4.0   1.3862943611198906
5.0   1.6094379124341003
6.0   1.791759469228055
7.0   1.9459101490553132
8.0   2.0794415416798357
9.0   2.1972245773362196
\end{stdout}

Looking at these values, can you tell what base \java{Math.log} uses?
Since powers of two are important in computer science, we often want logarithms with respect to base 2.
To compute them, we can apply this property of logarithms:
%
\[ \log_2 x = \frac{log_e x}{log_e 2} \]
%
Using the right side of the formula, we modify the \java{println} statement.

\begin{code}
    System.out.println(x + "   " + Math.log(x) / Math.log(2));
\end{code}

We can see that 1, 2, 4 and 8 are powers of two, because their logarithms base 2 are round numbers.

\begin{stdout}
1.0   0.0
2.0   1.0
3.0   1.5849625007211563
4.0   2.0
5.0   2.321928094887362
6.0   2.584962500721156
7.0   2.807354922057604
8.0   3.0
9.0   3.1699250014423126
\end{stdout}

If we wanted to find the logarithms of other powers of two, we could modify the program like this:

\begin{code}
    final double log2 = Math.log(2);
    double x = 1.0;
    while (x < 100.0) {
        System.out.println(x + "   " + Math.log(x) / log2);
        x = x * 2.0;
    }
\end{code}

First, we store \java{Math.log(2)} in a \java{final} variable to avoid computing that value over and over again.
Second, instead of adding something to \java{x} each time through the loop, which yields an {\em arithmetic sequence}, we multiply \java{x} by something, yielding a {\em geometric sequence}.
The result is:

\begin{stdout}
1.0   0.0
2.0   1.0
4.0   2.0
8.0   3.0
16.0   4.0
32.0   5.0
64.0   6.0
\end{stdout}

Log tables may not be useful any more, but for computer scientists, knowing the powers of two helps a lot!
%When you have an idle moment, you should memorize the powers of two up to 65536 (that's $2^{16}$).


\section{Program development}
\label{encapsulation}

\index{table!two-dimensional}

Two-dimensional tables consist of rows and columns that list values at the intersections.
A multiplication table is a good example.
Let's say you want to print a multiplication table for the values from 1 to 6.
A good way to start is a simple loop that prints the multiples of 2, all on one line.

\begin{code}
    int i = 1;
    while (i <= 6) {
        System.out.printf("%4d", 2 * i);
        i = i + 1;
    }
    System.out.println();
\end{code}

\index{loop variable}
\index{variable!loop}

The first line initializes a variable named \java{i}, which is going to act as a counter, or {\bf loop variable}.
As the loop executes, the value of \java{i} increases from 1 to 6; when \java{i} is 7, the loop terminates.
Each time through the loop, we print the value \java{2 * i}, padded with spaces so it's four characters wide.
Since we use \java{System.out.printf}, the output appears on a single line.

We need to call \java{println} after the loop to complete the line of output.
In some environments, the output from \java{printf} gets stored without being displayed until \java{println} is invoked.
If the program terminates, and you forget to invoke \java{println}, you may never see the stored output.

The output of the code so far is:

\begin{stdout}
    2    4    6    8   10   12
\end{stdout}

\index{encapsulation}
\index{generalization}

Now that we've solved part of the problem, we can encapsulate and generalize the code to do the rest.
{\bf Encapsulation} means taking a piece of code and wrapping it up in a method, allowing you to take advantage of all the things methods are good for.
%We have seen two examples of encapsulation, when we wrote \java{printParity} in Section~\ref{alternative} and \java{isSingleDigit} in Section~\ref{boolean}.
{\bf Generalization} means taking something specific, like printing multiples of 2, and making it more general, like printing the multiples of any integer.
%Here's a method that encapsulates the loop and then generalizes it to print multiples of \java{n}.

\begin{code}
    public static void printMultiples(int n) {
        int i = 1;
        while (i <= 6) {
            System.out.printf("%4d", n * i);
            i = i + 1;
        }
        System.out.println();
    }
\end{code}

To encapsulate, we added the first line, which declares the method name, parameter, and return type.
To generalize, we replaced the value 2 with the parameter \java{n}.
The whole point of parameters is to allow you to write general purpose methods.

Note that invoking this method with the argument 2 yields the same output as before.
With the argument 3, the output becomes:

\begin{stdout}
    3    6    9   12   15   18
\end{stdout}

And with argument 4, the output is:

\begin{stdout}
    4    8   12   16   20   24
\end{stdout}

By now you can probably guess how we are going to print a multiplication table: we'll invoke \java{printMultiples} repeatedly with different arguments.
In fact, we are going to use another loop to iterate through the rows.

\begin{code}
    int i = 1;
    while (i <= 6) {
        printMultiples(i);
        i = i + 1;
    }
\end{code}

First, notice how similar this loop is to the one inside \java{printMultiples}.
All we did was replace the \java{printf} statement with a method invocation.
Also, notice how the format specifier \java{"\%4d"} in \java{printMultiples} causes the output to align vertically, regardless of whether the numbers are one or two digits.

\begin{stdout}
    1    2    3    4    5    6
    2    4    6    8   10   12
    3    6    9   12   15   18
    4    8   12   16   20   24
    5   10   15   20   25   30
    6   12   18   24   30   36
\end{stdout}

%\section{Generalization}
%\label{methods}
%\index{method}
%\index{encapsulation}
%
%In Section~\ref{adding_methods} I listed some of the reasons methods are useful.
%Here are several more:
%
%\begin{itemize}
%\item By giving a name to a sequence of statements, you make your program easier to read and debug.
%\item Dividing a long program into methods allows you to separate parts of the program, debug them in isolation, and then compose them into a whole.
%\item Methods facilitate both recursion and iteration.
%\item Well-designed methods are often useful for many programs. Once you write and debug one, you can reuse it.
%\end{itemize}

One of the challenges of programming, especially for beginners, is figuring out how to divide up a program into methods.
The process of encapsulation and generalization allows you design as you go along.
You start by adding code to \java{main} or some another method.
When you get the code working, you wrap it up in a new method and generalize it by adding parameters.
Then you repeat, alternately developing new code and creating new methods.

As a final example, we can take the code above and wrap it up in a method:

\begin{code}
    public static void printMultTable() {
        int i = 1;
        while (i <= 6) {
            printMultiples(i);
            i = i + 1;
        }
    }
\end{code}

\index{program development}

Encapsulation and generalization, as demonstrated in this section, is a useful and common process for {\bf program development}.
In later chapters we will present some alternatives.


\section{Local variables}

You might wonder how we can use the same variable \java{i} in both \java{printMultiples} and \java{printMultTable}.
Isn't it true that you can only declare a variable once?
And doesn't it cause problems when one of the methods changes the value of the variable?

The answer to both questions is ``no,'' because the \java{i} in \java{printMultiples} and the \java{i} in \java{printMultTable} are {\em not the same variable}.
They have the same name, but they do not refer to the same storage location.
Changing the value of one variable has no effect on the other.
Consider the stack diagram at the moment the program begins printing the second row of the table:

\begin{center}
\vspace{1em}
\includegraphics{figs/stack4.pdf}
\vspace{1em}
\end{center}

%\begin{tabular}{rl}
%          main & \framebox[3cm][r]{\strut args ~\framebox[1cm]{\strut  }~} \\[1em]
%printMultTable & \framebox[3cm][r]{\strut    i ~\framebox[1cm]{\strut 2}~} \\[1em]
%printMultiples & \framebox[3cm][r]{\strut    i ~\framebox[1cm]{\strut 2}~} \\[1em]
%\end{tabular}

\index{local variable}
\index{variable!local}

Variables and parameters declared inside a method definition are called {\bf local variables} because they only exist inside the method.
You cannot access a local variable from outside its method, and you are free to have multiple variables with the same name as long as they are not in the same method.

\index{loop variable}
\index{variable!loop}

Although it can be confusing, there are good reasons to reuse names.
For example, it is common to use the names \java{i}, \java{j} and \java{k} as loop variables.
If you avoid using them in one method just because you used them somewhere else, you make the program harder to read.
Another reason is when two or more methods are based on the same parameter.
It's awkward to come up with many different names for the same data.


\section{More generalization}
\index{generalization}

Imagine a program that prints multiplication tables of any size, not just the 6x6 table.
All we need is to add a parameter to \java{printMultTable}:

\begin{code}
    public static void printMultTable(int size) {
        int i = 1;
        while (i <= size) {
            printMultiples(i);
            i = i + 1;
        }
    }
\end{code}

Rather than use the literal value 6 in the while statement, we generalize by using the parameter \java{size}.
Here is the output when you invoke \java{printMultTable} with the argument 7:

\begin{stdout}
   1   2   3   4   5   6
   2   4   6   8  10  12
   3   6   9  12  15  18
   4   8  12  16  20  24
   5  10  15  20  25  30
   6  12  18  24  30  36
   7  14  21  28  35  42
\end{stdout}

This result is fine, but it would be even better if it were square (i.e., the same number of rows and columns).
We can pass the \java{size} parameter to \java{printMultiples} to specify how many columns the table should have.

\begin{code}
    public static void printMultiples(int n, int size) {
        int i = 1;
        while (i <= size) {
            System.out.printf("%4d", n * i);
            i = i + 1;
        }
        System.out.println();
    }
\end{code}

%\begin{code}
%    public static void printMultTable(int size) {
%        int i = 1;
%        while (i <= size) {
%            printMultiples(i, size);
%            i = i + 1;
%        }
%    }
%\end{code}

Since we added a new parameter to \java{printMultiples}, we also have to change the line \java{printMultiples(i, size);} where it is invoked in \java{printMultTable}.
As expected, this program generates a square 7x7 table:

\begin{stdout}
   1   2   3   4   5   6   7
   2   4   6   8  10  12  14
   3   6   9  12  15  18  21
   4   8  12  16  20  24  28
   5  10  15  20  25  30  35
   6  12  18  24  30  36  42
   7  14  21  28  35  42  49
\end{stdout}

When you generalize a method appropriately, you often find that it has capabilities you did not plan.
For example, you might notice that the multiplication table is symmetric, because $ab = ba$, so all the entries in the table appear twice.
You could save ink by printing half the table, and you would only have to change one line of \java{printMultTable}:

\begin{code}
      printMultiples(i, i);
\end{code}

In other words, the \java{size} of each row is the same as the row number itself.

\begin{stdout}
   1
   2   4
   3   6   9
   4   8  12  16
   5  10  15  20  25
   6  12  18  24  30  36
   7  14  21  28  35  42  49
\end{stdout}

Even though the second parameter in \java{printMultiples} is named \java{size} and we have a variable with the same name, we can still use any value or expression we want for the argument.
Remember you do not pass {\em variables} to methods; you pass their current {\em values}.


\section{The for statement}
\label{for}

\index{for}
\index{loop!for}
\index{statement!for}

The loops we have written so far have a number of elements in common.
All of them start by initializing a variable; they have a test, or condition, that depends on that variable; and inside the loop they do something to update that variable.
This type of loop is so common that there is another statement, called \java{for}, that expresses it more concisely.

\begin{code}
    for (INITIALIZER; CONDITION; INCREMENTOR) {
        BODY
    }
\end{code}

This structure is equivalent to the following \java{while} loop:

\begin{code}
    INITIALIZER
    while (CONDITION) {
        BODY
        INCREMENTOR
    }
\end{code}

The \java{for} loop is more concise and easier to read, since it puts all the loop-related statements in one place.

\begin{code}
    for (int i = 0; i < 4; i++) {
        System.out.println(i);
    }
\end{code}

We easily rewrite any \java{for} statement as a \java{while} statement by separating the loop components:

\begin{code}
    int i = 0;
    while (i < 4) {
        System.out.println(i);
        i++;
    }
\end{code}

The statement \java{i++;} is shorthand for \java{i = i + 1;} and is commonly used in loop structures.
The \java{++} operator increments a variable by one, and the \java{--} operator decrements a variable by one.

There is one difference between the \java{for} and \java{while} loops above: where the variable \java{i} is declared.
After the \java{for} loop, the variable \java{i} ceases to exist because it was declared in the loop header.
In contrast, the variable \java{i} continues to exist after the \java{while} statment, because it was declared outside the loop.

Because \java{for} loops are so concise, they are particularly useful when iterating over two or more dimensions.
We can rewrite the final example of \java{printMultTable} in the previous section with just a few lines of code:

\begin{code}
    for (int row = 1; row <= size; row++) {
        for (int col = 1; col <= row; col++) {
            System.out.printf("%4d", row * col);
        }
        System.out.println();
    }
\end{code}

In contrast to \java{printMultTable} and \java{printMultiples}, this version of the code cannot use the variable \java{i} for both loops.
Instead, it uses the variables \java{row} and \java{col} to represent the positions in the table.


%TODO(csm) tracing code by hand?


\section{Vocabulary}

\begin{description}

\term{loop}
A statement that executes repeatedly while some condition is satisfied.

\term{iteration}
One pass through (execution of) the body of the loop, including the evaluation of the condition.

\term{loop body}
The statements inside the loop.

\term{infinite loop}
A loop whose condition is always true.

\term{loop variable}
A variable that is initialized, tested, and updated in order to control a loop.

\term{encapsulate}
To divide a large complex program into components (like methods) and isolate the components from each other (for example, by using local variables).

\term{generalize}
To replace something unnecessarily specific (like a constant value) with something appropriately general (like a variable or parameter).
Generalization makes code more versatile, more likely to be reused, and sometimes even easier to write.

\term{local variable}
A variable that is declared inside a method and that exists only within that method.
Local variables cannot be accessed from outside their method and do not interfere with any other methods.

\term{program development}
A process for writing programs.
So far we have seen ``incremental development'' and ``encapsulation and generalization.''

\end{description}


\section{Exercises}


\begin{exercise}
\label{infloop}

Consider the following code:

\begin{code}
public static void main(String[] args) {
    loop(10);
}

public static void loop(int n) {
    int i = n;
    while (i > 0) {
        System.out.println(i);
        if (i % 2 == 0) {
            i = i / 2;
        } else {
            i = i + 1;
        }
    }
}
\end{code}

\begin{enumerate}

\item Draw a table that shows the value of the variables \java{i} and \java{n} during the execution of \java{loop}.
The table should contain one column for each variable and one line for each iteration.

\item What is the output of this program?

\item Can you prove that this loop terminates for any positive value of \java{n}?

\end{enumerate}

\end{exercise}


\begin{exercise}

Let's say you are given a number, $a$, and you want to find its square root.
One way to do that is to start with a rough guess about the answer, $x_0$, and then improve the guess using the following average:
%
\[ x_1 =(x_0 + a/x_0) / 2 \]
%
For example, if we want to find the square root of 9, and we start with $x_0 = 6$, then $x_1 = (6 + 9/6) / 2 = 3.75$, which is closer.
We can repeat the procedure, using $x_1$ to calculate $x_2$, and so on.
In this case, $x_2 = 3.075$ and $x_3 = 3.00091$.
So it converges quickly on the correct answer.

Write a method called \java{squareRoot} that takes a \java{double} and returns an approximation of the square root of the parameter, using this technique.
You may not use \java{Math.sqrt}.

As your initial guess, you should use $a/2$.
Your method should iterate until it gets two consecutive estimates that differ by less than 0.0001.
In other words, return when the absolute value of $x_n - x_{n-1}$ is less than 0.0001.
You can use \java{Math.abs} to calculate the absolute value.

\end{exercise}


\begin{exercise}

In Exercise~\ref{ex.power} we wrote a recursive version of \java{power}, which takes a double \java{x} and an integer \java{n} and returns $x^n$.
Now write an iterative method to perform the same calculation.

\end{exercise}


\begin{exercise}

Section~\ref{factorial} presents a recursive method that computes the factorial function.
Write an iterative version of \java{factorial}.

\end{exercise}


\begin{exercise}

One way to calculate $e^x$ is to use the infinite series expansion:
%
\[ e^x = 1 + x + x^2 / 2! + x^3 / 3! + x^4 / 4! + ... \]
%
If the loop variable is named \java{i}, then the $i$th term is $x^i / i!$.

\begin{enumerate}

\item Write a method called \java{myexp} that adds up the first \java{n} terms of this series.
You can use the \java{factorial} method from Section~\ref{factorial} or your iterative version from the previous exercise.

\item You can make this method more efficient if you realize that, in each iteration, the numerator of the term is the same as its predecessor multiplied by \java{x}, and the denominator is the same as its predecessor multiplied by \java{i}.
Use this observation to eliminate the use of \java{Math.pow} and \java{factorial}, and check that you still get the same result.

\item Write a method called \java{check} that takes a parameter, \java{x}, and prints the values of \java{x}, \java{Math.exp(x)} and \java{myexp(x)} for various values of \java{x}.
The output should look something like:

\begin{stdout}
1.0     2.708333333333333     2.718281828459045
\end{stdout}

Recall that you can use the string \java{"\\t"} to print a tab character between columns of a table.

\item Vary the number of terms in the series (the second argument that \java{check} sends to \java{myexp}) and see the effect on
the accuracy of the result.
Adjust this value until the estimated value agrees with the ``correct'' answer when \java{x} is 1.

\item Write a loop in \java{main} that invokes \java{check} with the values 0.1, 1.0, 10.0, and 100.0.
How does the accuracy of the result vary as \java{x} varies?
Compare the number of digits of agreement rather than the difference between the actual and estimated values.

\item Add a loop in \java{main} that checks \java{myexp} with the values -0.1, -1.0, -10.0, and -100.0.
Comment on the accuracy.

\end{enumerate}

\end{exercise}


\begin{exercise}

One way to evaluate $\exp(-x^2)$ is to use the infinite series expansion:
%
\[ \exp(-x^2) = 1 - x^2 + x^4/2 - x^6/6 + \ldots \]
%
In other words, we need to add up a series of terms where the $i$th term is equal to $(-1)^i x^{2i} / i!$.
Write a method named \java{gauss} that takes \java{x} and \java{n} as arguments and returns the sum of the first \java{n} terms of the series.
You should not use \java{factorial} or \java{pow}.

\end{exercise}


\chapter{Strings and things}
\label{strings}

\index{object}
\index{class!String}
\index{method!string}

In Java and other object-oriented languages, an {\bf object} is a collection of data that provides a set of methods.
These methods operate on the object, performing computations and sometimes modifying the data.
Strings are objects, and their data is a sequence of characters; that is,
letters, numbers, spaces, and symbols.
The \java{String} class provides many methods for manipulating character data, and we will explore some of them in this chapter.


\section{Characters}

\index{charAt}
\index{char}
\index{type!char}

The first method we will look at is \java{charAt}, which extracts a character from a \java{String}.
It returns a \java{char}, a primitive type that can store individual characters (as opposed to strings of them).

\begin{code}
    String fruit = "banana";
    char letter = fruit.charAt(1);
    System.out.println(letter);
\end{code}

The expression \java{fruit.charAt(1)} means that we invoke the \java{charAt} method on the object referenced by \java{fruit}.
The argument \java{1} means that we want to know the letter at position 1.
The result is a character, which is stored in a \java{char} variable named \java{letter}.
When you print the value of \java{letter}, you might be surprised:

\begin{stdout}
a
\end{stdout}

Unless you already think like a computer scientist, the letter \java{a} is not the first letter of \java{"banana"}.
For technical reasons, computer scientists start counting from zero.
The 0th (``zeroeth'') letter of \java{"banana"} is the \java{b}.
The 1th letter (``oneth'') is \java{a} and the 2th (``twooth'') letter is \java{n}.
So if you want the {\em first} letter of a string, you have to pass 0 as the argument:

\begin{code}
    char letter = fruit.charAt(0);
\end{code}

\index{quote}
\index{double-quote}
\index{value!char}

Character literals appear in single quotes like \java{'c'}.
Unlike string literals, which appear in double quotes, characters may only contain a single letter or symbol.

\begin{code}
    char letter = 'c';
    if (letter == 'd') {
        System.out.println('?');
    }
\end{code}

Characters work much like the other primitive types we have seen.
You can use them in arithmetic, decisions, loops, and so forth.

\begin{code}
    System.out.print("Roman alphabet: ");
    for (char c = 'A'; c <= 'Z'; c++) {
        System.out.print(c);
    }
    System.out.println();
\end{code}

\index{Unicode}

Java uses {\bf Unicode} for its character set (see \url{http://unicode.org/}) so that strings may store text in any language.
Unicode supports alphabets like Cyrillic and Greek, and left-to-right scripts like Arabic and Hebrew.
%Regardless, both the data type \java{char} and the method \java{charAt} work the same.

\begin{code}
    System.out.print("Greek alphabet: ");
    for (int i = 913; i <= 937; i++) {
        System.out.print((char) i);
    }
    System.out.println();
\end{code}

This example demonstrates how you can convert a Unicode ``code unit,'' represented as an integer, to a \java{char} using a cast operator.


\section{String traversal}
\label{traverse}

\index{traverse}

A common task with strings is to start at the beginning, select each character in turn, do some computation with it, and continue until the end.
This pattern is called a {\bf traversal}.
A natural way to traverse a string is with a \java{for} statement:

\begin{code}
    for (int i = 0; i < fruit.length(); i++) {
        char letter = fruit.charAt(i);
        System.out.println(letter);
    }
\end{code}

\index{loop variable}
\index{variable!loop}
\index{index}

This loop prints each character of the string \java{fruit} on a line by itself.
The name of the loop variable is \java{i}, which stands for {\bf index}; an
index is an integer that indicates the position of a character.
Notice that the condition is \java{i < fruit.length()}, which means that when \java{i} is equal to the length of the string, the condition is \java{false} and the loop terminates.
%The last character we access is the one with the index \java{fruit.length() - 1}.

\index{String!length}
\index{length!String}

The \java{length} method returns the number of characters in the string.
It takes no arguments and returns an integer; the length of \java{"banana"} is 6.
%Notice that it is legal to have a variable with the same name as a method (although it can be confusing for human readers).
To find the last letter of a string, you might be tempted to try something like:

\begin{code}
    int length = fruit.length();
    char last = fruit.charAt(length);      // WRONG!
\end{code}

This code compiles and runs, but it causes a runtime error.
The reason is that there is no sixth letter in \java{"banana"}.
Since we started counting at 0, the 6 letters are indexed from 0 to 5.
To get the last character, you have to subtract 1 from \java{length}.

\begin{code}
    char last = fruit.charAt(length - 1);  // CORRECT
\end{code}

Many string traversals involve reading one string and creating another.
For example, to reverse a string we simply add one character at a time:

\begin{code}
    public static String reverse(String s) {
        String r = "";
        for (int i = s.length() - 1; i >= 0; i--) {
            r = r + s.charAt(i);
        }
        return r;
    }
\end{code}

\index{empty string}

The initial value of \java{r} is \java{""}, which is the {\bf empty string}.
The loop traverses the letters of \java{s} in reverse order.
Each time through the loop, it creates a new string and assigns it to \java{r}.
When the loop exits, \java{r} contains the letters from \java{s} in reverse order.
So the result of \java{reverse("banana")} is \java{"ananab"}.

%\section{Looping and counting}
\label{loopcount}

\index{loop!counting}
\index{traverse!counting}

Other string traversals involve looping and counting.
The following method counts the number of times a given character appears in a string.
For example, \java{numberOf("banana", 'a')} returns 3.

\begin{code}
    public static int numberOf(String s, char c) {
        int count = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == c) {
                count++;
            }
        }
        return count;
    }
\end{code}

\index{counter}

This method demonstrates a common idiom, called a {\bf counter}.
The variable \java{count} is initialized to zero and then incremented each time we find an \java{'a'}.
When we exit the loop, \java{count} contains the result: the total number of a's.


\section{Substrings}

The \java{substring} method returns new string that copies letters from an existing string, beginning at the given index.

\begin{itemize}
\item \java{fruit.substring(0)} returns \java{"banana"}
\item \java{fruit.substring(2)} returns \java{"nana"}
\item \java{fruit.substring(6)} returns \java{""}
\end{itemize}

The first example returns a copy of the entire string.
The second example returns all but the first two characters.
As the last example shows, \java{substring} returns the empty string if the argument is the length of the string.
To visualize how this method works, it helps to draw a picture:

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
b & a & n & a & n & a \\
\hline
0 & 1 & 2 & 3 & 4 & 5 \\
\hline
\end{tabular}
\end{center}

Like many string methods, \java{substring} is overloaded.
That is, there are other versions of \java{substring} that have different parameters.
If it's invoked with two argments, they are treated as a start and end index:

\begin{itemize}
\item \java{fruit.substring(0, 3)} returns \java{"ban"}
\item \java{fruit.substring(2, 5)} returns \java{"nan"}
\item \java{fruit.substring(6, 6)} returns \java{""}
\end{itemize}

Notice that the character indicated by the end index is not included.
%In other words, substrings are for the interval $[beg, end)$.
One way to remember this detail is to think about how loops work.
Here is a simplified version of \java{substring(2, 5)}:

\begin{code}
    String str = "banana";
    int beg = 2;
    int end = 5;
    String sub = "";
    for (int i = beg; i < end; i++) {
        sub = sub + str.charAt(i);
    }
    System.out.println(sub);  // prints "nan"
\end{code}

Because of the \java{<} operator, the loop terminates when \java{i == end}.
Designing substring this way simplifies many common operations.
For example, to select a substring with length \java{len}, starting at index \java{i}, you could write \java{fruit.substring(i, i + len)}.


\section{Bounds checking}
\label{StringIndexOutOfBounds}

\index{runtime error}
\index{error!runtime}
\index{exception}

If you call the \java{charAt} method with an index that is either negative or greater than \java{length - 1}, you will get an {\bf exception}.
%The same is true when calling \java{substring} with invalid start or end indexes.
When that happens, Java prints an error message and terminates the program.

For example, notice the error in the \java{getLastLetter} method below.
It should be looking at \java{index - 1} instead of \java{index}.

\begin{code}
public class BadString {
    public static void main(String[] args) {
        processWord("banana");
    }
    public static void processWord(String s) {
        char c = getLastLetter(s);
        System.out.println(c);
    }
    public static char getLastLetter(String s) {
        int index = s.length();
        char c = s.charAt(index);  // WRONG!
        return c;
    }
}
\end{code}

When you run the \java{BadString} program, Java prints the following message.

\begin{small}
\begin{stdout}
Exception in thread "main" java.lang.StringIndexOutOfBoundsException:
String index out of range: 6
    at java.lang.String.charAt(String.java:658)
    at BadString.getLastLetter(BadString.java:14)
    at BadString.processWord(BadString.java:8)
    at BadString.main(BadString.java:4)
\end{stdout}
\end{small}

\index{stack trace}

This information is called a {\bf stack trace}, which shows the methods that were running when the error occurred.
The stack trace can be difficult to read, but it contains a lot of useful information.
For one, it tells you that the index 6 was out of range.

More importantly, it shows the line of code where the error occurred.
It may be helpful to read the stack trace bottom-up.
On line~4, \java{main} called \java{processWord}, which on line~8 called \java{getLastLetter}, which on line~14 called \java{charAt}.
The actual error occurred on line 658 of String.java, which is in the source code for the \java{String} class itself.

Although possible, it's unlikely that the Java library code has mistakes that cause programs to crash.
When reading stack diagrams, look for the top line that refers to a file you wrote.
In this example, \java{BadString.java:14} is the most useful debugging information.


\section{The indexOf method}
\index{indexOf}

At first glance, \java{indexOf} is the inverse of \java{charAt}.
The \java{charAt} method takes an index and returns the character at that index.
In contrast, the \java{indexOf} method takes a character and finds an index where that character appears.

\begin{code}
    String fruit = "banana";
    int index = fruit.indexOf('a');
\end{code}

This example finds the index of the letter \java{'a'} in the string.
But the letter appears three times, so it's not obvious what \java{indexOf} should do.
According to the documentation, it returns the index of the {\em first} appearance.

To find subsequent appearances, you can use another version of \java{indexOf}, which takes a second argument that indicates where in the string to start looking.
%For an explanation of this kind of overloading, see Section~\ref{overloading}.

\begin{code}
    int index = fruit.indexOf('a', 2);
\end{code}

This code starts at the third letter (the first \java{'n'}) and finds the next \java{'a'}, which is at index 3.
If the letter happens to appear at the starting index, the starting index is the answer.
So \java{fruit.indexOf('a', 5)} returns 5.

There are subtle differences between \java{charAt} and \java{indexOf}:
\java{charAt} throws an exception if the index is out of range;
\java{indexOf} returns the value \java{-1} if the character does not appear in the string.

You can also use \java{indexOf} to search for an entire string.
For example, the expression \java{fruit.indexOf("nan")} returns 2, whereas \java{fruit.indexOf("zzz")} returns -1 (not found).


\section{String comparison}
\label{immutable}
\label{incomparable}

\index{toUpperCase}
\index{toLowerCase}
\index{immutable}

As you read the documentation of the \java{String} methods, you might notice \java{toUpperCase} and \java{toLowerCase}.
These methods are often a source of confusion, because it sounds like they have the effect of changing (or mutating) an existing string.
It turns out that neither these methods nor any others can change a string, because strings are {\bf immutable}.

When you invoke \java{toUpperCase} on a string object, you get a new string object as a return value.
For example:

\begin{code}
    String name = "Alan Turing";
    String upperName = name.toUpperCase();
\end{code}

\index{Turing, Alan}

After the second line runs, \java{upperName} contains the value \java{"ALAN TURING"}.
But \java{name} still contains \java{"Alan Turing"} as before.

\index{equals}
\index{compareTo}

It is often useful to compare strings to see if they are the same, or to see which comes first in alphabetical order.
It would be nice if we could use the comparison operators, like \java{==} and \java{>}, but we can't.
To compare \java{String}s, we have to use the \java{equals} and \java{compareTo} methods.

\begin{code}
    String name1 = "Alan Turing";
    String name2 = "Ada Lovelace";
    if (name1.equals(name2)) {
        System.out.println("The names are the same.");
    }
\end{code}

The syntax here may seem awkward.
To compare two strings, you have to invoke a method on one of them and pass the other as an argument.
The return value from \java{equals} is straightforward: \java{true} if the strings contain the same characters, and \java{false} otherwise.

\begin{code}
    int diff = name1.compareTo(name2);
    if (diff == 0) {
        System.out.println("The names are the same.");
    } else if (diff < 0) {
        System.out.println("name1 comes before name2.");
    } else if (diff > 0) {
        System.out.println("name2 comes before name1.");
    }
\end{code}

The return value from \java{compareTo} is the {\em difference} between the first characters in the strings that differ.
If the strings are equal, their difference is 0.
If the first string (the one on which the method is invoked) comes first in the alphabet, the difference is negative.
Otherwise, the difference is positive.

In the example above, \java{compareTo} returns positive 8, because the second letter of \java{"Ada"} comes before the second letter of \java{"Alan"} by 8 letters.


\section{Character arithmetic}

% ABD: I propose that we kill this section.  The first example is
% a bad solution, and the second example is string concatentation,
% not character arithmetic. (CSM: the ++ is the arithmetic part.)

% Instead, let's have a section that introduces the Character class
% and some of the methods it provides.

\index{arithmetic!char}

Like the \java{compareTo} method, you too can do arithmetic with characters.
For example, if \java{letter} refers to a lowercase letter, \java{letter - 'a'} yields its position in the alphabet (keeping in mind that 'a' is the zeroeth letter of the alphabet and 'z' is the 25th).

Performing arithmetic on characters is rarely necessary in programs, but it helps demonstrate how text is represented in Java.
For example, we often need to convert between characters that contain numbers (e.g., \java{'0'}, \java{'1'}, \java{'2'}) and their corresponding integers.
A common mistake beginning programmers make is simply to cast a \java{char} to an \java{int}:

\begin{code}
    char letter = '3';
    int x = (int) letter;
    System.out.println(x);
\end{code}

You might expect the value to be 3, but instead you get 51, which is the Unicode value for the character \java{'3'}.
%Remember, not all languages in the world use Arabic numerals like English does.
To convert \java{'3'} to the corresponding integer value, you effectively need to subtract \java{'0'}:

\begin{code}
    int x = (int) (letter - '0');
\end{code}

In both of these examples, the typecast \java{(int)} is not strictly necessary since Java will do the conversion automatically.
Since this conversion can be a bit ugly, it is preferable to use the \java{digit} method in the \java{Character} class instead.
For example, this code converts \java{letter} to the corresponding digit, interpreting it as a base 10 number.

\begin{code}
    int x = Character.digit(letter, 10);
\end{code}

Another use for character arithmetic is to loop through the letters of the alphabet in order.
For example, in Robert McCloskey's book {\em Make Way for Ducklings}, the names of the ducklings form an Abecedarian series: Jack, Kack, Lack, Mack, Nack, Ouack, Pack and Quack.
Here is a loop that prints these names in order:

\begin{code}
    char letter = 'J';
    while (letter <= 'Q') {
        System.out.println(letter + "ack");
        letter++;
    }
\end{code}

Notice that in addition to the arithmetic operators, we can also use the conditional operators on characters.
The output of this program is:

\begin{stdout}
Jack
Kack
Lack
Mack
Nack
Oack
Pack
Qack
\end{stdout}

Of course, that's not quite right because it misspelled ``Ouack'' and ``Quack.''
As an exercise, you can modify the program to correct this error.


\section{Wrapper classes}

In the previous section, we introduced the \java{Character} class.
There are similar classes for the other primitive data types such as \java{Boolean}, \java{Integer}, \java{Long}, and \java{Double}.
These classes are in the \java{java.lang} package, so can use them without explicitly importing them.

Each of these classes defines constants \java{MIN_VALUE} and \java{MAX_VALUE}.
For example, \java{Integer.MIN_VALUE} is the \java{int} $-2147483648$, and \java{Integer.MAX_VALUE} is the \java{int} $2147483647$.
Rather than remember these unusual numbers, you can simply refer to the built-in constants.

Another purpose of wrapper classes is converting values to and from strings.
For example, we can convert a string to an integer using the \java{parseInt} method:

\begin{code}
String str = "12345";
int num = Integer.parseInt(str);
\end{code}

You will find similar methods in the other wrapper classes, for example, \java{Double.parseDouble} and \java{Boolean.parseBoolean}.

These wrapper classes also provide \java{toString}, which returns a string
representation of a number:

\begin{code}
int num = 12345;
String str = Integer.toString(num);
\end{code}

% ABD: There is a jump here from talking about wrapper classes to talking
% about instances of those classes.  I think we don't want to do the
% second part yet.

%As a convenience, Java will automatically convert primitive values to/from their wrapper types.
%We will see later why this code is inefficient.

%\begin{code}
%Integer i = 12345;
%Double d = 123.45;
%\end{code}

%For now, it's important to note that \java{i} and \java{d} are references to %objects.
%In other words, the values {\tt 12345} and {\tt 123.45} have been wrapped %inside objects.
%Like strings, these objects have a variety of methods that can be applied.
%Refer to the documentation for \java{Integer} and \java{Double} for more details.


\section{Vocabulary}

\begin{description}

\term{object}
A collection of related data that comes with a set of methods that operate on it.

\term{Unicode}
A standard for representing characters in most of the world's languages.

\term{traverse}
To iterate through the elements of a set performing a similar operation on each.

\term{index}
A variable or value used to indicate one of the members of a collection, like a character from a string.

\term{empty string}
The string \java{""}, what contains no characters and has a length of zero.

\term{counter}
A variable used to count something, usually initialized to zero and then incremented.

\term{exception}
A runtime error like ArithmeticException or IndexOutOfBoundsException.

\term{stack trace}
An error message that shows the state of a program when an exception occurs.

\term{immutable}
An object that, once created, cannot be modified.
Strings are immutable.

\end{description}


\section{Exercises}

\index{encapsulation}
\index{generalization}


\begin{exercise}

Encapsulate the code in Section~\ref{loopcount} into a method named \java{countLetters}, and generalize it so that it accepts the string and the letter as arguments.
Then rewrite the method so that it uses \java{indexOf} to locate the a's, rather than checking the characters one by one.

\end{exercise}


\begin{exercise}

The purpose of this exercise is to review encapsulation and generalization (see Section~\ref{encapsulation}).

\begin{enumerate}

\item Encapsulate the following code fragment, transforming it into a method that takes a string argument and returns the final value of \java{count}.

\item In a sentence or two, describe what the resulting method does (without getting into the details of how).

\item Now that you have generalized the code so that it works on any string, what could you do to generalize it more?

\item Write several test cases to verify that your generalized code works as expected (see Section~\ref{JUnit}).

\end{enumerate}

\begin{code}
    String s = "((3 + 7) * 2)";
    int len = s.length();
    
    int i = 0;
    int count = 0;
    
    while (i < len) {
        char c = s.charAt(i);
        
        if (c == '(') {
            count = count + 1;
        } else if (c == ')') {
            count = count - 1;
        }
        i = i + 1;
    }
    
    System.out.println(count);
\end{code}

\end{exercise}


\begin{exercise}

The point of this exercise is to explore Java types and fill in some of the details that aren't covered in the chapter.

\begin{enumerate}

\index{concatenate}

\item Create a new program named {\tt Test.java} and write a \java{main} method that contains expressions that combine various types using the \java{+} operator.
For example, what happens when you ``add'' a \java{String} and a \java{char}?
Does it perform character addition or string concatenation?
What is the type of the result?
(How can you determine the type of the result?)

\item Make a bigger copy of the following table and fill it in.
At the intersection of each pair of types, you should indicate whether it is legal to use the \java{+} operator with these types, what operation is performed (addition or concatenation), and what the type of the result is.

\begin{center}
\begin{tabular}{|l|l|l|l|l|l|} \hline
        &  boolean  &  ~char~  &  ~~int~~  &  double  &  String \\ \hline
boolean &           &          &           &          &         \\ \hline
char    &           &          &           &          &         \\ \hline
int     &           &          &           &          &         \\ \hline
double  &           &          &           &          &         \\ \hline
String  &           &          &           &          &         \\ \hline
\end{tabular}
\end{center}

\item Think about some of the choices the designers of Java made when they filled in this table.
How many of the entries seem unavoidable, as if there was no other choice?
How many seem like arbitrary choices from several equally reasonable possibilities?
Which entries seem most problematic?

\item Here's a puzzler: normally, the statement \java{x++} is exactly equivalent to \java{x = x + 1}.
But if \java{x} is a \java{char}, it's not exactly the same!
In that case, \java{x++} is legal, but \java{x = x + 1} causes an error.
Try it out and see what the error message is, then see if you can figure out what is going on.

\item What happens when you add \java{""} (the empty string) to the other types (e.g., \java{"" + 5})?
How does this technique compare with methods provided by the wrapper classes?

\item For each data type, what types of values can you assign to it? For example, you can assign an \java{int} to a \java{double} but not vice versa.

\end{enumerate}

\end{exercise}


\begin{exercise}

Create a program called {\tt Recurse.java} and type in the following methods:

\begin{code}
    // first: returns the first character of the given String
    public static char first(String s) {
        return s.charAt(0);
    }

    // last: returns a new String that contains all but the
    // first letter of the given String
    public static String rest(String s) {
        return s.substring(1, s.length());
    }

    // length: returns the length of the given String
    public static int length(String s) {
        return s.length();
    }
\end{code}

\begin{enumerate}

\item Write some code in \java{main} that tests each of these methods.
Make sure they work, and you understand what they do.

\item Write a method called \java{printString} that takes a String as a parameter and that prints the letters of the String, one on each line.  It should be a \java{void} method.

\item Write a method called \java{printBackward} that does the same thing as \java{printString} but that prints the String backward (again, one character per line).

\item Write a method called \java{reverseString} that takes a String as a parameter and that returns a new String as a return value.
The new String should contain the same letters as the parameter, but in reverse order.

\begin{code}
    String backwards = reverseString("coffee");
    System.out.println(backwards);
\end{code}

For example, the output of the above code should be:

\begin{stdout}
eeffoc
\end{stdout}

\end{enumerate}

\end{exercise}


\begin{exercise}

What is the output of this program?
Describe in a sentence what \java{mystery} does (not how it works).

\begin{code}
public class Mystery {

    public static String mystery(String s) {
        String total = "";
        int i = s.length() - 1;

        while (i >= 0) {
            char ch = s.charAt(i);
            System.out.println(i + "     " + ch);

            total = total + ch;
            i--;
        }
        return total;
    }

    public static void main(String[] args) {
        System.out.println(mystery("Think Java"));
    }

}
\end{code}

\end{exercise}


\begin{exercise}

A friend shows you the following method and claims that if \java{number} is any two-digit number, the program will output the number backwards.
For example if \java{number} is 17, the code should output {\tt 71}.

\begin{code}
    Scanner in = new Scanner(System.in);
    int number = in.nextInt();

    int lastDigit = number % 10;
    int firstDigit = number / 10;

    System.out.println(lastDigit + firstDigit);
\end{code}

Explain what the program actually does, and modify it so that it does the right thing.
You can assume the input will be a two-digit positive integer.

\end{exercise}


\begin{exercise}
\label{palindrome}

A palindrome is a word that reads the same both forward and backward, like ``otto'' and ``palindromeemordnilap.''

\begin{enumerate}

\item Create a new program named {\tt Palindrome.java}.

\item Write a method named \java{first} that takes a string and returns the first letter.
Write another method named \java{last} that returns the last letter.

\item Write a method named \java{middle} that takes a string and returns a substring that contains everything {\em except} the
first and last characters.

%Hint: read the documentation of the \java{substring} method in the \java{String} class.
% Run a few tests to make sure you understand how \java{substring} works before you try to write \java{middle}.

Hint: Think about what happens if you invoke \java{middle} on strings that have only two letters, one letter, and no letters.

\item Here's one way to test whether a string is a palindrome:
``A single letter is a palindrome, and a two-letter word is a palindrome if the letters are the same, and any other word is a palindrome if the first letter is the same as the last and the middle is a palindrome.''

Write a recursive method named \java{isPalindrome} that takes a \java{String} and returns a \java{boolean} indicating whether the word is a palindrome or not.

\item Once you have a working palindrome checker, look for ways to simplify it by reducing the number of conditions you check.

Hint: It might be useful to adopt the definition that the empty string is a palindrome.

\item On a piece of paper, figure out a strategy for checking palindromes iteratively (i.e., using loops).
There are several possible approaches, so make sure you have a solid plan before you start writing code.

\item Implement your strategy in a method called \java{isPalindromeIter}.
Make sure it returns the same results as your recursive method.

%\item Optional: Appendix~\ref{javaio} provides code for reading a list
%of words from a file.  Read a list of words and print the palindromes.

\end{enumerate}

\end{exercise}


\begin{exercise}
\label{abecedarian}

A word is said to be ``abecedarian'' if the letters in the word appear in alphabetical order.
For example, the following are all 6-letter English abecedarian words.

\begin{quote}
abdest, acknow, acorsy, adempt, adipsy, agnosy, befist, behint,
beknow, bijoux, biopsy, cestuy, chintz, deflux, dehors, dehort,
deinos, diluvy, dimpsy
\end{quote}

\begin{enumerate}

\item Describe a process for checking whether a given word is abecedarian, assuming that the word contains only lower-case
letters.
Your process can be iterative or recursive.

\item Implement your process in a method called \java{isAbecedarian}.

\end{enumerate}

\end{exercise}


\begin{exercise}
\label{dupledrome}

A dupledrome is a word that contains only double letters, like ``llaammaa'' or ``ssaabb''.
There are most likely no dupledromes in common English use.

\begin{enumerate}

\item Write a method named \java{isDupledrome} that takes a \java{String} and returns a \java{boolean} indicating whether the word is a dupledrome.

\item Write a \java{main} program that reads words from \java{System.in} and checks them for dupledromity.
Continue reading input until the user enters the word \java{"Done"} (ignoring case).

\end{enumerate}

\end{exercise}


\begin{exercise}

A {\em shift cipher} works by taking each letter in a string and adding 13 to it.
For example, \java{'a'} becomes \java{'n'} and \java{'b'} becomes \java{'o'}.
The letters wrap around at the end, so \java{'z'} becomes \java{'m'}.

\begin{enumerate}

\item Write a method that takes a string and returns a new string containing the encoded version.
You should assume that the string contains upper and lower case letters and spaces, but no other characters.
Lower case letters should be transformed into other lowercase letters, and uppercase into uppercase.
You should not encode the spaces.

\item Generalize the method so that instead of adding 13 to each letter, it adds any given amount.
Now you should be able to encode things by adding 13 and decode them by adding -13.

\item Use your method to decrypt the string \java{"Jnl gb Tb"}.

\item Figure out how to decrypt \java{"Tjp adbpmzy do jpo"}.
It wasn't created by adding 13 to each letter.
Write a loop to try other possible values.

\end{enumerate}

\end{exercise}


%\input{todo-tex/chapter09.tex}
%\input{todo-tex/chapter11.tex}
%\input{todo-tex/chapter12.tex}
%\input{todo-tex/chapter13.tex}
%\input{todo-tex/chapter14.tex}
%\input{todo-tex/chapter15.tex}
%\input{todo-tex/chapter16.tex}

\backmatter
\appendix

%\input{todo-tex/chapter17.tex}
%\input{todo-tex/chapter18.tex}
%\input{todo-tex/chapter19.tex}
%\input{todo-tex/chapter20.tex}

\printindex
\cleardoublepage

\end{document}
