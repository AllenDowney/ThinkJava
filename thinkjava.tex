\documentclass[12pt]{book}

\newcommand{\thetitle}{Think Java: How to Think Like a Computer Scientist}
\title{\thetitle}

\newcommand{\theauthors}{Allen Downey and Chris Mayfield}
\author{\theauthors}

\newcommand{\theversion}{Version 6.0 Draft -- \today}
\date{\theversion}

\usepackage{geometry}
\geometry{
    width=5.5in,
    height=8.5in,
    hmarginratio=3:2,
    vmarginratio=1:1,
    includehead=true,
    headheight=15pt
}

% paragraph spacing
\setlength{\parindent}{0pt}                      % 17.62482pt
\setlength{\parskip}{12pt plus 4pt minus 4pt}    % 0.0pt plus 1.0pt
\linespread{1.05}
\def\arraystretch{1.5}

% list spacing
\setlength{\topsep}{5pt plus 2pt minus 3pt}      % 10.0pt plus 4.0pt minus 6.0pt
\setlength{\partopsep}{-6pt plus 2pt minus 2pt}  %  3.0pt plus 2.0pt minus 2.0pt
\setlength{\itemsep}{0pt}                        %  5.0pt plus 2.5pt minus 1.0pt

% these are copied from tex/latex/base/book.cls
% all I changed is afterskip
\makeatletter
\renewcommand{\section}{\@startsection {section}{1}{\z@}%
    {-3.5ex \@plus -1ex \@minus -.2ex}%
    {0.7ex \@plus.2ex}%
    {\normalfont\Large\bfseries}}
\renewcommand\subsection{\@startsection{subsection}{2}{\z@}%
    {-3.25ex\@plus -1ex \@minus -.2ex}%
    {0.3ex \@plus .2ex}%
    {\normalfont\large\bfseries}}
\renewcommand\subsubsection{\@startsection{subsubsection}{3}{\z@}%
    {-3.25ex\@plus -1ex \@minus -.2ex}%
    {0.3ex \@plus .2ex}%
    {\normalfont\normalsize\bfseries}}
\makeatother

% table of contents vertical spacing
\usepackage{tocloft}
\setlength\cftparskip{8pt plus 4pt minus 4pt}

% The following line adds a little extra space to the column
% in which the Section numbers appear in the table of contents
\makeatletter
\renewcommand{\l@section}{\@dottedtocline{1}{1.5em}{3.0em}}
\makeatother

% customize page headers
\usepackage{fancyhdr}
\pagestyle{fancyplain}
\renewcommand{\chaptermark}[1]{\markboth{Chapter \thechapter ~~ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection ~~ #1}}
\lhead[\fancyplain{}{\bfseries\thepage}]%
      {\fancyplain{}{\bfseries\rightmark}}
\rhead[\fancyplain{}{\bfseries\leftmark}]%
      {\fancyplain{}{\bfseries\thepage}}
\cfoot{}
%\rfoot{\textcolor{gray}{\tiny ThinkJava Draft \today}}

% balanced index with TOC entry
\usepackage{makeidx}
\makeindex
%\usepackage[totoc]{idxlayout}

% automatically index glossary terms
\newcommand{\term}[1]{%
\index{#1}
\item[#1:]}
% TODO: doesn't work with plastex
%\newcommand{\term}[1]{\item[#1:]}

% where to find graphics
\usepackage{graphicx}
%\graphicspath{{figs/}}

%% tweak spacing of figures and captions
%\usepackage{floatrow}
%\usepackage{caption}
%\captionsetup{
%    font=small,
%    labelformat=empty,
%    justification=centering,
%    skip=4pt
%}

% format end of chapter excercises
\usepackage{amsmath}
\usepackage{amsthm}
\newtheoremstyle{exercise}
  {12pt}        % space above
  {12pt}        % space below
  {}            % body font
  {}            % indent amount
  {\bfseries}   % head font
  {}            % punctuation
  {12pt}        % head space
  {}            % custom head
\theoremstyle{exercise}
\newtheorem{exercise}{Exercise}[chapter]

% colors for code listings and output
\usepackage{xcolor}
\definecolor{bgcolor}{HTML}{FAFAFA}
\definecolor{comment}{HTML}{007C00}
\definecolor{keyword}{HTML}{0000FF}
\definecolor{strings}{HTML}{B20000}

% syntax highlighting in code listings
\usepackage{textcomp}
\usepackage{listings}
\lstset{
    language=java,
    basicstyle=\ttfamily,
    backgroundcolor=\color{bgcolor},
    commentstyle=\color{comment},
    keywordstyle=\color{keyword},
    stringstyle=\color{strings},
    columns=fullflexible,
    keepspaces=true,
    showstringspaces=false,
    upquote=true,
    aboveskip=\parskip,
    belowskip=\parskip
}

% code listing environments
\lstnewenvironment{code}
{\minipage{\linewidth}}
{\endminipage}
\lstnewenvironment{stdout}
{\lstset{commentstyle=,keywordstyle=,stringstyle=}\minipage{\linewidth}}
{\endminipage}

% pdf hyperlinks, table of contents, and document properties
\usepackage[pdftex]{hyperref}
\hypersetup{%
  pdftitle={\thetitle},
  pdfauthor={\theauthors},
  pdfsubject={\theversion},
  pdfkeywords={},
  bookmarksopen=false,
  colorlinks=true,
  citecolor=black,
  filecolor=black,
  linkcolor=black,
  urlcolor=blue
}

% inline syntax formatting
\newcommand{\java}[1]{\lstinline{#1}} %\end{
%\newcommand{\java}[1]{\verb"#1"}
%\newcommand{\java}[1]{{\tt #1}}

\begin{document}

\frontmatter

%-half title--------------------------------------------------
%\thispagestyle{empty}
%
%\begin{flushright}
%\vspace*{2.0in}
%
%{\huge Think Java}
%
%\vspace{0.25in}
%{\LARGE How to Think Like a Computer Scientist}
%
%\vfill
%
%\end{flushright}

%--verso------------------------------------------------------

%\cleardoublepage
%\cleardoublepage

%--title page--------------------------------------------------
\pagebreak
\thispagestyle{empty}

\begin{flushright}
\vspace*{2.0in}

{\huge Think Java}

\vspace{0.25in}
{\LARGE How to Think Like a Computer Scientist}

\vspace{1in}
{\Large \theauthors}

\vspace{1in}
{\large \theversion}

\vfill

\end{flushright}

%--copyright--------------------------------------------------
\pagebreak
\thispagestyle{empty}

Copyright \copyright ~2016 Allen Downey and Chris Mayfield.

{\bf NOTE: This version of the book is a work in progress and won't be completed until February 2016.}

\vspace{0.25in}

Permission is granted to copy, distribute, transmit, and adapt this work under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License: \url{http://creativecommons.org/licenses/by-nc-sa/3.0/}

The original form of this book is \LaTeX\ source code.
Compiling the \LaTeX\ source has the effect of generating a device-independent representation of the book, which can be converted to other formats and printed.

The \LaTeX\ source for this book is available from \url{http://thinkjava.org}.
%-----------------------------------------------------------------

%\input{todo-tex/preface.tex}

% table of contents
\cleardoublepage
\setcounter{tocdepth}{1}
\tableofcontents

\mainmatter


\chapter{The way of the program}

The goal of this book is to teach you to think like a computer scientist.
This way of thinking combines some of the best features of mathematics, engineering, and natural science.
Like mathematicians, computer scientists use formal languages to denote ideas (specifically computations).
Like engineers, they design things, assembling components into systems and evaluating trade-offs among alternatives.
And like scientists, they observe the behavior of complex systems, form hypotheses, and test predictions.

\index{problem-solving}

The single most important skill for a computer scientist is {\bf problem-solving}.
It involves the ability to formulate problems, think creatively about solutions, and express solutions clearly and accurately.
As it turns out, the process of learning to program is an excellent opportunity to develop problem-solving skills.
That's why this chapter is called, ``The way of the program.''

On one level you will be learning to program, a useful skill by itself.
But on another level you will use programming as a means to an end.
As we go along, that end will become clearer.
Learning how to think in terms of computation is much more valuable than simply learning how to write code.


\section{What is programming?}

\index{program}

A {\bf program} is a sequence of instructions that specifies how to perform a computation.
%\footnote{This definition does not apply to all programming languages; for alternatives, see \url{http://en.wikipedia.org/wiki/Declarative_programming}.}
The computation might be something mathematical, like solving a system of equations or finding the roots of a polynomial.
It can also be a symbolic computation, like searching and replacing text in a document or (strangely enough) compiling a program.
The details look different in different languages, but a few basic instructions appear in just about every language.

\begin{description}
\item[input:] Get data from the keyboard, a file, a sensor, or some other device.
\item[output:] Display data on the screen or send data to a file or other device.
\item[math:] Perform basic mathematical operations like addition and division.
\item[decisions:] Check for certain conditions and execute the appropriate code.
\item[repetition:] Perform some action repeatedly, usually with some variation.
\end{description}

\index{programming}

Believe it or not, that's pretty much all there is to it.
Every program you've ever used, no matter how complicated, is made up of instructions that look much like these.
So you can think of {\bf programming} as the process of breaking down a large, complex task into smaller and smaller subtasks.
The process continues until the subtasks are simple enough to be performed with the basic instructions provided by computer hardware.


\section{What is computer science?}

One of the most interesting aspects of writing programs is deciding how to solve a particular problem, especially when there are multiple solutions.
For example, there are numerous ways to sort a list of numbers, and each way has its advantages (see \url{http://www.sorting-algorithms.com/}).
In order to determine which way is best for a given situation, we need techniques for describing and analyzing solutions formally.
That is where computer science comes in.

\index{computer science}
\index{algorithm}

Put simply, {\bf computer science} is the science of algorithms, including their discovery and analysis.
An {\bf algorithm} is a sequence of steps that specify exactly how to solve a problem.
Some algorithms are better than others in terms of low long they take or how much memory they use.
As you learn to develop algorithms for problems you haven't solved before, you also learn to think like a computer scientist.
%It's much more fun to discover new algorithms than to write the code for solutions that other people came up with!

\index{bug}
\index{debugging}

Designing algorithms and writing code is difficult and error-prone.
For historical reasons, programming errors are called {\bf bugs}, and the process of tracking them down and correcting them is called {\bf debugging}.
As you learn to debug your programs, you will develop new problem-solving skills.
You will need to think creatively when unexpected errors happen.

%In the old days, computer scientists had to deal with real bugs flying into their systems.
%You probably won't have that problem, but you will need to think creatively when unexpected errors happen.

%\begin{figure}[!h]
%\begin{center}
%\includegraphics[height=2.2in]{figs/firstbug.jpg}
%\caption{The first computer bug, taped to Grace Hopper's log book in 1947.
%\\ She discovered the moth in an electromagnetic relay of the Mark II.}
%\end{center}
%\end{figure}

% ABD: I don't love this particular piece of mythology, partly because it's not accurate, and partly because stories about the old days bore students.

Although it can be frustrating, debugging is an intellectually rich, challenging, and interesting part of computer programming.
In some ways, debugging is like detective work.
You are confronted with clues, and you have to infer the processes and events that led to the results you see.
Thinking about how to correct programs and improve their performance sometimes even leads to the discovery of new algorithms.


\section{Introduction to Java}

\index{high-level language}
\index{language!high-level}

The programming language you will learn is Java, which is relatively new (Sun released the first version in May 1995).
Java is an example of a {\bf high-level language}.
Other high-level languages you may have heard of include C and C++, JavaScript, Python, Ruby, and Visual Basic.

\index{low-level language}
\index{language!low-level}

There are also {\bf low-level languages}, sometimes referred to as ``machine languages'' or ``assembly languages.''
Loosely speaking, computers can only run programs written in low-level languages.
So programs written in a high-level language have to be translated before they can run.
This translation takes some time, which is a small disadvantage of high-level languages.
But the advantages of high-level languages are enormous.
As a result, low-level languages are only used for programs that need to interact directly with hardware.

\index{portable}

Due to the advantages, almost all programs are written in high-level languages.
First, it is {\em much} easier to program in a high-level language.
Programs take less time to write, are shorter and easier to read, and are more likely to be correct.
Second, high-level languages are {\bf portable}, meaning that they can run on different kinds of computers with few or no modifications.
Low-level programs can only run on one kind of computer, and have to be rewritten to run on another.

\index{interpreter}

Two kinds of programs translate high-level languages into low-level languages: interpreters and compilers.
An {\bf interpreter} reads a high-level program and executes it, meaning that it does what the program says.
It processes the program a little at a time, alternately reading lines and performing computations.
% Figure 1.1 shows the structure of an interpreter.

\begin{figure}[!h]
\begin{center}
\includegraphics{figs/interpreter.pdf}
\caption{How interpreted languages like Python and Ruby are executed.}
\end{center}
\end{figure}

\index{compiler}
\index{source code}
\index{object code}
\index{executable}

In contrast, a {\bf compiler} reads the entire program and translates it completely before the program starts running.
In this context, the high-level program is called the {\bf source code}, and the translated program is called the {\bf object code} or the {\bf executable}.
Once a program is compiled, you can execute it repeatedly without further translation.
As a result, compiled programs often run faster than interpreted programs.
% Figure 1.2 shows the structure of a compiler.

\index{byte code}

Java is {\em both} compiled and interpreted.
Instead of translating programs directly into machine language, the Java compiler generates {\bf byte code}.
Similar to machine language, byte code is easy (and fast) to interpret.
But it is also portable, like a high-level language.
Thus it is possible to compile a Java program on one machine, transfer the byte code to another machine, and then execute (interpret) the byte code on the other machine.
%This ability is an advantage of Java over some other high-level languages.

\begin{figure}[!h]
\begin{center}
\includegraphics{figs/compiler.pdf}
\caption{The process of editing, compiling, and running a Java program.}
\end{center}
\end{figure}

Although this process may seem complicated, in most program development environments these steps are automated for you.
Usually you will only have to write a program and press a button or type a single command to compile and run it.
On the other hand, it is important to know what steps are happening in the background, so if something goes wrong you can figure out what it is.


\section{Formal languages}

\index{natural language}
\index{language!natural}

Learning a programming language is very different from learning a {\bf natural language} such as English, Spanish, or German.
The languages that people speak evolved naturally over time.
They were not designed by people, although we try to impose order on them for practical reasons.

\index{formal language}
\index{language!formal}

In contrast, {\bf formal languages} are designed by people for specific applications.
For example, the notation that mathematicians use is a formal language that is particularly good at denoting relationships among numbers and symbols.
Chemists use a formal language to represent the chemical structure of molecules.
And most importantly:

\index{programming language}
\index{language!programming}

\begin{quote}
{\bf Programming languages are formal languages that have been designed to express computations.}
\end{quote}

\index{syntax}
\index{semantics}

Formal languages have strict rules about both the {\bf syntax} (structure) and the {\bf semantics} (meaning) of statements.
For example, $3 + 3 = 6$ is a syntactically correct mathematical statement, but $3\ + = 3\ \$\ 6$ is not.
$1 + 2 = 4$ uses correct syntax, but is semantically incorrect.
$H_2O$ is a syntactically correct chemical formula, but $_2Zz$ is not.

\subsection{Tokens and grammar}

\index{token}

Syntax rules come in two flavors, pertaining to tokens and grammar.
{\bf Tokens} are the basic elements of the language, like words, numbers, and chemical elements.
One of the problems with $3\ + = 3\ \$\ 6$ is that $\$$ is not a legal token in mathematics.
Similarly, $_2Zz$ is not legal because there is no element with the abbreviation $Zz$.

\index{grammar}

The second type of syntax rule pertains to the {\bf grammar} of the language, or the way tokens can be arranged.
The statement $3\ + = 3$ is structurally illegal, even though $+$ and $=$ are legal tokens, because you can't have one right after the other.
Similarly, in a chemical formula the subscript comes after the element name, not before.

\index{parse}

When you read a sentence in English or a statement in a formal language, you have to figure out its structure.
This process is called {\bf parsing}, and in a natural language you learn to do it unconsciously.
For example, when you hear the statement ``the penny dropped,'' you understand that the penny is the subject and dropped is the predicate.
After you have parsed the statement, you can begin to figure out what it means.
%Assuming that you know what a penny is and what it means to drop, you will understand the general implication of this statement.

\subsection{Reading source code}

Although formal and natural languages have features in common---tokens, grammar, and meaning---there are some differences.

\begin{description}

\term{ambiguity}
Natural languages are full of ambiguity, which people deal with by using contextual clues and other information.
Formal languages are designed to be nearly or completely unambiguous, which means that any statement has exactly one meaning, regardless of context.

\term{redundancy}
In order to make up for ambiguity and reduce misunderstandings, natural languages employ lots of redundancy.
As a result, they are often verbose.
Formal languages are less redundant and more concise.

\term{literalness}
Natural languages are full of idiom and metaphor.
When someone says ``the penny dropped'' there is no penny and nothing dropping.
This idiom means that someone finally realized something after a period of confusion.
In contrast, formal languages mean exactly what they say.

\end{description}

People who grow up speaking a natural language---that is, everyone---often have a hard time adjusting to formal languages.
In some ways, the difference between natural and formal language is like the difference between poetry and prose, but more so.

\begin{description}

\term{poetry}
Words are used for their sounds as well as for their meaning, and the whole poem together creates an effect or emotional response.
Ambiguity is not only common but often deliberate.

\term{prose}
The literal meaning of words is more important, and the structure contributes more meaning.
Prose is more amenable to analysis than poetry but still often ambiguous.

\term{program}
The meaning of a computer program is unambiguous and literal, and can be understood entirely by analysis of the tokens and grammar.

\end{description}

%Here are some suggestions for reading programs (and other formal languages).
Remember that formal languages are much more dense than natural languages, so it takes longer to read them.
The structure is very important, so it is not always a good idea to read from top to bottom, left to right.
Over time you will learn to parse the program in your head, identifying the tokens and interpreting the structure.
Finally, the details matter.
Small errors in spelling and punctuation, which you can get away with in natural languages, can make a big difference in a formal language.


\section{The hello world program}
\label{sec:hello}

\index{hello world}

Traditionally, the first program you write when learning a new programming language is called the hello world program.
All it does is display the words ``Hello, World!''\ on the screen.
In Java, it looks like this:

\begin{code}
public class Hello {

    public static void main(String[] args) {
        // generate some simple output
        System.out.println("Hello, World!");
    }

}
\end{code}

Note the output of this program does not include the quote marks:

\begin{stdout}
Hello, World!
\end{stdout}

\index{public}
\index{static}

Unfortunately in Java, even this simple example requires language features that are difficult to explain to beginners.
But it provides a preview of topics that we will see in detail later on.
The word \java{public} means the code can be accessed from other source files.
The word \java{static} means that memory is allocated for the program in advance.
We will discuss \java{void}, \java{String}, and \java{args} in the next few chapters.
For now, let's focus on the overall structure.

\index{class!definition}
\index{method!definition}

Java programs are made up of {\bf class} and {\bf method} definitions, which generally have the form:

\begin{code}
public class CLASSNAME {

    METHOD {
        STATEMENTS
    }

    METHOD {
        STATEMENTS
    }

}
\end{code}

\index{class!name}

Here \java{CLASSNAME} indicates the name chosen by the programmer.
Java requires the class name to match the source file name.
In the hello world example, the file name must be {\tt Hello.java} because the class name is \java{Hello}.

\index{statement}
\index{main}

Classes define a program's methods, or named sequences of {\bf statements}.
The \java{Hello} class has only one method:

\begin{code}
    public static void main(String[] args)
\end{code}

The name and format of \java{main} is special; it marks the place in the class where execution begins.
When the program runs, it starts at the first statement in \java{main} and ends when it finishes the last statement.

\index{braces}
\index{squiggly braces}

Java uses squiggly braces (\{ and \}) to group things together.
In {\tt Hello.java}, the outermost braces (lines 1 and 8) contain the class definition, and the inner braces (lines 3 and 6) contain the definition of \java{main} method.

% ABD: It looks like we don't have line numbers in the listings.
% Is that a problem for the text here?

\index{println}
\index{statement!print}

The main method can have any number of statements, but the \java{Hello} example has only one.
It is a {\bf print statement}, meaning that it displays a message on the screen.
Confusingly, print can mean both ``display something on the screen'' and ``send something to the printer.''
%I won't say much about sending things to the printer;
In this book, we'll do all our printing on the screen.
The print statement ends with a semicolon ({\tt ;}).

\index{comments!inline}
\index{statement!comment}

Line 4 contains a {\bf comment}, or a bit of English text that explains the code that follows.
When the compiler sees {\tt //}, it ignores everything from there until the end of the line.
It is a good idea to write a comment before every major block of code so that other programmers (including your future self) can understand what you meant to do.


\section{Getting started with DrJava}

\index{JDK}

In order to compile Java programs on your own computer, you will need to install the Java Development Kit (JDK).
This free software by Oracle includes tools for developing and debugging Java programs.
All the examples in this book were developed and tested using Java SE Version 7.
Later versions of Java are generally backward compatible, so if you are using a more recent version, the examples in this book should still work.

\begin{figure}[!h]
\begin{center}
\includegraphics[width=\textwidth]{figs/drjava-hello.png}
\caption{Screenshot of DrJava editing the hello world program.}
\end{center}
\end{figure}

\index{DrJava}

We will use DrJava as the primary development environment throughout the book.
A useful feature of DrJava is the Interactions Pane at the bottom of the window.
It provides the ability to try out code quickly, without having to write a class definition and save/compile/run the program.
Refer to the DrJava documentation (\url{http://drjava.org/docs/quickstart/}) for more details.

Step-by-step instructions for installing the JDK and configuring DrJava are available on this book's website: \url{http://thinkjava.org/}

% TODO: when we have the specific URL for the install page, let's put it here.

\subsection{Command-line interface}

\index{command-line}
\index{terminal}

One of the most powerful and useful skills you can learn as a computer scientist is how to use the {\bf command-line}, also called
the {\em terminal}.
The command-line is a direct interface to the operating system.
It allows you to run programs, manage files and directories, and monitor system resources.
Many advanced tools, both for software development and general purpose computing, are available only at the command-line.

There are many good tutorials online for learning the command-line for your operating system; just search the web for ``command line tutorial.''
To get started, you only need to know four commands: how to change the working directory ({\tt cd}), list directory contents ({\tt ls}), compile Java programs ({\tt javac}), and run Java programs ({\tt java}).

% ABD: There's a conflict here between ``Find the details for your system'' and ``Here are the UNIX commands''.

\begin{figure}[!h]
\begin{center}
\includegraphics[width=4.5in]{figs/terminal.png}
\caption{Compiling and running {\tt Hello.java} from the command-line.}
\end{center}
\end{figure}

In this example, the {\tt Hello.java} source file is stored in the {\tt Desktop} directory.
After changing to that location and listing the files, we use the {\tt javac} command to compile {\tt Hello.java}.
Running {\tt ls} again, we see that the compiler generated a new file, {\tt Hello.class}, which contains the byte code.
We run the program using the {\tt java} command, which displays the output on the following line.

Note that the {\tt javac} command requires a {\em file name} (or multiple source files separated by spaces), whereas the {\tt java} command requires a single {\em class name}.
If you use DrJava, it runs these commands for you and displays the output in the Interactions Pane.

Taking time to learn this efficient and elegant way of interacting with your operating system will make you more productive as a computer user.
People who don't use the command-line don't know what they're missing.

% ABD: Maybe add a reference to Neal Stephenson's book?


\section{More printing}

You can put as many statements as you want in \java{main}.
For example, to print more than one line:

\begin{code}
public class Hello {

    public static void main(String[] args) {
        // generate some simple output
        System.out.println("Hello, World!");  // print one line
        System.out.println("How are you?");   // print another
    }

}
\end{code}

As this program demonstrates, you can put comments at the end of a line as well as on lines all by themselves.

\index{String}
\index{type!String}

Phrases that appear in quotation marks are called {\bf strings}, because they contain a sequence of characters strung together.
Strings can contain any combination of letters, numbers, punctuation marks, symbols, and even non-printable characters like tab and backspace.

\index{newline}
\index{print}
\index{statement!print}

The name \java{println} is short for ``print line.''
It appends a special character, called a {\bf newline}, that advances the cursor to the beginning of the next line.
%The next time \java{println} is invoked, the new text appears on the next line.
To display the output from multiple print statements on one line, use \java{print}:

\begin{code}
public class Goodbye {

    public static void main(String[] args) {
        System.out.print("Goodbye, ");
        System.out.println("cruel world");
    }

}
\end{code}

The output appears on a single line as {\tt Goodbye, cruel world}.
Notice that there is a space between the word ``Goodbye'' and the second quotation mark.
This space appears in the output, so it affects the {\em behavior} of the program.

\subsection{Code formatting}
\label{sec:formatting}

Spaces that appear outside of quotation marks generally do not affect the behavior of the program.
For example, we could have written:

\begin{code}
public class Goodbye {
public static void main(String[] args) {
System.out.print("Goodbye, ");
System.out.println("cruel world");
}
}
\end{code}

This program would compile and run just as well as the original.
The newlines at the end of each line do not affect the program's behavior either.
So we could have also written:

\begin{code}
public class Goodbye { public static void main(String[] args) {
System.out.print("Goodbye, "); System.out.println
("cruel world");}}
\end{code}

It still works, but the program is getting harder and harder to read.
Newlines and spaces are important for organizing your program visually, making it easier to understand the program and find errors when they occur.
%Formatting your code well does not take much effort, and it pays huge dividends.
%We will discuss readability and style guidelines in the next chapter.

\subsection{Escape sequences}

It is possible to print multiple lines of output in just one line of code.
You simply have to tell Java where to put the newlines.

\begin{code}
public class Hello {

    public static void main(String[] args) {
        System.out.print("Hello!\nHow are you doing?\n");
    }

}
\end{code}

The output is two lines, each ending with a newline character:

\begin{stdout}
Hello!
How are you doing?
\end{stdout}

\index{escape sequence}

The code \verb"\n" is an example of an {\bf escape sequence}, which is a sequence of characters in a string that represents a special character.
The backslash allows you to ``escape'' the string's literal interpretation.
Notice there is no space between \verb"\n" and \verb"How".
If you add a space there, there will be a space at the beginning of the second line.

\begin{table}[!h]
\begin{center}
\begin{tabular}{|c|c|}
\hline
\verb"\n" & newline \\
\hline
\verb"\t" & tab \\
\hline
\verb'\"' & double quote \\
\hline
\verb"\\" & backslash \\
\hline
\end{tabular}
\caption{Common escape sequences}
\end{center}
\end{table}

Another common use of escape sequences is to have quote marks inside of strings.
Since double quotes indicate the beginning and end of strings, you need to escape them with a backslash.

\begin{code}
    System.out.println("She said \"Hello!\" to me.");
\end{code}

The result is:

\begin{stdout}
She said "Hello!" to me.
\end{stdout}


\section{Working through examples}
\label{sec:examples}

It is a good idea to read this book in front of a computer so you can try out the examples as you go.
You can run many of the examples directly in DrJava's Interactions Pane, but if you put the code in a source file, it will be easier to try out variations.

Whenever you are experimenting with a new feature, you should also try to make mistakes.
For example, in the hello world program, what happens if you leave out one of the quotation marks?
What if you leave out both?
What if you spell \java{println} wrong?
This kind of experiment helps you remember what you read.
It also helps with debugging, because you get to know what the error messages mean.
It is better to make mistakes now and on purpose than later on and accidentally.

\index{experimental debugging}
\index{debugging!experimental}

\index{Holmes, Sherlock}
\index{Doyle, Arthur Conan}

Debugging is like an experimental science.
Once you have an idea about what is going wrong, you modify your program and try again.
If your hypothesis was correct, then you can predict the result of the modification, and you take a step closer to a working program.
If your hypothesis was wrong, you have to come up with a new one.
As Sherlock Holmes pointed out, ``When you have eliminated the impossible, whatever remains, however improbable, must be the truth.''
(A.~Conan Doyle, {\em The Sign of Four}.)

Programming and debugging should go hand in hand.
Don't just write a bunch of code and then perform trial and error debugging until it all works.
Instead, start with a program that does {\em something} and make small modifications, debugging them as you go, until the program does what you want.
That way you will always have a working program, and it will be easier to isolate errors.

\index{Linux}
\index{Torvalds, Linus}
\index{Greenfield, Larry}

A great example of this principle is the Linux operating system, which contains millions of lines of code.
It started out as a simple program Linus Torvalds used to explore the Intel 80386 chip.
According to Larry Greenfield, ``One of Linus's earlier projects was a program that would switch between printing AAAA and BBBB.
This later evolved to Linux.'' ({\em The Linux Users' Guide})

%Later chapters will make more suggestions about debugging and other programming practices.

Finally, programming sometimes brings out strong emotions.
If you are struggling with a difficult bug, you might feel angry, despondent, or embarrassed.
Remember that you are not alone, and most if not all programmers have had similar experiences.
Don't hesitate to reach out to a friend and ask questions!

%\index{emotional debugging}
%\index{debugging!emotional response}

%There is evidence that people naturally respond to computers as if they were people.
%When they work well, we think of them as teammates, and when they are obstinate or rude, we respond to them the same way we respond to rude, obstinate people.
%(Reeves and Nass, {\it The Media Equation: How People Treat Computers, Television, and New Media Like Real People and Places})

%Preparing for these reactions might help you deal with them.
%One approach is to think of the computer as an employee with certain strengths, like speed and precision, and particular weaknesses, like lack of empathy and inability to grasp the big picture.

%Your job is to be a good manager: find ways to take advantage of the strengths and mitigate the weaknesses.
%And find ways to use your emotions to engage with the problem, without letting your reactions interfere with your ability to work effectively.

%Learning to debug can be frustrating, but it is a valuable skill that is useful for many activities beyond programming.
%At the end of each chapter there is a debugging section, like this one, with my thoughts about debugging.
%I hope they help!


\section{Vocabulary}

\begin{description}

\term{problem-solving}
The process of formulating a problem, finding a solution, and expressing the solution.

\term{program}
A sequence of instructions that specify how to perform tasks on a computer.

\term{programming}
The application of problem-solving to creating executable computer programs.

\term{computer science}
The scientific and practical approach to computation and its applications.

\term{algorithm}
A procedure or formula for solving a problem, with or without a computer.

\term{bug}
An error in a program.

\term{debugging}
The process of finding and removing any of the three kinds of errors.

\term{high-level language}
A programming language that is designed to be easy for humans to read and write.

\term{low-level language}
A programming language that is designed to be easy for a computer to run.
Also called ``machine language'' or ``assembly language.''

\term{portable}
The ability of a program to run on more than one kind of computer.

\term{interpret}
To run a program in a high-level language by translating it one line at a time and immediately executing the corresponding instructions.

\term{compile}
To translate a program in a high-level language into a low-level language, all at once, in preparation for later execution.

\term{source code}
A program in a high-level language, before being compiled.

\term{object code}
The output of the compiler, after translating the program.

\term{executable}
Another name for object code that is ready to run on specific hardware.

\term{byte code}
A special kind of object code used for Java programs.
Byte code is similar to a low-level language, but it is portable like a high-level language.

\term{natural language}
Any of the languages people speak that have evolved naturally.

\term{formal language}
A language people have designed for specific purposes, like representing mathematical ideas or computer programs.

\term{programming language}
A formal language that has been designed to express computations.

\term{syntax}
The structure of a program.

\term{semantics}
The meaning of a program.

\term{token}
A basic element of a program, such as a word, space, symbol, or number.

\term{grammar}
A set of rules that determines whether a statement is legal.

\term{parse}
To examine a program and analyze the syntactic structure.

\term{statement}
A part of a program that specifies a computation.

\term{method}
A named sequence of statements.

\term{class}
For now, a collection of related methods. (We will see later that there is more to it.)

\term{print statement}
A statement that causes output to be displayed on the screen.

\term{comment}
A part of a program that contains information about the program but has no effect when the program runs.

\term{command-line}
A means of interacting with the computer by issuing commands in the form of successive lines of text.

\term{string}
A sequence of characters; the primary data type for text.

\term{newline}
A special character signifying the end of a line of text.
Also known as line ending, end of line (EOL), or line break.

\term{escape sequence}
A sequence of code that represents a special character when used inside a string.

\end{description}


\section{Exercises}

\begin{exercise}

Computer scientists have the annoying habit of using common English words to mean something other than their common English meaning.
For example, in English, statements and comments are the same thing, but in programs they are different.

The glossary at the end of each chapter is intended to highlight words and phrases that have special meanings in computer science.
When you see familiar words, don't assume that you know what they mean!

\begin{enumerate}
\item In computer jargon, what's the difference between a statement and a comment?
\item What does it mean to say that a program is portable?
\item What is an executable?
\end{enumerate}

\end{exercise}

\begin{exercise}

Before you do anything else, find out how to compile and run a Java program in your environment.
Some environments provide sample programs similar to the example in Section~\ref{sec:hello}.

\begin{enumerate}
\item Type in the ``Hello, world'' program, then compile and run it.

\item Add a print statement that prints a second message after the ``Hello, world!''.
Say something witty like, ``How are you?''
Compile and run the program again.

\item Add a comment to the program (anywhere), recompile, and run it again.
The new comment should not affect the result.
\end{enumerate}

This exercise may seem trivial, but it is the starting place for many of the programs we will work with.
To debug with confidence, you have to have confidence in your programming environment.
In some environments, it is easy to lose track of which program is executing.
You might find yourself trying to debug one program while you are accidentally running another.
Adding (and changing) print statements is a simple way to be sure that the program you are looking at is the program you are running.

\end{exercise}

\begin{exercise}

It is a good idea to commit as many errors as you can think of, so that you see what error messages the compiler produces.
Sometimes the compiler tells you exactly what is wrong, and all you have to do is fix it.
But sometimes the error messages are misleading.
You will develop a sense for when you can trust the compiler and when you have to figure things out yourself.

\begin {enumerate}
\item Remove one of the open squiggly-braces.
\item Remove one of the close squiggly-braces.
\item Instead of \java{main}, write \java{mian}.
\item Remove the word \java{static}.
\item Remove the word \java{public}.
\item Remove the word \java{System}.
\item Replace \java{println} with {Println}.
\item Replace \java{println} with {print}.
This one is tricky because it is a logic error, not a syntax error.
The statement \java{System.out.print} is legal, but it may or may not do what you expect.
\item Delete one of the parentheses.  Add an extra one.
\end {enumerate}

\end{exercise}


\chapter{Variables and arithmetic}

This chapter is about storing values in computer memory and doing basic arithmetic.
More importantly, it discusses how to {\em compose} statements using smaller building blocks such as variables and operators.
We also discuss code quality, which is almost as important as correctness.
High quality code is easier to read, which makes it easier to maintain and debug.

%For better or worse, Java performs some conversions automatically when you have different types of data in the same statement.
%Following style guidelines helps you to avoid common programming mistakes that are difficult to debug.


\section{Types of errors}

\index{error!message}

%As you begin writing your own programs, you will encounter various error messages.
Three kinds of errors can occur in a program: syntax errors, runtime errors, and logic errors.
It is useful to distinguish between them in order to track them down more quickly.
Regardless of what type of error occurs, remember to {\em read and think about the error messages carefully}.
They will usually point you in the right direction to fix your program.

\subsection{Syntax errors}

\index{syntax error}
\index{error!syntax}

The compiler can only translate a program if the syntax is correct; otherwise, it fails and displays an error message.
For example, parentheses have to come in matching pairs.
So \java{(1 + 2)} is legal, but \java{8)} is a {\bf syntax error}.

In English, readers can tolerate most syntax errors, which is why we can read the poetry of E.\ E.\ Cummings without spewing error messages.
Java is not so forgiving; if there is a single syntax error anywhere in your program, the compiler will display an error message and quit, and you will not be able to run the program.

\begin{figure}[!h]
\begin{center}
\includegraphics[width=\textwidth]{figs/syntax-error.png}
\caption{A syntax error caused by a missing brace.}
\label{fig:syntax}
\end{center}
\end{figure}

To make matters worse, the error messages you get from the compiler are often not very helpful.
As shown in Figure~\ref{fig:syntax}, removing the closing brace on line 8 of the hello world program results in ``Error: reached end of file while parsing.''
The compiler also reports that the problem was found on line 6, which in this case is not at fault.
Since line 8 was deleted, the compiler simply reported the last line of the file.

During the first few weeks of your programming career, you will probably spend a lot of time tracking down syntax errors.
But as you gain experience, you will make fewer mistakes and find them more quickly.

\subsection{Runtime errors}

\index{runtime error}
\index{error!runtime}
%\index{type-safe}
%\index{language!type-safe}

The second type of error is a {\bf runtime error}, so called because it does not appear until after the program has started running.
In Java, these errors occur when the interpreter is executing the byte code and something goes wrong.
%Java is designed to be a {\bf type-safe} language, which means that the compiler can detect many potential errors cased by common programming mistakes.
Runtime errors are rare in the simple programs you will see in the first few chapters, so it might be a while before you encounter one.

\index{exception}

These errors are also called {\em exceptions} because they usually indicate that something exceptional (and bad) has happened.
In most environments they appear as windows or dialog boxes that contain information about what happened and what the program was doing when it happened.
For example, if you accidentally divide by zero you will get an \java{ArithmeticException}:

\begin{small}
\begin{stdout}
Exception in thread "main" java.lang.ArithmeticException: / by zero
    at Hello.main(Hello.java:5)
\end{stdout}
\end{small}

This information is useful for debugging.
The first line gives a brief description of the error (/ by zero).
The subsequent lines report the class and method names (Hello.main), along with the file name and line number where the error occurred (Hello.java:5).
Keep in mind that the line where the program crashed may not be the line that needs to be fixed.

\subsection{Logic errors}

\index{logic error}
\index{error!logic}

The third type of error is the {\bf logic error}.
If there is an error in your program's logic, it will compile and run successfully in the sense that the computer will not generate any error messages.
But it will not do the right thing.
It will do something else.
Specifically, it will do what you told it to do.
Here is an example of a logic error in the hello world program:

\begin{code}
public class Hello {

    public static void main(String[] args) {
        System.out.println("Goodbye, world.");
    }

}
\end{code}

This program compiles and runs just fine.
The problem is that the main method is not the program we intended.
The meaning of the program is wrong, because it says goodbye instead of hello.
In addition, world is not capitalized, and it ends with a period instead of an exclamation point.

Identifying logic errors can be tricky because it requires you to challenge your assumptions, both about the code and the requirements.
You will need to work backwards by looking at the output of the program, try to figure out what it is doing, and make sure you understand what it should be doing.


\section{Creating variables}

\index{variable}
\index{value}

One of the most powerful features of a programming language is the ability to define and manipulate {\bf variables}.
A variable is a named location of computer memory that stores a {\bf value}.
Values may be numbers, text, images, sounds, and other types of data.
%They can be printed, and as we'll see later, operated on.
To store a value in memory, you first have to create a variable.
%Since the values we want to store are text, we declare that the new variable is a string:

\begin{code}
    String message;
\end{code}

\index{declaration}
\index{statement!declaration}
\index{type!int}
\index{type!char}
\index{type!String}

This statement is a {\bf declaration}, because it declares that the variable named \java{message} has the type \java{String}.
Each variable has a {\bf type} that determines what kind of values it can store.
For example, the \java{int} type can store integers, and the \java{char} type can store characters.

Some types begin with a capital letter and some with lower-case.
We will learn the significance of this distinction later, but for now you should take care to get it right.
There is no such type as \java{Int} or \java{string}, and the compiler will complain if you make one up.

To declare an integer variable, the syntax is:

\begin{code}
    int x;
\end{code}

Note that \java{x} is an arbitrary name for the variable.
In general, you should use names that indicate what the variables mean.
For example, if you saw these variable declarations, you could probably guess what values would be stored in them:

\begin{code}
    String firstName;
    String lastName;
    int hour, minute;
\end{code}

This example also demonstrates the syntax for declaring multiple variables with the same type: \java{hour} and \java{minute} are both integers.
Note that each declaration statement ends with a semicolon.

You can use any name you want for a variable.
But there are certain words that are reserved in Java, because they are used by the compiler to parse the structure of the program.
These {\bf keywords} include \java{public}, \java{class}, \java{static}, \java{void}, \java{int}, and others (there are currently 50 in Java).
Search the Internet for ``Java keywords'' to see the complete list.

%The complete list is available at \url{https://docs.oracle.com/javase/tutorial/}.
%This site, provided by Oracle, includes Java documentation I refer to throughout the book.

Rather than memorize the keywords, you should take advantage of the syntax highlighting provided in many development environments (including DrJava).
As you type, the tokens in your program will appear in different colors.
For example, keywords might be blue, strings red, comments green, and other code black.
If you type a variable name and it turns blue, watch out!

\subsection{Assignment}

\index{assignment}
\index{statement!assignment}

Now that we have created variables, we want to store values.
We do that with an {\bf assignment} statement.

\begin{code}
    message = "Hello!";  // give message the value "Hello!"
    hour = 10;           // assign the value 10 to hour
    minute = 59;         // set minute to 59
    hour = 11;           // change the hour to 11
\end{code}

This example shows four assignments, and the comments illustrate different ways people sometimes talk about assignment statements.
The vocabulary can be confusing here, but the idea is straightforward:

\begin{itemize}
\item When you declare a variable, you create a named storage location.
\item When you make an assignment to a variable, you give it a value.
\item If you reassign the variable, its value changes.
\end{itemize}

As a general rule, a variable has to have the same type as the value you assign to it.
For example, you cannot store a \java{String} in \java{minute} or an integer in \java{message}.
We will see some examples that seem to break this rule, but we'll get to that later.

%On the other hand, that rule can be confusing.
%There are many ways that you can convert values from one type to another, and Java sometimes converts things automatically.
%For now you should remember the general rule, and we'll talk about exceptions later.

A common source of confusion is that some strings {\em look} like integers, but they are not.
For example, \java{message} can contain the string \java{"123"}, which is made up of the characters \java{'1'}, \java{'2'}, and \java{'3'}.
But that is not the same thing as the integer \java{123}.

\begin{code}
    message = "123";  // legal
    message = 123;    // not legal
\end{code}

\subsection{Memory diagrams}

\index{memory diagram}

A common way to represent variables on paper is to draw a box with the name of the variable on the outside and the value of the variable on the inside.
This diagram shows the effect of the four assignments in the previous section:

\begin{center}
\begin{tabular}{rl}
message & \framebox[2cm]{Hello!} \\
   hour & \framebox[1cm]{11} \\
 minute & \framebox[1cm]{59} \\
\end{tabular}
\end{center}

% ABD: In the hour box, consider showing 10 crossed out, followed by 11?

Each box represents the storage location that holds the variable's value.
Once declared, you cannot change the name of a variable, but you can change the value as many times as you like.
For example, \java{hour} was initially \java{10}, then reassigned to \java{11}.
The diagram shows only the final value.

%Since these locations can be anywhere in memory, we refer to them by the variable name.
%The storage location does not change; those memory cells are simply reused.


\section{Printing variables}
\label{sec:printvar}

You can display the value of a variable using \java{print} or \java{println}.
The following program declares a variable named \java{firstLine}, assigns it the value \java{"Hello, again!"}, and then prints that value.

\begin{code}
public class Hello {
    public static void main(String[] args) {
        String firstLine;
        firstLine = "Hello, again!";
        System.out.println(firstLine);
    }
}
\end{code}

When we talk about printing a variable, we generally mean printing the {\em value} of the variable.
To print the {\em name} of a variable, you have to put it in quotes.
%For example: \java{System.out.println("firstLine");}
For example, you can write:

\begin{code}
    String firstLine;
    firstLine = "Hello, again!";
    System.out.print("The value of firstLine is ");
    System.out.println(firstLine);
\end{code}

The output of this program is:

\begin{stdout}
The value of firstLine is Hello, again!
\end{stdout}

%The output does not contain quote marks around \java{Hello, again!}.
%Those quote marks were part of the source code, not the value.

The syntax for printing a variable is the same regardless of the variable's type.
For example:

\begin{code}
    int hour, minute;
    hour = 11;
    minute = 59;
    System.out.print("The current time is ");
    System.out.print(hour);
    System.out.print(":");
    System.out.print(minute);
    System.out.println(".");
\end{code}

The output of this program is:

\begin{stdout}
The current time is 11:59.
\end{stdout}

To output multiple values on the same line, it's common to use several \java{print} statements followed by a \java{println} at the end.
{\bf Don't forget the \java{println}!}
On many operating systems, the output from \java{print} is stored without being displayed until \java{println} is invoked, at which point the entire line is displayed at once.
If you omit the \java{println}, the program may display the stored output at unexpected times or even terminate without displaying anything.


\section{Arithmetic operators}

%Recall that Java programs are organized into {\em classes}, each of which has one or more {\em methods}, each of which has one or more {\em statements}.
%Most statements consist of one or more {\bf expressions}.

\index{operator}

{\bf Operators} are symbols that represent computations like addition and multiplication.
%Most operators in Java do what you expect them to do, since they are common mathematical symbols.
For example, the operator for addition is {\tt +}, subtraction is {\tt -}, multiplication is {\tt *}, and division is {\tt /}.
%Variables are replaced with their values before the computation is performed.

The following program converts the time of day to minutes:

\begin{code}
    int hour, minute;
    hour = 11;
    minute = 59;
    System.out.print("Number of minutes since midnight: ");
    System.out.println(hour * 60 + minute);
\end{code}

\index{expression}

In this program, \java{hour * 60 + minute} is an {\bf expression}, which represents a single value to be computed.
When the program runs, each variable is replaced by its current value, and then the operators are applied.
The result is:

\begin{stdout}
Number of minutes since midnight: 719
\end{stdout}

Expressions are generally a combination of numbers, variables, and operators.
When complied and executed, they become a single value:

\begin{code}
    1 + 1     hour - 1     hour * 60 + minute     minute / 60
    2         11 - 1       11 * 60 + 59           59 / 60
              10           660 + 59               0
                           719
\end{code}

Addition, subtraction, and multiplication all do what you expect, but you might be surprised by division.
For example, the following lines try to compute the fraction of an hour that has elapsed:

\begin{code}
    System.out.print("Fraction of the hour that has passed: ");
    System.out.println(minute / 60);
\end{code}

But the program outputs:

\begin{stdout}
Fraction of the hour that has passed: 0
\end{stdout}

\index{division!integer}
\index{integer division}

This result often confuses people.
After all, the value of \java{minute} is 59, and 59 divided by 60 should be 0.98333, not 0.
The problem here is that Java performs {\em integer division}.
When the values being divided are integers, the result is also an integer.
Computer hardware is designed so that integer division always {\em rounds down}, even in cases like this one where the next integer is close.

One solution is to calculate a percentage rather than a fraction:

\begin{code}
    System.out.print("Percent of the hour that has passed: ");
    System.out.println(minute * 100 / 60);
\end{code}

The new output is:

\begin{stdout}
Percent of the hour that has passed: 98
\end{stdout}

Again the result is rounded down, but at least now it's approximately correct.
%To get a more precise answer, we can use a different type of variable that can store fractional values.


\section{Floating-point numbers}

\index{floating-point}
\index{double (floating-point)}
\index{type!double}

A more general solution is to use {\bf floating-point} numbers, which can represent fractions as well as integers.
%As the name implies, the decimal point floats around (i.e., you can have as many decimal places as you want).

In Java, the default floating-point type is called \java{double}, which is short for double-precision.
You can create \java{double} variables and assign values to them using the same syntax we used for the other types:

\begin{code}
    double pi;
    pi = 3.14159;
\end{code}

Although floating-point numbers are useful, they can be a source of confusion.
For example, Java distinguishes the integer value \java{1} from the floating-point value \java{1.0}, even though they seem to be the same number.
They belong to different data types, and strictly speaking, you are not allowed to make assignments between types.

The following is illegal because the variable on the left is an \java{int} and the value on the right is a \java{double}.

\begin{code}
    int x;
    x = 1.1;  // syntax error
\end{code}

But it is easy to forget this rule because in many cases Java {\em automatically} converts from one type to another:

\begin{code}
    double y;
    y = 1;  // bad style
\end{code}

The above example should be illegal, but Java allows it by converting the \java{int} value \java{1} to the \java{double} value \java{1.0} automatically.
This leniency is convenient, but it often causes problems for beginners. For example:

\begin{code}
    double y;
    y = 1 / 3;  // logic error
\end{code}

\index{division!integer}
\index{integer division}

You might expect the variable \java{y} to get the value \java{0.333333}, which is a legal floating-point value.
But instead it gets the value \java{0.0}.
The reason is that the expression on the right divides two integers.
So Java does {\em integer division}, which yields the \java{int} value \java{0}.
Converted to \java{double}, the final result is \java{0.0}.

One way to solve this problem (after you finally discover that bug) is to make the right-hand side a floating-point expression.
The following initializes \java{y} to \java{0.333333}, as expected:

\begin{code}
    double y;
    y = 1.0 / 3.0;  // correct
\end{code}

As a matter of style, you should always assign floating-point values to floating-point variables.
The compiler won't make you do it, but you never know when a bug like this one will come back and haunt you.


\section{Rounding errors}

%The operations we have seen so far---addition, subtraction, multiplication, and division---also work on floating-point values, although you might be interested to know that the underlying mechanism is completely different.
%In fact, most processors have special circuitry just for performing floating-point operations.

\index{rounding error}

On hardware, floating-point numbers are only {\it approximately} correct.
Some numbers, like reasonably-sized integers, can be represented exactly.
But repeating fractions, like $1/3$, and irrational numbers, like $\pi$, cannot.
To represent these numbers, computers have to round off to the nearest floating-point number.
The difference between the number we want and the floating-point number we get is called {\bf rounding error}.

%Notwithstanding, there is a fundamental flaw with floating-point arithmetic.
%In mathematics, there is an infinite number of real numbers.
%But computer processors are finite; they cannot represent {\em every} possible floating-point number.
%Even with double-precision, you will frequently run into problems.

\index{arithmetic!floating-point}

For example, the following two statements should be equivalent:

\begin{code}
    System.out.println(0.1 * 10);
    System.out.println(0.1 + 0.1 + 0.1 + 0.1 + 0.1
                     + 0.1 + 0.1 + 0.1 + 0.1 + 0.1);
\end{code}

But on many machines, the output is:

\begin{stdout}
1.0
0.9999999999999999
\end{stdout}

The problem is that \java{0.1}, which is a terminating fraction in base 10, is a repeating fraction in base 2.
So its floating-point representation is only approximate.
When we add up the approximations, the rounding errors accumulate.

For many applications, like computer graphics, encryption, statistical analysis, and multimedia rendering, floating-point arithmetic has benefits that outweigh the costs.
But if you need {\em absolute} precision, use integers instead.
For example, consider a bank account with a balance of \$123.45:

\begin{code}
    double balance = 123.45;  // potential rounding error
\end{code}

In this example, balances will become inaccurate over time as the variable is used in arithmetic operations like deposits and withdrawals.
The result would be angry customers and potential law suits.
You can avoid the problem by representing the balance as an integer:

\begin{code}
    int balance = 12345;      // total number of cents
\end{code}

\index{type!long}

This solution works as long as the number of cents doesn't exceed the largest integer, which is about 2 billion.
If necessary you can use \java{long} instead, which has a max value of $2^{63}-1$ (about 92 quadrillion dollars).
Hopefully nobody will ever need that much money!


\section{Operators for strings}

\index{string operator}
\index{operator!string}

In general, you cannot perform mathematical operations on strings, even if the strings look like numbers.
The following expressions are illegal:

\begin{code}
    "Hello" - 1     "World" / 123     "Hello" * "World"
\end{code}

%Note that it's unclear looking at these expressions whether \java{message} is an integer or a string.
%The only way to tell the type of a variable is to look at the place where it is declared.

\index{concatenate}

The {\tt +} operator does work with strings, but it might not do what you expect.
For strings, the {\tt +} operator performs {\bf concatenation}, which means joining each part end-to-end.
So \java{"Hello, " + "world!"} yields the string \java{"Hello, world!"}.
Likewise, the expression \java{"Hello, " + name} adds the value of \java{name} to the hello string, which is handy for creating a personalized greeting.

%When you append two strings, make sure one of them contains a space character.
%Otherwise you will end up with something like \java{"Hello,world!"}.

%\subsection{Adding Strings and numbers}

%If you add an \java{int} and a \java{double}, Java automatically converts the \java{int} into a \java{double} before performing the addition:

%\begin{code}
%    System.out.println(1 + 2.0);
%    // prints 3.0
%\end{code}

Since addition is defined for both numbers and strings, Java performs automatic conversions you may not expect:

% TODO: use DrJava interactive format for these examples?

\begin{code}
    System.out.println(1 + 2 + "Hello");
    // the output is 3Hello

    System.out.println("Hello" + 1 + 2);
    // the output is Hello12
\end{code}

Java executes these operations from left to right.
In the first line, \java{1 + 2} is the value \java{3}, and \java{3 + "Hello"} is the value \java{"3Hello"}.
But in the second line, \java{"Hello" + 1} is \java{"Hello1"}, and \java{"Hello1" + 2} is \java{"Hello12"}.
The difference is when the conversion from integer to string actually takes place.

%Fortunately, this situation only happens when using the plus operator.
%You cannot, for example, store an integer directly in a string variable.
%
%\begin{code}
%     String number = 5;  // syntax error
%\end{code}

%In general, it's better not to compose multiple additions of varying data types.
%Instead you can break those statements into multiple lines, or use another method like \java{printf} to achieve the same results.


% TODO: add the following subsection before/after this section?
%\section{Type conversion}
%\index{type!conversion}
%\index{typecasting}

%You might wonder how you can get away with an expression like \java{
%"The log of x is " + result}, since one of the operands is a \java{String}
%and the other is a \java{double}.  In this case Java is being
%smart on our behalf, automatically converting the \java{double} to a
%\java{String} before it does the string concatenation.

%This kind of feature is an example of a common problem in designing a
%programming language, which is that there is a conflict between {\em
%formalism}, which is the requirement that formal languages should have
%simple rules with few exceptions, and {\em convenience}, which is the
%requirement that programming languages be easy to use in practice.

%More often than not, convenience wins, which is usually good for
%expert programmers (who are spared from rigorous but unwieldy
%formalism), but bad for beginning programmers, who are often baffled
%by the complexity of the rules and the number of exceptions.  In this
%book I have tried to simplify things by emphasizing the rules and
%omitting many of the exceptions.

%Whenever you try to ``add'' two
%expressions, if one of them is a \java{String}, Java converts the
%other to a \java{String} and then perform string concatenation.
%What do you think happens if you perform an operation between
%an integer and a floating-point value?


\section{Order of operations}

\index{order of operations}
\index{precedence}

When more than one operator appears in an expression, the order of evaluation depends on the rules of {\bf precedence}.
Generally speaking, Java executes individual operations from left to right (as was the case in the previous section).
But for numeric operators, Java follows mathematical conventions:

\begin{itemize}

\item Multiplication and division happen before addition and subtraction.
So \java{2 * 3 - 1} yields 5, not 4, and \java{2 / 3 - 1} yields -1, not 1.
Remember that because of integer division, \java{2 / 3} is 0.

\item If the operators have the same precedence, they are evaluated from left to right.
So in the expression \java{minute * 100 / 60}, the multiplication happens first, yielding \java{5900 / 60}, which in turn yields \java{98}.
If these same operations had gone from right to left, the result would have been \java{59 * 1}, which is incorrect.

\item Any time you want to override the rules of precedence (or you are not sure what they are) you can use parentheses.
Expressions in parentheses are evaluated first, so \java{2 * (3 - 1)} is 4.
You can also use parentheses to make an expression easier to read, as in \java{(minute * 100) / 60}, even though it doesn't change the actual result.

\end{itemize}

Don't work too hard to remember all the rules of precedence, especially for other operators.
If it's not obvious by looking at the expression, use parentheses to make it more clear.


\section{Composition}

\index{composition}

So far we have looked at the elements of a programming language---variables, expressions, and statements---in isolation, without talking about how to put them all together.

One of the most useful features of programming languages is their ability to take small building blocks and {\bf compose} them.
For example, we know how to multiply numbers and we know how to print.
It turns out we can combine these operations into a single statement:

\begin{code}
    System.out.println(17 * 3);
\end{code}

Any expression involving numbers, strings, and variables can be used inside a print statement.
We've already seen one example:

\begin{code}
    System.out.println(hour * 60 + minute);
\end{code}

You can also put arbitrary expressions on the right side of an assignment:

\begin{code}
    int percentage;
    percentage = (minute * 100) / 60;
\end{code}

The left side of an assignment must be a {\em variable name}, not an expression.
That's because the left side indicates where the result will be stored,
and expressions do not represent storage locations.

\begin{code}
    hour = minute + 1;  // correct
    minute + 1 = hour;  // syntax error
\end{code}

\index{readability}

The ability to compose operations may not seem that impressive now, but we will see examples later on that allow us to write complex computations neatly and concisely.

Before you get too carried away with composition, keep in mind that other people will be reading your source code.
In practice, software developers spend the vast majority of their time {\em understanding} and {\em modifying} existing code.
Thus it's far more important to write code that is readable than to write code that is (or appears to be) optimal.
%There is much beauty in simplicity.
In general, each line of code should be a single step of the algorithm.


\section{Formatting and style}

\index{whitespace}

Recall from Section~\ref{sec:formatting} that the compiler generally ignores {\bf whitespace}, i.e., newlines, tab characters, and other spaces.
Programmers have a lot of freedom in how they {\em format} their code in terms of indenting, blank lines, spaces around operators, etc.
However with that freedom comes responsibility, both to yourself (when you look at the code in the future) and to others who will be reading, understanding, and modifying your code.

\index{Google style}

Virtually every organization that does a lot of software development has strict guidelines on how to format source code.
For example, Google published its Java coding standards for use in open-source projects:
\url{http://google.github.io/styleguide/javaguide.html}
It is easier to understand a large codebase when all the source code is formatted consistently.
%Plus following style guidelines helps you to avoid common programming mistakes that are difficult to debug.

\index{Checkstyle}

Style rules can be difficult to learn, especially for beginners who haven't yet seen many of the language features discussed in them.
Fortunately there are many tools that help programmers find and correct formatting errors.
One prominent example is Checkstyle, which has the built-in ability to enforce most of Google's coding standards:
\url{http://checkstyle.sourceforge.net/}

Checkstyle is primarily a command-line tool.
Instructions for downloading and running Checkstyle are available on our website: \url{http://thinkjava.org/}

% TODO: When we have the website up, let's update this with a more specific URL

There are limits to what automatic style checkers can do.
In particular, they can't evaluate the {\em quality} of your comments, the {\em meaning} of your variable names, or the {\em structure} of your algorithms.
Good comments make it easier for experienced developers to identify errors in your code.
Good variable names communicate the intent of your program and how the data is organized.
And good programs are designed to be efficient and demonstrably correct.


\section{Vocabulary}

\begin{description}

\term{syntax error}
An error in a program that makes it impossible to parse (and therefore impossible to compile).

%\term{type-safe}
%A property of Java that makes it possible to catch some errors at compile time.

\term{runtime error}
An error in a program that makes it impossible to execute completely.
In Java, they are ``exceptions'' that terminate the program.

\term{logic error}
An error in a program that makes it do something other than what the programmer intended.

\term{variable}
A named storage location for values.
All variables have a type, which is declared when the variable is created.

\term{value}
A number or string that can be stored in a variable.
Every value belongs to a type (for example, \java{int} or \java{String}).

\term{declaration}
A statement that creates a new variable and specifies its type.

\term{type}
Mathematically speaking, a set of values.
The type of a variable determines which values it can have.

\term{keyword}
A reserved word used by the compiler to parse programs.
You cannot use keywords (like \java{public}, \java{class}, and \java{void}) as variable names.

\term{assignment}
A statement that stores a value in a memory location.

\term{operator}
A symbol that represents a computation like addition, multiplication, or string concatenation.

%\term{operand}
%One of the values on which an operator operates.

\term{expression}
A combination of variables, operators, and values that represents a single value.
Expressions also have types, as determined by their operators and operands.

\term{floating-point}
A data type that represents decimal numbers (numbers that have an integer part and a fractional part).
In Java, the default floating-point type is \java{double}.

\term{rounding error}
The small difference between a floating-point number and its actual representation on computer hardware.

\term{concatenate}
To join two values end-to-end.
For string values, concatenation means to append.

\term{precedence}
The order in which operations are evaluated.

\term{composition}
The ability to combine simple expressions and statements into compound expressions and statements, making it possible to represent complex computations in a concise manner.

\term{whitespace}
Newlines, tab characters, and other spaces in a source program.
Its purpose in the Java language is to separate tokens.

%\term{wildcard}
%A command-line feature that allows you to specify a pattern of file names.

\end{description}


\section{Exercises}

\begin{exercise}

If you are using this book in a class, you might enjoy this exercise.
Find a partner and play {\it Stump the Chump}:

Start with a program that compiles and runs correctly.
One player turns away while the other player adds an error to the program.
Then the first player tries to find and fix the error.
You get two points if you find the error without compiling the program, one point if you find it using the compiler, and your opponent gets a point if you don't find it.

\end{exercise}

\begin{exercise}
\label{ex:date}

The point of this exercise is (1) to use string concatenation to display values with different types (\java{int} and \java{String}), and (2) to practice developing programs gradually by adding a few statements at a time.

\begin{enumerate}

\item Create a new program named {\tt Date.java}.
Copy or type in something like the ``Hello, World!'' program and make sure you can compile and run it.

\item Following the example in Section~\ref{sec:printvar}, write a program that creates variables named \java{day}, \java{date}, \java{month}, and \java{year}.
\java{day} will contain the day of the week and \java{date} will contain the day of the month.
What type is each variable?
Assign values to those variables that represent today's date.

\item Print the value of each variable on a line by itself.
This is an intermediate step that is useful for checking that everything is working so far.

\item Modify the program so that it prints the date in standard American format, for example: {\tt Thursday, July 16, 2015}.

\item Modify the program again so that the total output is:

\begin{stdout}
American format:
Thursday, July 16, 2015
European format:
Thursday 16 July, 2015
\end{stdout}

\end{enumerate}

HINT: You should be able to copy, paste, and modify the code from Step 4 when completing Step 5.

\end{exercise}

\begin{exercise}

The point of this exercise is (1) to use some of the arithmetic operators, and (2) to start thinking about compound entities (like time of day) that that are represented with multiple values.

\begin{enumerate}

\item Create a new program called {\tt Time.java}.
From now on, we won't remind you to start with a small, working program, but you should.

\item Following the example program in Section~\ref{sec:printvar}, create variables named \java{hour}, \java{minute}, and \java{second}.
Assign values that are roughly the current time.
Use a 24-hour clock, i.e., so that at 2pm the value of \java{hour} is 14.

\item Make the program calculate and print the number of seconds since the most recent midnight.

\item Make the program calculate and print the number of seconds remaining in the day.

\item Make the program calculate and print the percentage of the day that has passed.
You might run into problems when computing percentages with integers, so consider using floating-point.

\item Change the values of \java{hour}, \java{minute}, and \java{second} to reflect the current time.
Check that the program works correctly each time you run it.

\end{enumerate}

HINT: You may want to use additional variables to hold values during the computation.
Variables that are used in a computation but never printed are sometimes called intermediate or temporary variables.

\end{exercise}


\chapter{Input and output}

%A number of years ago, Jeannette Wing published a terrific editorial with the title {\it Computational Thinking}, or in her own words, ``Ways to Think Like a Computer Scientist'' (see Communications of the ACM, March 2006).
%This 3-page article summarizes many of the problem-solving techniques you will discover while learning to program.
%Everyone interested in learning computer science beyond programming should read it.
%She defines the field this way:

%\index{computer science}

%\begin{quote}
%{\bf ``Computer science is the study of computation---what can be computed and how to compute it.''}
%\end{quote}

The programs we've looked at so far just display messages, which doesn't involve a lot of real computation.
This chapter will show you how to read input from the keyboard, use that input to calculate a result, and then format that result for output.
%We will also look at some technical details about how operating systems work.


\section{The System class}
\label{sec:system}

\index{System class}
\index{class!System}

\java{System.out.println} can display the value of any type of variable.
You can even use \java{println} to print the value of \java{System.out}:

\begin{code}
    System.out.println(System.out);
\end{code}

The result is:

\begin{stdout}
java.io.PrintStream@685d72cd
\end{stdout}

\index{package}

From this output we can see that \java{System.out} is a \java{PrintStream}, which is defined in a package called \java{java.io}.
A {\bf package} is a collection of related classes; \java{java.io} contains classes for ``I/O'' which stands for input and output.

\index{address}

After the {\tt @} sign is the location of the object in memory, which is called its {\bf address}.
In this example the address is \java{685d72cd}, but if you run the same code you will likely get something different.
%You can think of the address as a unique identifier for the object.

\index{object}

\java{System.out} is an {\bf object}, which means that it is a special value that provides methods.
Specifically, \java{System.out} provides methods for displaying output, including \java{print} and \java{println}.
Numbers with type \java{int} and \java{double} are not objects because they provide no methods.
Strings are objects; we will see some of their methods soon.

\index{library}

The \java{System} class is defined in a file called {\tt System.java}, and {\tt PrintStream} is defined in {\tt PrintStream.java}.
These files are part of the Java {\bf library}, which is an extensive collection of classes you can use in your programs.

\begin{figure}[!h]
\begin{center}
\includegraphics{figs/system.pdf}
\caption{\java{System.out.println} refers to the \java{out} variable of the \java{System} class, which is a \java{PrintStream} that provides a method called \java{println}.}
\end{center}
\end{figure}

%Both \java{System} and \java{PrintStream} are written in Java, and later in the book we'll examine their source code.
%For now, you should understand that \java{System.out} is a \java{PrintStream} object.
%Because Java is an {\em object-oriented} language, much of the library is organized around objects that perform specific actions.

% ABD: there is so much new vocab in these sections, I want to reduce the number of new ideas

%\index{operating system}

%As with most software, Java programs run on top of an {\bf operating system} that manages the keyboard, the display, main memory, disk drives, printers, the network, and other hardware resources.
%Common examples of operating systems include Android, iOS, Linux, Mac OS~X, and Windows.
%When starting Java programs, the operating system directs \java{System.out} to the screen.

%\index{abstraction}

%Note the exact type of display doesn't matter, whether it's a 5-inch touch screen or 30-inch monitor.
%From the programmer's point of view, \java{System.out} simply provides the means for printing messages.
%Computer scientists often use {\bf abstraction} to deal with the complexity of software.
%The \java{System} class is a platform-independent abstraction of the operating system.
%The operating system itself is a layer of abstraction on top of computer hardware.


\section{The Scanner class}

\index{Scanner class}
\index{class!Scanner}

%\index{byte}
%
%From the operating system's point of view, data from the keyboard arrives in a series of hardware control signals.
%The operating system translates these signals into a stream of {\bf bytes} (small integers), which in turn need to be translated into characters.
%\java{System.in} provides the means for reading one byte of input at a time, which is hardly useful for programs that would rather read in an entire word or line of input.

The \java{System} class also provides an object named \java{in}, which is an \java{InputStream} that provides methods for reading input from the keyboard.
%As with \java{System.out}, the exact type of keyboard (or even touch screen) does not matter to the programmer.
These methods perform simple operations, but they are not easy to use.
Fortunately, Java provides other classes that make it easier to handle common input tasks.

\index{class!utility}
\index{utility class}

For example, \java{Scanner} is a class that provides methods for inputting words, numbers, and other data.
\java{Scanner} is provided by \java{java.util}, which is a package that contains classes so useful they are called {\bf utility classes}.
Before you can use \java{Scanner}, you have to import it at the top of your source file:

\begin{code}
import java.util.Scanner;
\end{code}

\index{import}
\index{statement!import}

This {\bf import statement} tells the compiler that when you say \java{Scanner}, you mean the one defined in \java{java.util}.
It's necessary because there might be another class named \java{Scanner} in another package.
Using an import statement makes your code unambiguous.

Next you have to create a \java{Scanner} object using the keyword \java{new}.
%In most programs, you will need only one \java{Scanner}, since there is only one source of input.
The following code declares a \java{Scanner} variable and then creates a \java{Scanner} object:

\begin{code}
    Scanner in;
    in = new Scanner(System.in);
\end{code}

\index{argument}

Although \java{Scanner} is not a method, the syntax is the same as a method call.
We pass \java{System.in} as an argument, which specifies that we are planning to input values from the keyboard.
Alternatively, you can declare the variable and assign it using one line of code.
%This latter syntax is more convenient, since it's a one-time setup for many programs.
%Just make sure you understand that it's two statements in one.

\begin{code}
    Scanner in = new Scanner(System.in);
\end{code}

The new \java{Scanner} object (stored in the variable \java{in}) provides a method called \java{nextLine} that reads a line of input from the keyboard and returns a String.
The following example reads two lines and repeats them back to the user.

\begin{code}
import java.util.Scanner;

public class Echo {
    public static void main(String[] args) {
        String line;
        Scanner in = new Scanner(System.in);

        System.out.print("Type something:");
        line = in.nextLine();
        System.out.println("You said: " + line);

        System.out.print("Type something else:");
        line = in.nextLine();
        System.out.println("You also said: " + line);
    }
}
\end{code}

If you omit the import statement and later refer to \java{Scanner}, you will get a compiler error like ``cannot find symbol.''
That means the compiler doesn't know what you mean by \java{Scanner}.

You might wonder why we can use the \java{System} class without importing it.
\java{System} belongs to the \java{java.lang} package, which is imported automatically.
According to the documentation, \java{java.lang} ``provides classes that are fundamental to the design of the Java programming language.''
The \java{String} class is also part of the \java{java.lang} package.

\subsection{Structure of Java programs}
\label{sec:library}

At this point, we have seen all of the elements that make up Java programs.
The following figure shows these organizational units.

\begin{figure}[!h]
\begin{center}
\includegraphics[width=4in]{figs/package.pdf}
\caption{Elements of the Java language, from largest to smallest.}
\end{center}
\end{figure}

To review, a package is a collection of classes, which define methods.
Methods contain statements, some of which contain expressions.
Expressions are made up of tokens, which include variable names, numbers, operators, keywords, and punctuation like braces and semicolons.

The standard edition of Java comes with {\em several thousand} classes you can \java{import}, which can be both exciting and intimidating.
You can browse this library on Oracle's website: \url{http://docs.oracle.com/javase/7/docs/api/}
Note there is a major difference between the Java {\em language}, which deals with syntax and grammar, and the Java {\em library}, which provides the built-in classes.
In fact, most of the Java library itself is written in Java.

%To help keep things organized, classes are grouped into {\bf packages}.
%Just as each \java{class} is a separate file, each \java{package} is a separate folder.

%In order to use a class defined in another package (and in another folder), you have to {\bf import} it first.

%\begin{code}
%import java.io.File;
%import java.io.PrintStream;
%import java.util.Date;
%import java.util.Scanner;
%\end{code}

%All \java{import} statements appear at the top of the source file, above the class definition.
%It's not uncommon for Java programs to have many import statements.


\section{Inches to centimeters}

Now let's see an example that's a little more useful.
Although most of the world has adopted the metric system for weights and measures, some countries are stuck with English units.
For example, when talking with friends in Europe about the weather, people in the United States may have to convert from Celsius to Fahrenheit and back.
%And when making an international purchase online, you may have to convert your nation's currency into another based on the exchange rate.
Or you might want to convert your height in inches to centimeters.

%An everyday problem that computers are great at solving is converting numbers from one unit into another.
%For the rest of the chapter, we will look at how to write programs that solve these types of problems.
%Specifically, each program will 1) prompt the user for input, 2) read input from the keyboard, 3) calculate a result, and 4) format the result for output.
%The focus will not only be on Java syntax and language features, but also on the {\em process} of solving the problem, documenting the code, and testing the solution.

We can write a program to help.
We can use a \java{Scanner} to input a measurement in inches, convert to centimeters, and then print the results.
These lines declare the variables and create the \java{Scanner}:

% ABD: I am inclined not to include comments in most of the code
% examples because (1) I think it makes the code less cluttered and
% easier to read, and (2) they are often redundant with the text.

% I understand that it would be good to demonstrate good commenting
% style.  Despite this benefit, I think it's better to leave
% them out.  But I don't feel strongly about it.

\begin{code}
    int inch;  // the input
    double cm;  // the output
    Scanner in = new Scanner(System.in);
\end{code}

The first step is to prompt the user for the input.
We'll use \java{print} instead of \java{println} so they can enter the input on the same line.

\begin{code}
    System.out.print("How many inches? ");
    inch = in.nextInt();
\end{code}

Next we multiply the number of inches by 2.54, since that's how many centimeters there are per inch.
Finally we display the results on one line, but use two print statements since it's easier to read.

\begin{code}
    cm = inch * 2.54;
    System.out.print(inch + " in = ");
    System.out.println(cm + " cm");
\end{code}

\index{magic number}

This code works, but it has a problem.
If another programmer reads this code, they might wonder where 2.54 comes from.
Numbers that appear in an expression with no explanation are called {\bf magic numbers}.
For the benefit of other programmers (and yourself in the future), it is helpful to assign magic numbers to variables with informative names:

\begin{code}
    final double cmPerInch = 2.54;
    cm = inch * cmPerInch;
    System.out.print(inch + " in = ");
    System.out.println(cm + " cm");
\end{code}

\subsection{Literals and constants}

\index{literal}

Parts of the output we have been printing (\java{" in = "}, \java{" cm"}, etc.) are {\em literal} string values.
{\bf Literals} are data embedded directly into programs.
In contrast, variables (\java{inch}, \java{cm}, etc.) are the names of values stored in memory.
The English word {\em variable} implies that this data is subject to change.

As we saw with \java{cmPerInch}, it's often useful to give names to literals that will be used throughout the program.
But when doing so, we don't want those variables to be changed accidentally because of an unexpected bug in the code.
As another example, consider the famous card game that comes with most versions of Microsoft Windows.

\begin{code}
    final String title = "Solitaire";
    final int deckSize = 52;
\end{code}

\index{final}
\index{constant}
\index{initialize}

The keyword \java{final} indicates these variables are {\bf constants} and therefore may be assigned only one time.
Constants are generally declared and {\bf initialized} on the same line of code.
%The term initialize means to assign for the first time.
If you attempt to assign \java{title} or \java{deckSize} later in the program, the compiler will report an error.
This feature helps prevent you from making mistakes.

It's good practice to create final variables for constant values, rather than repeat literal values again and again.
For one, it makes the program easier to understand.
When looking at the code, it may not be obvious what the number \java{52} means.
The name \java{deckSize} explains the programmer's intent.
Second, named constants make the program easier to maintain.
If we want to change the title from \java{"Solitaire"} to \java{"Klondike"}, we would only need to change one line of code (as opposed to every line where that title is used).


\section{Formatting output}

When printing floating-point numbers, Java automatically decides how many decimal places to display.

% ABD: What do you think of using the DrJava interpreter format to show the result of simple examples, as in the following?

\begin{code}
    System.out.print(7.0 / 3.0);
    // prints 2.3333333333333335   note: 5 is a rounding error
\end{code}

\index{printf}
\index{argument}

\java{System.out} provides another method called \java{printf}, where the ``f'' stands for ``formatted''.
The first argument of \java{printf} is a {\em format string} that specifies how values should be displayed.
%It contains a template for the text you want to output, as well as positions where it will substitute other values.
The other arguments are the values themselves.

\begin{code}
    System.out.printf("Seven thirds = %.3f", 7.0 / 3.0);
    // prints Seven thirds = 2.333
\end{code}

\index{format specifier}

This format string contains ordinary text followed by a {\bf format specifier}, which is a special sequence that starts with a percent sign.
The format specifier \verb"%.3f" indicates that the value should be displayed as floating-point with three decimal places.
Here's an example that contains two format specifiers:

\begin{code}
   inch = 100;
   cm = inch * cmPerInch;
   System.out.printf("%d in = %f cm\n", inch, cm);
   // prints 100 in = 254.000000 cm
\end{code}

The values are matched up with the format specifiers in order, so \java{inch} is displayed as an integer (``d'' stands for ``decimal'') and \java{cm} is displayed as a floating-point number.
Format strings often end with a newline character (\verb"\n"), since \java{printf} does not append a newline like \java{println} does.

Learning \java{printf} is like learning a sub-language within Java.
There are many options, and the details can be overwhelming.
But here are some common uses, to give you an idea of how it works:

\begin{table}[!h]
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
\verb"%d" & decimal integer & 12345 \\
\hline
\verb"%,d" & decimal integer with comma separators & 12,345 \\
\hline
\verb"%08d" & padded with zeros, at least 8 digits wide & 00012345 \\
\hline
\verb"%f" & floating-point & 6.789000 \\
\hline
\verb"%.2f" & floating-point {\em rounded} to 2 decimal places & 6.79 \\
\hline
\end{tabular}
\caption{Example format specifiers}
\end{center}
\end{table}

For more details, refer to the documentation of \java{java.util.Formatter}
or search the web for ``java formatting.''


\section{Centimeters to inches}
\label{sec:rounding}

Now suppose we have a measurement in centimeters and we want to round it off to the nearest inch.
It is tempting to write:

\begin{code}
    inch = cm / centPerInch;  // syntax error
\end{code}

But the result is an error---you get something like, ``Bad types in assignment: from double to int.''
The problem is that the value on the right is floating-point and the variable on the left is an integer.

%Java converts an \java{int} to a \java{double} automatically, since no information is lost in the process.
%On the other hand, going from \java{double} to \java{int} gets rid of the decimal places.
%Java doesn't perform this operation automatically in order to ensure that you are aware of the loss of the fractional part of the number.

\index{type cast}
\index{operator!cast}

The simplest way to convert a floating-point value to an integer is to use a {\bf type cast}, so called because it molds or ``casts'' a value from one shape to another.
The syntax for type casting is to put the name of the type in parentheses and use it as an operator.

\begin{code}
    double pi = 3.14159;
    int x = (int) pi;
\end{code}

%\index{truncate}

The \java{(int)} operator has the effect of converting what follows into an integer.
In this example, \java{x} gets the value \java{3}.
Converting to an integer always rounds {\em toward zero}, even if the fraction part is \java{0.999999} (or \java{-0.999999}).

Type casting takes precedence over arithmetic operations.
In this example, the value of \java{pi} gets converted to an integer first.
So the result is 60.0, not 62.

\begin{code}
    double pi = 3.14159;
    double x = (int) pi * 20.0;
\end{code}

%Operator precedence and integer truncation make type casting somewhat error-prone.

Keeping that in mind, here's how we can convert a measurement in centimeters to inches.

\begin{code}
    inch = (int) (cm / centPerInch);
    System.out.printf("%f cm = %d in\n", cent, inch);
\end{code}

The parentheses after the cast operator require the division to come before the type cast.
This result will be rounded toward zero, but we will learn in the next chapter how to round floating-point numbers to the closest integer.

\subsection{Modulus operator}

Let's take the example one step further: suppose you have a measurement in inches and you want to convert to feet and inches.
The goal is divide by 12 (the number of inches in a foot) and keep the remainder.

\index{modulus}
\index{operator!modulus}

We have already seen the division operator ({\tt /}), which computes the quotient of two numbers.
If the numbers are integers, it performs integer division.
Java also provides the {\bf modulus} operator ({\tt \%}), which divides two numbers and computes the remainder.

Assuming the following variables are integers, we can convert 76 inches to feet and inches like this:

\begin{code}
    quotient = 76 / 12;   // division
    remainder = 76 % 12;  // modulus
\end{code}

The first line yields 6.
The second line, which is pronounced ``76 mod 12,'' yields 4.
So 76 inches is 6 feet, 4 inches.

Although the modulus operator is a percent sign, you might find it helpful to think of it as a division sign ($\div$) rotated to the left.
Note that both {\tt /} and {\tt \%} perform {\em integer division}.
The reason why integer division ``rounds down'' is that the hardware computes the quotient and remainder separately.
%Many algorithms, including the example above, perform division and modulus together.

\index{divisible}
\index{extract digits}

Integer division turns out to be surprisingly useful.
For example, you can check whether one number is divisible by another: if \java{x \% y} is zero, then \java{x} is divisible by \java{y}.
You can also use modulus to ``extract'' digits from a number: \java{x \% 10} yields the rightmost digit of \java{x}, and \java{x \% 100} yields the last two digits.
Also, many encryption algorithms are based on modular arithmetic.


\section{Putting it all together}

%\begin{itemize}

%% Chapter 1
%\item Write a class and main
%\item Display simple output
%\item Compile and run programs
%\item Correct syntax errors

%% Chapter 2
%\item Declare/assign variables
%\item Create named constants
%\item Perform basic arithmetic
%\item Compose multiple operations

%% Chapter 3
%\item Browse the Java library
%\item Import Java library classes
%\item Initialize a Scanner object
%\item Get input from the keyboard
%\item Read/write documentation
%\item Format output with printf
%\item Divide and mod integers

%\end{itemize}

At this point you know enough Java to write useful programs that solve everyday problems.
You've seen how to 1) import Java library classes, 2) initialize a \java{Scanner} object, 3) get input from the keyboard, 4) format output with \java{printf}, and 5) divide and mod integers.
Now we can put them together in a complete program:

%Since we've looked at each of these topics in isolation, it's important to see how they fit together in a complete program.
%If you've been working through the examples on your computer as you've been reading (like we recommended in Section~\ref{sec:examples}), then good job!

\begin{code}
import java.util.Scanner;

/**
 * Converts centimeters to feet and inches.
 */
public class Convert {
    public static void main(String[] args) {
        double cm;
        int feet, inches;
        final double centPerInch = 2.54;
        Scanner in = new Scanner(System.in);

        // prompt the user and get the value
        System.out.print("Exactly how many cm? ");
        cm = in.nextDouble();

        // convert and output the result
        inches = (int) (cm / centPerInch);
        feet = inches / 12;
        inches = inches % 12;
        System.out.printf("%.2f cm = %d ft, %d in\n",
                          cm, feet, inches);
    }
}
\end{code}

\begin{itemize}

\item Although not required, all variables and constants are declared at the top of \java{main}.
This practice makes it easier to find their types later on and helps the reader know what data is involved in the algorithm.

\item For readability, each major step of the algorithm is separated by a blank line and begins with a comment.

\item Integer division and modulus often go together.
Notice how \java{inches} gets reassigned (which replaces its value) just before the \java{printf}.

\item When statements get long (generally wider than 80 characters), a common style convention is to break them across multiple lines.
The reader should never have to scroll horizontally.

\end{itemize}

%As an exercise, try running this code through Checkstyle.


\section{The Scanner bug}

Now that you've had some experience with \java{Scanner}, there is an unexpected behavior we want to warn you about.
Consider a simple program that asks users for their name and age.
Somewhere in the middle of the code, we have the following lines:

\begin{code}
    System.out.print("What is your name? ");
    name = in.nextLine();
    System.out.print("What is your age? ");
    age = in.nextInt();
    System.out.printf("Hello %s, age %d\n", name, age);
\end{code}

The output of the \java{printf} statement looks something like this:

\begin{stdout}
Hello Darth Vader, age 45
\end{stdout}

When you read a \java{String} followed by an \java{int}, everything works just fine.
But when you read an \java{int} followed by a \java{String}, something strange happens.

\begin{code}
    System.out.print("What is your age? ");
    age = in.nextInt();
    System.out.print("What is your name? ");
    name = in.nextLine();
    System.out.printf("Hello %s, age %d\n", name, age);
\end{code}

Try running the above example.
It doesn't let you input your name and immediately displays the output:

\begin{stdout}
What is your name? Hello , age 45
\end{stdout}

To understand what is happening, recall that computers do not {\em see} input as multiple lines like we do.
Instead, the operating system simply forwards a stream of characters to your program via \java{System.in}:

\begin{center}
\includegraphics{figs/vader1.pdf}
\end{center}

The up-arrow represents the next character to be read by \java{Scanner}.
When you call \java{nextInt}, it will read characters until a non-digit is found.

\begin{center}
\includegraphics{figs/vader2.pdf}
\end{center}

At this point, \java{nextInt} returns the \java{int} value \java{45}.
The program then asks \java{"What is your name? "} and calls \java{nextLine}.
\java{Scanner} will read characters until a newline is found.
Since the next character to be read already is a newline, \java{nextLine} returns the empty string \java{""}.

To solve this problem, you need to add an extra call to \java{nextLine} after you call \java{nextInt}.

\begin{code}
    System.out.print("What is your age? ");
    age = in.nextInt();
    in.nextLine();  // read the newline
    System.out.print("What is your name? ");
    name = in.nextLine();
    System.out.printf("Hello %s, age %d\n", name, age);
\end{code}

This technique is common when reading \java{int} or \java{double} values that appear on their own line.
First you read the number, then you read the rest of the line (which is just a newline character).
Note that you do not have to assign the return value of \java{nextLine} to a variable in that case; you can simply ignore it.


\section{Command-line testing}

You should review the advice in Section~\ref{sec:examples}, now that you've written some more substantial programs.
Remember, it's more effective to program and debug your code little by little than to attempt writing everything at once.
And once you've completed programming an algorithm, it's important to test that it works correctly on a variety of inputs.

Throughout the book, we will illustrate techniques for testing your programs.
Most if not all testing is based on a simple idea: does the program do what we expect it to do?
For simple programs, it's not difficult to run them several times and see what happens.
But at some point, you will get tired of typing the same test cases over and over.

We can automate the process of entering input and comparing {\em expected output} with {\em actual output} using the command-line.
The basic idea is to store the test cases in plain text files and trick Java into thinking they are coming from the keyboard.
Here are step by step instructions.

\begin{enumerate}

\item Make sure you can compile and run the {\tt Convert.java} example in the previous section.
%You can also download a copy from \url{http://thinkjava.org/}.

\item In the same directory as {\tt Convert.java}, create a plain text file named {\tt test.in} (``in'' is for input).
Enter the following line and save the file.

\begin{stdout}
193.04
\end{stdout}

\item Create a second plain text file named {\tt test.exp} (``exp'' is for expected).
Enter the following line and save the file.

\begin{stdout}
193.04 cm = 6 ft, 4 in
\end{stdout}

\item Open a command-line, and change to the directory with these files.
Run the following command to test the program.

\begin{stdout}
java Convert < test.in > test.out
\end{stdout}

\end{enumerate}

\index{redirection operator}

On the command-line, {\tt <} and {\tt >} are {\bf redirection operators}.
The first one redirects the contents of {\tt test.in} to \java{System.in}, as if it were entered from the keyboard.
The second one redirects the contents of \java{System.out} to a new file {\tt test.out}, much like a screen capture.
In other words, the {\tt test.out} file contains the output of your program.

% ABD: Since I killed the previous reference to abstraction, I am inclined
% to kill this one too.  The problem in both places is that it pulls the
% focus off topic.

%Redirecting a program's input and output is an example of how computer scientists use abstraction.
%Notice that \java{System.in} is not called \java{Keyboard}, and \java{System.out} is not called \java{Display}.
%In practice, these objects could be text files, network connections, microphones and speakers, or some other byte streams.
%What's great is that doesn't change anything about how you write the code.

By the way, it's perfectly okay to compile your programs in DrJava (or some other environment) and run them from the command-line.
Knowing both techniques allows you to use the right tool for the job.

At this point, we just need to compare the contents {\tt test.out} with {\tt test.exp}.
If the files are the same, then the program outputted what we expected it to output.
If not, then we found a bug, and we can use the output to begin debugging our program.
Fortunately, there's a simple way to compare files on the command-line:

\begin{stdout}
diff test.exp test.out
\end{stdout}

The {\tt diff} utility summarizes the differences between two files.
If there are no differences, then it prints nothing, which in our case is what we want.
If the expected output differs from the actual output, then we need to continue debugging.
Usually the program is at fault, and {\tt diff} provides some insight about what is broken.
But there's also a chance that we have a correct program and the expected output is wrong.

Interpreting the results from {\tt diff} can be confusing, but fortunately there are many graphical tools that show the differences between two files. For example, on Windows you can install WinMerge, on Mac you can use {\tt opendiff} (which comes with Xcode), and on Linux there's {\tt meld}. Regardless what tool you use, the goal is the same. Debug your program until the actual output is {\it identical} to the expected output.

\begin{figure}[!h]
\begin{center}
\includegraphics[width=0.9\textwidth]{figs/meld.png}
\caption{Using {\tt meld} to compare the expected output with the actual output.}
\end{center}
\end{figure}


\section{Vocabulary}

\begin{description}

\term{package}
A group of classes that are related to each other.
Java classes are organized into packages.

\term{address}
The storage location of a variable or object in memory.
Addresses are integers encoded in hexadecimal (base 16).

\term{object}
An abstract entity that represents data and performs actions.
In Java, objects are stored in memory and referenced by variables.

\term{library}
A collection of packages and classes that are available for use in other programs.
Libraries are often distributed in {\tt .jar} (Java Archive) files.

%\term{operating system}
%Software that is always running behind the scenes on your computer.
%It controls the execution of application programs and manages hardware resources.

%\term{abstraction}
%The process of reducing information and/or detail to focus on high-level concepts.

%\term{byte}
%A single unit of data on a computer; enough to represent one character.

\term{utility class}
A class that provides commonly needed functionality.

\term{import}
A statement that allows programs to use classes defined in other packages.

\term{magic number}
A unique value with unexplained meaning or multiple occurrences.
They should generally be replaced with named constants.

\term{literal}
A constant value written directly in the source code.
For example, \java{"Hello"} is a string literal and \java{74} is an integer literal.

\term{constant}
A variable that can only be assigned one time.
Once initialized, its value cannot be changed.

\term{initialize}
To assign an initial value to a variable.

\term{format specifier}
A special code beginning with percent sign and ending with a single letter that stands for the data type.

\term{type cast}
An operation that explicitly converts one data type into another, sometimes with loss of information.
In Java it appears as a type name in parentheses, like \java{(int)}.

%\term{truncate}
%To make shorter by cutting something off.
%Casting a floating-point value to an integer simply removes the fractional part.

\term{modulus}
An operator that yields the remainder when one integer is divided by another.
In Java, it is denoted with a percent sign (e.g., \java{5 \% 2} is \java{1}).

\term{redirection operator}
A command-line feature that substitutes \java{System.in} and/or \java{System.out} with a plain text file.

\end{description}


\section{Exercises}

\begin{exercise}
When you use \java{printf}, the Java compiler does not check your formatting string.
See what happens if you try to display value with type \java{int} using \verb"%f".
And what happens if you display a \java{float} using \verb"%d"?
What if you use two format specifiers, but then only provide one value?
\end{exercise}


\begin{exercise}

TODO

\end{exercise}


\begin{exercise}

TODO

\end{exercise}


\chapter{Void methods}

So far we've only written short programs that have a single class with a \java{main} method.
In this chapter, we'll show you how to organize longer programs into multiple methods and classes.
%We will also take a look at separate compilation.

\index{method}

% ABD: In theory I like the idea of providing a chapter overview, but
% in practice I find them impossible to write without breaking the rules
% (like using terms before defining them, etc)

At a conceptual level, a {\bf method} represents a mathematical {\em function} or a general {\em procedure}.
Some methods perform a computation and return a result.
For example, \java{Math.sqrt(25)} returns the value \java{5.0}.
Other methods (including \java{main}) carry out a sequence of actions without returning a result.
Java uses the keyword \java{void} to declare such methods.
Regardless whether they return a value or not, methods enable you to break down a complex program into smaller blocks of code.


\section{Math methods}

\index{Math class}
\index{class!Math}
\index{expression}
\index{argument}

In mathematics, you have probably seen functions like $\sin$ and $\log$, and you have learned to evaluate expressions like $\sin(\pi/2)$ and $\log(1/x)$.
First, you evaluate the expression in parentheses, which is called the {\bf argument} of the function.
Then you can evaluate the function itself, maybe by punching it into a calculator.

This process can be applied repeatedly to evaluate more complex expressions like $\log(1/\sin(\pi/2))$.
First we evaluate the argument of the innermost function, then evaluate the function itself, and so on.

\index{invoke}

The Java library includes a \java{Math} class that provides most common mathematical operations.
%These functions are called {\bf methods}.
\java{Math} is in the \java{java.lang} package, so you don't have to import it.
You can {\bf invoke} Math methods like this:

\begin{code}
    double root = Math.sqrt(17.0);
    double angle = 1.5;
    double height = Math.sin(angle);
\end{code}

The first line sets \java{root} to the square root of 17.
The third line finds the sine of the value of \java{angle}.

\index{degrees}
\index{radians}

Arguments of the trigonometric functions---\java{sin}, \java{cos}, and \java{tan}---should be in {\em radians}.
To convert from degrees to radians, you can divide by 180 and multiply by $\pi$.
Conveniently, the \java{Math} class provides a \java{final double} named \java{PI} that contains an approximation of $\pi$:

\begin{code}
    double degrees = 90;
    double angle = degrees / 180.0 * Math.PI;
\end{code}

Notice that \java{PI} is in capital letters.
Java does not recognize \java{Pi}, \java{pi}, or \java{pie}.
Also, \java{PI} is the name of a variable, not a method, so it doesn't have parentheses.
The same is true for the constant \java{Math.E}, which approximates Euler's number.

It turns out that converting to/from radians is a common operation, so the \java{Math} class provides methods for that.

\begin{code}
    double radians = Math.toRadians(180.0);
    double degrees = Math.toDegrees(Math.PI);
\end{code}

\index{type!long}

If you haven't already, take a look at the documentation for \java{Math} so you know what methods are provided.
For example, another useful method is \java{round}, which rounds a floating-point value to the nearest integer and returns a \java{long}.

\begin{code}
    long x = Math.round(Math.PI * 20.0);
\end{code}

In Java, \java{int} values are stored using 32 bits (4 bytes) of memory, whereas \java{long} values are stored in 64 bits (8 bytes).
As a result, \java{long} variables can represent much larger integers.
In the above example, the multiplication happens first, before the method is invoked.
The result is 63 (rounded up from 62.8319).

\subsection{Composition revisited}

\index{composition}
\index{expression}

Just as with mathematical functions, Java methods can be {\bf composed}.
That means you can use one expression as part of another.
For example, you can use any expression as an argument to a method:

\begin{code}
    double x = Math.cos(angle + Math.PI / 2);
\end{code}

This statement takes the value \java{Math.PI}, divides it by two, and then adds the result to the value of the variable \java{angle}.
The sum is then passed as an argument to \java{cos}.
You can also take the result of one method and pass it as an argument to another:

\begin{code}
    double x = Math.exp(Math.log(10.0));
\end{code}

In Java, the \java{log} method always uses base $e$.
So this statement finds the log base $e$ of 10, and then raises $e$ to that power.
The result gets assigned to \java{x}.
%Do you know what it is without reaching for a calculator?

When using \java{Math} methods, it is a common error to forget to specify the class name \java{Math}.
For example, \java{Math.pow} takes two arguments and raises the first argument to the power of the second.

\begin{code}
    pow(2.0, 10.0);  // syntax error
\end{code}

If you try to invoke \java{Math.pow} this way, the compiler will say it ``cannot find symbol'' (i.e., there is no method named \java{pow} in the current class).


\section{Adding new methods}
\label{adding_methods}

\index{method!definition}
\index{main}
\index{method!main}

Like the \java{Math} class, you can write your own set of methods for use in other programs.
%One of the most powerful features of a programming language is the ability to add new methods.
Let's revisit the method definition for \java{main}:

\begin{code}
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
\end{code}

\index{public}
\index{void}
\index{type!void}

The first line contains information about the method:
\java{main} is a \java{public} method, which means it can be invoked from other classes;
it is a \java{static} method, but we're not going to explain what that means yet;
and it is a \java{void} method, which means that it doesn't yield a result (unlike the \java{Math} methods).

\index{parameter}

The statement in parentheses declares a parameter named
\java{args}.  A {\bf parameter} is a variable that stores an argument.
This parameter has type \java{String[]}, which means that whoever invokes \java{main} must provide an array of Strings (we'll get to arrays in a later chapter).

You can define other methods using syntax that is similar to \java{main}:

\begin{code}
    public static void NAME(PARAMETERS) {
        STATEMENTS
    }
\end{code}

By convention, methods start with a lower case letter and use ``camel case,'' which is a cute name for \java{jammingWordsTogetherLikeThis}.
You can use any name you want for your method, except \java{main} or any of the Java keywords.

% TODO: move the definition of ``argument'' to Ch3?

The list of parameters specifies what values, if any, you have to provide in order to invoke the new method.
The first methods we are going to write have no parameters, so the parameter list is empty.  Here's an example:

\begin{code}
    public static void newLine() {
        System.out.println();
    }
\end{code}

The name of this method is \java{newLine}.
It contains only one statement, which prints a blank line.
In \java{main}, we can invoke the new method like this:

\begin{code}
    public static void main(String[] args) {
        System.out.println("First line.");
        newLine();
        System.out.println("Second line.");
    }
\end{code}

Because \java{newLine} is in the same class as \java{main}, we don't have to specify the class name.
The output of this program is:

\begin{stdout}
First line.

Second line.
\end{stdout}

Notice the extra space between the lines.
If we wanted more space between them, we could invoke the same method repeatedly:

\begin{code}
    public static void main(String[] args) {
        System.out.println("First line.");
        newLine();
        newLine();
        newLine();
        System.out.println("Second line.");
    }
\end{code}

Or we could write a new method that prints three blank lines:

\begin{code}
    public static void threeLine() {
        newLine();
        newLine();
        newLine();
    }

    public static void main(String[] args) {
        System.out.println("First line.");
        threeLine();
        System.out.println("Second line.");
    }
\end{code}

You can invoke the same method more than once, and you can have one method invoke another.
In this example, \java{main} invokes \java{threeLine}, and \java{threeLine} invokes \java{newLine}.

%In \java{threeLine} I wrote three statements all on the same line, which is syntactically legal (remember that spaces and new lines usually don't change the meaning of a program).
%It is usually a good idea to put each statement on its own line, but I sometimes break that rule.

You might wonder why it is worth the trouble to create new methods.
There are many reasons, but this example demonstrates a few of them:

\begin{enumerate}

\item Creating a new method gives you an opportunity to give a name to a group of statements, which makes code easier to read and understand.
%Methods simplify a program by hiding complex computations behind a single statement, and by using English words in place of arcane code.
%Which is clearer, \java{newLine} or \java{System.out.println()}?

\item Introducing new methods can make a program smaller by eliminating repetitive code.
For example, to print nine consecutive new lines, you could invoke \java{threeLine} three times.

\item A common problem-solving technique is to break things down into sub-problems.
Methods allow you to focus on each sub-problem in isolation, and then compose them into a complete solution.

\end{enumerate}

%Perhaps most importantly, organizing your code into multiple methods allows you to test individual parts of your program separately.
%It's easier to get a complex program working if you know that each sub-part works correctly.

%In Section~\ref{methods} we will come back to this question and list some additional benefits of dividing programs into methods.


\section{Classes and methods}

\index{class}
\index{method}

Pulling together the code from the previous section, the complete program looks like this:

\begin{code}
public class NewLine {

    public static void newLine() {
        System.out.println();
    }

    public static void threeLine() {
        newLine();
        newLine();
        newLine();
    }

    public static void main(String[] args) {
        System.out.println("First line.");
        threeLine();
        System.out.println("Second line.");
    }
}
\end{code}

\index{case-sensitive}

The first line is the class definition.
Class names should be capitalized; this convention helps readers tell the difference between classes and methods in your source code.
The \java{NewLine} class contains three \java{void} methods: \java{newLine}, \java{threeLine}, and \java{main}.
Java is a case-sensitive language, so \java{NewLine} and \java{newLine} are considered different.

\subsection{Programs with multiple methods}

\index{order of execution}

When you look at a class definition that contains several methods, it is tempting to read it from top to bottom.
But that is likely to be confusing, because that is not the {\bf order of execution} of the program.

Execution always begins at the first statement of \java{main}, regardless of where it is in the source file.
In the previous example, we deliberately put \java{main} at the bottom of the program.
Statements are executed one at a time, in order, until you reach a method invocation.
Think of method invocations as a detour in the flow of execution.
Instead of going to the next statement, you go to the first line of the invoked method, execute the statements there, and then come back and pick up again where you left off.

That sounds simple enough, but remember that one method can invoke another one.
In the middle of \java{main}, we go off to execute the statements in \java{threeLine}.
But while we are executing \java{threeLine}, we go off to execute \java{newLine}.
Then \java{newLine} invokes \java{println}, which causes yet another detour.

Fortunately, Java is adept at keeping track of where it is.
So when \java{println} completes, it picks up where it left off in \java{newLine}, and then gets back to \java{threeLine}, and then finally gets back to \java{main} so the program can terminate.
In summary, when you read a program, don't read from top to bottom.
Instead, follow the flow of execution.

%Technically, the program does not terminate at the end of \java{main}.
%Instead, execution picks up where it left off in the program that invoked \java{main}, which is the Java interpreter.
%The interpreter takes care of things like deleting windows and general cleanup, and {\em then} the program terminates.


\section{Parameters and arguments}

\index{parameter}
\index{argument}

Some of the methods we have used require arguments, which are values that you provide when you invoke the method.
For example, to find the sine of a number, you have to provide the number.
So \java{sin} takes a \java{double} as an argument.
To print a message, you have to provide the string.
So \java{println} takes a \java{String} as an argument.
Some methods take more than one argument.
For example, \java{Math.pow} takes two \java{double}s: the base and the exponent.

When you use a method, you provide the arguments.
When you write a method, you list the parameters.
The parameter list indicates what arguments are required.
Here's a method that takes a string and prints it twice:

\begin{code}
    public static void printTwice(String s) {
        System.out.println(s);
        System.out.println(s);
    }
\end{code}

\java{printTwice} has a parameter named \java{s} with type \java{String}.
The parameter name hints that it is a \java{String}, but you could use any legal variable name.
When we invoke \java{printTwice}, we have to provide an argument with type \java{String}.
Before the method executes, the argument gets assigned to the parameter.

In this example, the argument \java{"Don't make me say this twice!"} gets assigned to the parameter \java{s}.

\begin{code}
    printTwice("Don't make me say this twice!");
\end{code}

\index{parameter passing}

This process is called {\bf parameter passing} because the value gets passed from outside the method to the inside.
An argument can be any kind of expression, so if you have a \java{String} variable, you can use it as an argument:

\begin{code}
    String argument = "Never say never.";
    printTwice(argument);
\end{code}

The value you provide as an argument must have the same type as the parameter.
For example, if you try:

\begin{code}
    printTwice(17);  // syntax error
\end{code}

You will get the compiler error ``cannot find symbol,'' which might be confusing.
Java is looking for a method named \java{printTwice} that can take an integer.
Since there isn't one in the current class, Java can't find such a ``symbol.''

There are some apparent exceptions to this rule, because sometimes Java converts from one type to another automatically.
For example, \java{Math.sqrt} requires a \java{double} value.
If you run \java{Math.sqrt(25)}, the interger value \java{25} is automatically converted to the floating-point value \java{25.0}.

\java{System.out.println} can accept any type as an argument.
But generally speaking, that is an exception; most methods are not so accommodating.

\subsection{Methods with multiple parameters}
\label{time}

\index{parameter!multiple}
\index{method!multiple parameter}
\index{class!Time}

The syntax for declaring and invoking methods with multiple parameters is a common source of confusion.
For one, you have to declare the type of every parameter separately.

\begin{code}
    public static void printTime(int hour, int minute) {
        System.out.print(hour);
        System.out.print(":");
        System.out.println(minute);
    }
\end{code}

It might be tempting to write ``\java{int hour, minute}'' but that format is only legal for variable declarations, not parameter lists.
Another common source of confusion is that you do not have to declare the types of arguments in a method call.
The following is incorrect:

\begin{code}
    int hour = 11;
    int minute = 59;
    printTime(int hour, int minute);  // syntax error
\end{code}

In this case, Java can tell the type of \java{hour} and \java{minute} by looking at their declarations.
It is unnecessary (and therefore not allowed) to include the type when you pass them as arguments.
The correct syntax is:

\begin{code}
    printTime(hour, minute);
\end{code}

When you call a method, Java {\it copies the value} of any arguments you provide into the method's parameters.
It's common for two methods (e.g., \java{main} and \java{printTime}) to have variables with the same name, to show how data passes from one method to the next.
But remember that these variables are stored in different memory locations.
Changing the value of \java{hour} or \java{minute} in \java{printTime} has no effect on the original variables in \java{main}.


\section{Reading documentation}
\label{sec:apidocs}

\index{documentation}

For a comprehensive example of what methods are like, take a look at the documentation for \java{Scanner}.
You can find it in the Java library (see the link in Section~\ref{sec:library}) or simply do a web search for ``java scanner.''
The latter technique is more useful in the long run, especially as Oracle releases new versions of Java.
Either way, you should get something like Figure~\ref{fig:javadoc}.

\begin{figure}[!h]
\begin{center}
\includegraphics[width=0.9\textwidth]{figs/scanner.png}
\caption{Screenshot of the documentation for \java{Scanner} on Oracle's website.}
\label{fig:javadoc}
\end{center}
\end{figure}

Scroll down to the ``Method Summary'' section.
In the previous chapter, we introduced methods for reading the ``next'' input.
As you can see, the \java{Scanner} class provides quite a few of them.
Click on the link for \java{nextInt}, and it will scroll down to more details:

\begin{stdout}
public int nextInt()
Scans the next token of the input as an int.
\end{stdout}

\index{signature}

The first line is the method's {\bf signature}, which specifies the name of the method, its return type, and parameters.
In this example, \java{nextInt} returns an \java{int}.
The empty parentheses mean that \java{nextInt} has no parameters.
The next line explains what the method does.
The subsequent lines (not shown) describe each parameter (if any) and the return value.
Explanations are often redundant, but the documentation is supposed to fit this standard format.
%The last line describes the exceptions this method might throw.

It might take some time to get comfortable reading this kind of information, but it's well worth the effort.
Knowing what methods a class provides helps you avoid reinventing the wheel.
Whenever you learn about a new class, you should take a quick look at its documentation.
On that note, take a few minutes to review the documentation for \java{System} and \java{String}.


\section{Writing documentation}

\index{Javadoc}

A nice feature of the Java language is the ability to write documentation at the same time you are writing the source code.
That way, the documentation stays in sync with the classes and methods themselves.
In fact, the HTML pages you browsed in the previous section were automatically generated using a tool called {\bf Javadoc}.
This tool is part of the standard JDK, and you can run it directly from DrJava by pressing the {\tt Javadoc} button on the toolbar.

\index{comments!documentation}
\index{documentation comments}

Javadoc parses your source files for {\bf documentation comments} and extracts other relevant information about your class and method definitions.
Given the prevalence of this tool, people sometimes refer to documentation as ``Javadoc comments.''
In contrast to inline comments that begin with {\tt //}, documentation comments begin with {\tt /**} (two stars) and end with {\tt */} (one star).
Anything in between these two tokens becomes part of the documentation.
%As a rule of thumb, you should document every class and every method.

\begin{code}
/**
 * Example program that demonstrates print vs println.
 */
public class Goodbye {

    /**
     * Application entry point; simply prints a greeting.
     */
    public static void main(String[] args) {
        System.out.print("Goodbye, ");  // note the space
        System.out.println("cruel world");
    }

}
\end{code}

This example has perhaps too many comments, since all the program does is print a single message.
But it illustrates the differences between inline and documentation comments:

\begin{itemize}
\item Inline comments tend to be short phrases that help explain complex parts of a method.
Documentation comments are typically complete sentences that begin with a capital letter and end with a period.

\item Documentation comments often span multiple lines.
By convention, each line begins with a {\tt *} that is aligned vertically with the start and end of the comment.

\item Some development environments (e.g., Eclipse and NetBeans) automatically display documentation comments when you hover your mouse over the name of a class or method.

\end{itemize}

Writing documentation and inline comments is essential for making source code readable.
As we discussed in an earlier chapter, people spend the majority of their development time understanding and modifying existing code.
You should not only write good comments for others, but for yourself as well.
When you haven't looked at your own code for a while, it takes a long time to remember how it works (or what you were trying to do) if there's no comments.


\section{Stack diagrams and scope}
\label{stack}

\index{stack diagram}
\index{diagram!stack}

Pulling together the code examples from the previous section, here is a complete
class definition:

\begin{code}
public class PrintTwice {

    public static void printTwice(String s) {
        System.out.println(s);
        System.out.println(s);
    }

    public static void main(String[] args) {
        String argument = "Never say never.";
        printTwice(argument);
    }

}
\end{code}

Parameters and other variables only exist inside their own methods.
Within the confines of \java{main}, there is no such thing as \java{s}.
If you try to use it there, the compiler will complain.
Similarly, inside \java{printTwice} there is no such thing as \java{argument}.
That variable belongs to the \java{main} method.

One way to keep track of where each variable is defined is to draw a {\bf stack diagram}.
The stack diagram for this example looks like this:

\begin{figure}[!h]
\begin{center}
\includegraphics[scale=0.9]{figs/stack.pdf}
\caption{Stack diagram for the \java{PrintTwice} program.}
\end{center}
\end{figure}

\index{frame}

For each method there is a box called a {\bf frame} that contains the method's parameters and variables.
The name of the method appears outside the frame.
The value of each variable is drawn inside a box with the name of the variable beside it.
(Note for people who know too much: this diagram leaves out an important detail about strings that we will explain later.)

Stack diagrams help you to visualize the {\bf scope} of a variable, which is the area of a program where a variable exists.
It's possible to have two variables with the same name in two different methods.
Each only exists within its own method, so they don't interfere with each other.


\section{Tracing with a debugger}

\index{debugger}

Keeping track of variables and methods on paper is a useful skill, and you should practice drawing stack diagrams.
Another way to visualize the scope of variables and the flow of execution is to use a {\bf debugger}.
Regardless which development environment you use, the overall process is the same:

\index{breakpoint}

\begin{enumerate}
\item Set {\bf breakpoints} on lines where you want the program to pause.
\item Step through the code one line at a time and watch what it does.
\item Check the values of variables and see when and how they change.
\end{enumerate}

For example, open any program in DrJava and move the cursor to the first line of \java{main}.
Press Ctrl+B to toggle a breakpoint on the current line; it should now be highlighted in red.
Press Ctrl+Shift+D to turn on Debug Mode; a new pane should appear at the bottom of the window.
(These commands are also available from the {\em Debugger} menu, in case you forget the shortcut keys.)

\index{call stack}

When you run the program, execution pauses at the first breakpoint.
The debug pane shows the {\bf call stack}, with the current method on top of the stack.
You might be surprised to see how many methods were called before the \java{main} method!
To the right are several buttons that allow you to step through the code at your own pace.
You can also press ``Automatic Trace'' to watch DrJava run your code one line at a time.

\begin{figure}[!h]
\begin{center}
\includegraphics[width=\textwidth]{figs/debugger.png}
\caption{Screenshot of the DrJava debugger.
Execution is currently paused on the first line of \java{printTwice}.
There is a breakpoint on the first line of \java{main}.}
\end{center}
\end{figure}

Using a debugger is like having the computer proofread your code out loud.
When the program is paused, you can examine (or even change) the value of any variable using the Interactions Pane.
Tracing allows you to verify how control and data passes from one method to another.
%You can edit your code while debugging it, but the changes won't take effect until after you compile.
%The result can be confusing, so we don't recommend it.
%The debugger may get out of sync if you add or delete multiple lines of code while the program is paused.
You might expect the code do one thing, but then the debugger shows it doing something else.
At that moment, you gain insight about what may be wrong with the code.


\section{Vocabulary}

\begin{description}

% Note: expanded definition from Chapter 1
\term{method}
A named sequence of statements that performs a procedure or function.
Methods may or may not take parameters, and may or may not return a value.

\term{invoke}
To call or run a method, i.e., cause it to execute.

\term{parameter}
A piece of information that a method requires before it can run.
Parameters are variables: they contain values and have types.

\term{argument}
A value that you provide when you invoke a method.
This value must have the same type as the corresponding parameter.

% Note: expanded definition from Chapter 2
\term{composition}
The ability to combine simple expressions and statements into compound expressions and statements, making it possible to use intermediate computations as arguments.

\term{order of execution}
The order in which Java executes methods and statements.
It may not necessarily be from top to bottom, left to right.

\term{parameter passing}
The process of assigning an argument value to a parameter variable.

\term{signature}
The first line of a method that defines its name, return type, and parameters.

\term{Javadoc}
A tool that reads Java source code and generates documentation in HTML format.

\term{documentation}
Comments that describe the technical operation of a class or method.

\term{stack diagram}
A memory diagram that shows which variables belong to which methods at a certain point in the program.
The methods calls are ``stacked'' from top to bottom, in the order of execution.

\term{frame}
A structure (represented by a box in stack diagrams) that contains a method's parameters and variables.

\term{scope}
The area of a program where a variable exists.

\term{debugger}
A tool that allows you to run one statement at a time and see the contents of variables.

\term{breakpoint}
A line of code where the debugger will pause a running program.

\term{call stack}
The history of method calls and where to resume execution after each method returns.

\end{description}


\section{Exercises}

\begin{exercise}

The point of this exercise is to practice reading code and to make sure that you understand the flow of execution through a program with multiple methods.

\begin{enumerate}

\item What is the output of the following program?
Be precise about where there are spaces and where there are newlines.
(Hint: Start by describing in words what \java{ping} and \java{baffle} do when they are invoked.)

\item Draw a stack diagram that shows the state of the program the first time \java{ping} is invoked.

%\item What happens if you add a method call to \java{baffle();} at the end of the \java{ping} method? (We will see why in the next chapter.)

\end{enumerate}

\begin{code}
    public static void zoop() {
        baffle();
        System.out.print("You wugga ");
        baffle();
    }
    public static void main(String[] args) {
        System.out.print("No, I ");
        zoop();
        System.out.print("I ");
        baffle();
    }
    public static void baffle() {
        System.out.print("wug");
        ping();
    }
    public static void ping() {
        System.out.println(".");
    }
\end{code}

\end{exercise}

\begin{exercise}

What is the difference between a variable and a method?
In terms of their syntax, how does the Java compiler tell the difference between the two?

%A variable is a {\em location of data}, whereas a method is a {\em location of code}.
%In Java, methods always have parentheses, even if they have no arguments like \java{System.out.println()}.

\end{exercise}

\begin{exercise}

Draw a stack diagram that shows the state of the program in Section~\ref{time} when \java{main} invokes \java{printTime} with the arguments \java{11} and \java{59}.

\end{exercise}

\begin{exercise}

The point of this exercise is to make sure you understand how to write and invoke methods that take parameters.

\begin{enumerate}
\item Write the first line of a method named \java{zool} that takes three parameters: an \java{int} and two \java{Strings}.

\item Write a line of code that calls \java{zool}, passing as arguments the value \java{11}, the name of your first pet, and the name of the street you grew up on.
\end{enumerate}

\end{exercise}

\begin{exercise}

The purpose of this exercise is to take code from a previous exercise and encapsulate it in a method that takes parameters.
You should start with a working solution to Exercise~\ref{ex:date}.

\begin{enumerate}

\item Write a method called \java{printAmerican} that takes the day, date, month and year as parameters and that prints them in American format.

\item Test your method by invoking it from \java{main} and passing appropriate arguments.
The output should look something like this (except that the date might be different):

\begin{stdout}
Saturday, July 16, 2011
\end{stdout}

\item Once you have debugged \java{printAmerican}, write another method called \java{printEuropean} that prints the date in European format.

\end{enumerate}
\end{exercise}


%\input{todo-tex/chapter07.tex}
%\input{todo-tex/chapter08.tex}
%\input{todo-tex/chapter09.tex}
%\input{todo-tex/chapter11.tex}
%\input{todo-tex/chapter12.tex}
%\input{todo-tex/chapter13.tex}
%\input{todo-tex/chapter14.tex}
%\input{todo-tex/chapter15.tex}
%\input{todo-tex/chapter16.tex}

\backmatter
\appendix

%\input{todo-tex/chapter17.tex}
%\input{todo-tex/chapter18.tex}
%\input{todo-tex/chapter19.tex}
%\input{todo-tex/chapter20.tex}

\printindex
\cleardoublepage

\end{document}
